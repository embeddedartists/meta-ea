diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index cb770c3..073bdd9 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -270,7 +270,17 @@ dtb-$(CONFIG_ARCH_MXC) += \
 	imx7d-sdb-sim.dtb \
 	imx7d-sdb-touch.dtb \
 	imx7d-sdb-wm8960.dtb \
-	imx7d-sdb-m4.dtb
+	imx7d-sdb-m4.dtb \
+	imx6sxea-com-kit.dtb \
+	imx6sxea-com-kit-m4.dtb \
+	imx6sxea-com-kit-lvds.dtb \
+	imx6sxea-com-kit-rgb.dtb \
+	imx6qea-com-kit.dtb \
+	imx6dlea-com-kit.dtb \
+	imx6ulea-com-kit.dtb \
+	imx6ulea-com-kit-rf.dtb \
+	imx7dea-ucom-kit.dtb \
+	imx7dea-ucom-kit-lvds.dtb
 dtb-$(CONFIG_ARCH_MXS) += imx23-evk.dtb \
 	imx23-olinuxino.dtb \
 	imx23-stmp378x_devb.dtb \
diff --git a/arch/arm/boot/dts/imx6dlea-com-kit.dts b/arch/arm/boot/dts/imx6dlea-com-kit.dts
new file mode 100644
index 0000000..3c06317
--- /dev/null
+++ b/arch/arm/boot/dts/imx6dlea-com-kit.dts
@@ -0,0 +1,868 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+
+#include "imx6dlea-com.dtsi"
+
+
+/ {
+	aliases {
+		mxcfb0 = &mxcfb1;
+		mxcfb1 = &mxcfb2;
+		mxcfb2 = &mxcfb3;
+		mxcfb3 = &mxcfb4;
+
+		/* Aliases to allow u-boot to modify the device tree */
+		fb_hdmi = &mxcfb2;
+		fb_rgb = &mxcfb3;
+		fb_lvds0 = &mxcfb1;
+		fb_lvds1 = &mxcfb4;
+		t_rgb = &t_lcd;
+		t_lvds0 = &t_lvds;
+		t_lvds1 = &t_lvds2;
+		bl_rgb = &backlight_lcd;
+		bl_lvds = &backlight_lvds;
+		rgb = &lcd;
+		ldb = &ldb;
+		ts_con_rgb = &i2c1;
+		ts_con_lvds0 = &i2c1;
+		ts_con_lvds1 = &i2c2;
+	};
+
+
+	regulators {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_usb_otg_vbus: regulator@0 {
+			compatible = "regulator-fixed";
+			reg = <0>;
+			regulator-name = "usb_otg_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio3 22 0>;
+			enable-active-high;
+		};
+
+		reg_usb_h1_vbus: regulator@1 {
+			compatible = "regulator-fixed";
+			reg = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_usb_h1>;
+			regulator-name = "usb_h1_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio1 0 0>;
+			enable-active-high;
+		};
+
+		/* For uSD/MMC socket on EA COM Base Board */
+		reg_vcc_sd2: regulator@2 {
+			compatible = "regulator-fixed";
+			reg = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_vcc_sd2>;
+			regulator-name = "VCC_SD2";
+			regulator-min-microvolt = <3000000>;
+			regulator-max-microvolt = <3000000>;
+			gpio = <&gpio7 8 GPIO_ACTIVE_HIGH>;
+			enable-active-high;
+		};
+
+		reg_vcc_can: regulator@4 {
+			compatible = "regulator-fixed";
+			reg = <4>;
+			regulator-name = "VCC_CAN";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			regulator-always-on;
+			/*regulator-boot-on;*/
+		};
+	};
+
+	sound {
+		compatible = "fsl,imx-audio-wm8731";
+		model = "wm8731-audio";
+		ssi-controller = <&ssi2>;
+		src-port = <2>;
+		ext-port = <3>;
+		audio-codec = <&codec>;
+		audio-routing = "LOUT", "ROUT", "LLINEIN", "RLINEIN";
+	};
+
+	sound-hdmi {
+		compatible = "fsl,imx6q-audio-hdmi",
+			     "fsl,imx-audio-hdmi";
+		model = "imx-audio-hdmi";
+		hdmi-controller = <&hdmi_audio>;
+	};
+
+	mxcfb1: fb@0 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "ldb";
+		interface_pix_fmt = "RGB666";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		dispctrl-gpios = <&gpio3 20 GPIO_ACTIVE_HIGH>, <&gpio2 27 GPIO_ACTIVE_HIGH>;
+		status = "disabled";
+	};
+
+	mxcfb2: fb@1 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "hdmi";
+		interface_pix_fmt = "RGB24";
+		mode_str ="1920x1080M@60";
+		default_bpp = <24>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	mxcfb3: fb@2 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "lcd";
+		interface_pix_fmt = "RGB24";
+		mode_str ="EA7-WVGA";
+		default_bpp = <32>;
+		int_clk = <0>;
+		late_init = <0>;
+		dispctrl-gpios = <&gpio6 31 GPIO_ACTIVE_HIGH>, <&gpio5 0 GPIO_ACTIVE_HIGH>;
+		status = "disabled";
+	};
+
+	mxcfb4: fb@3 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "ldb";
+		interface_pix_fmt = "RGB666";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		dispctrl-gpios = <&gpio6 31 GPIO_ACTIVE_HIGH>, <&gpio5 0 GPIO_ACTIVE_HIGH>;
+		status = "disabled";
+	};
+
+	lcd: lcd@0 {
+		compatible = "fsl,lcd";
+		ipu_id = <0>;
+		disp_id = <0>;
+		default_ifmt = "RGB24";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_ipu1>;
+		status = "okay";
+	};
+
+	/* Backlight for LVDS 0 and 1 */
+	backlight_lvds: backlight1 {
+		compatible = "pwm-backlight";
+		pwms = <&pwm1 0 5000000>;
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <7>;
+		status = "okay";
+	};
+
+	/* Backlight for RGB */
+	backlight_lcd: backlight2 {
+		compatible = "pwm-backlight";
+		pwms = <&pwm2 0 5000000>;
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <7>;
+		status = "okay";
+	};
+
+	v4l2_cap_0 {
+		compatible = "fsl,imx6q-v4l2-capture";
+		ipu_id = <0>;
+		csi_id = <0>;
+		mclk_source = <0>;
+		status = "okay";
+	};
+
+	v4l2_cap_1 {
+		compatible = "fsl,imx6q-v4l2-capture";
+		ipu_id = <0>;
+		csi_id = <1>;
+		mclk_source = <0>;
+		status = "okay";
+	};
+
+	v4l2_out {
+		compatible = "fsl,mxc_v4l2_output";
+		status = "okay";
+	};
+
+        gpio-keys {
+                compatible = "gpio-keys";
+                pinctrl-names = "default";
+                pinctrl-0 = <&pinctrl_gpio_keys>;
+
+                power {
+                        label = "Power Button";
+                        gpios = <&gpio3 29 1>;
+                        gpio-key,wakeup;
+                        linux,code = <KEY_POWER>;
+                };
+
+        };
+
+};
+
+&audmux {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_audmux>;
+	status = "okay";
+};
+
+&i2c1 {
+	
+	codec: wm8731@1a {
+		compatible = "wlf,wm8731";
+		reg = <0x1a>;
+		clocks = <&clks IMX6QDL_CLK_CKO>;
+		AVDD-supply = <&vgen4_reg>;
+		HPVDD-supply = <&vgen4_reg>;
+		DCVDD-supply = <&vgen4_reg>;
+		DBVDD-supply = <&vgen4_reg>;
+	};
+
+	/* AR1021 touch controller through RGB display interface connector on Carrier Board */
+	ar1021_rgb@4d {
+		compatible = "microchip,ar1021-i2c";
+		reg = <0x4d>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_rgb_connector>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <18 IRQ_TYPE_EDGE_FALLING>;
+		ar1021,swap_xy;
+		ar1021,invert_x;
+		#ar1021,invert_y;
+		status = "disabled";
+	};
+	/* AR1021 touch controller through LVDS0 display interface connector on Carrier Board */
+	ar1021_lvds0@4d {
+		compatible = "microchip,ar1021-i2c";
+		reg = <0x4d>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lvds0_connector>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+		ar1021,swap_xy;
+		ar1021,invert_x;
+		#ar1021,invert_y;
+		status = "disabled";
+	};
+	/* eGalax touch controller through RGB display interface connector on Carrier Board */
+	egalax_ts_rgb@04 {
+		compatible = "eeti,egalax_ts";
+		reg = <0x04>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_rgb_connector>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <18 IRQ_TYPE_EDGE_FALLING>;
+		wakeup-gpios = <&gpio2 18 GPIO_ACTIVE_HIGH>;
+		status = "disabled";
+	};
+	/* eGalax touch controller through LVDS0 display interface connector on Carrier Board */
+	egalax_ts_lvds0@04 {
+		compatible = "eeti,egalax_ts";
+		reg = <0x04>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lvds0_connector>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+		wakeup-gpios = <&gpio3 13 GPIO_ACTIVE_HIGH>;
+		status = "disabled";
+	};
+
+	/* FocalTech touch controller through RGB display interface connector on Carrier Board */
+	edt-ft5x06_rgb@38 {
+		compatible = "edt,edt-ft5x06";
+		reg = <0x38>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_rgb_connector>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <18 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&gpio3 14 GPIO_ACTIVE_HIGH>;
+		status = "disabled";
+	};
+	/* FocalTech touch controller through LVDS0 display interface connector on Carrier Board */
+	edt-ft5x06_lvds0@38 {
+		compatible = "edt,edt-ft5x06";
+		reg = <0x38>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lvds0_connector>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+		status = "disabled";
+	};
+
+	/* Ilitek touch controller through RGB display interface connector on Carrier Board */
+	ilitek_aim_rgb@41 {
+		compatible = "ilitek,ilitek_aim";
+		reg = <0x41>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_rgb_connector>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <18 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&gpio3 14 GPIO_ACTIVE_HIGH>;
+		status = "disabled";
+	};
+	/* Ilitek touch controller through LVDS0 display interface connector on Carrier Board */
+	ilitek_aim_lvds0@41 {
+		compatible = "ilitek,ilitek_aim";
+		reg = <0x41>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lvds0_connector>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+		status = "disabled";
+	};
+
+	/* Sitronix touch controller through RGB display interface connector on Carrier Board */
+	sitronix_rgb@55 {
+		compatible = "sitronix,sitronix_i2c";
+		reg = <0x55>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_rgb_connector>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <18 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&gpio3 14 GPIO_ACTIVE_HIGH>;
+		status = "disabled";
+	};
+	/* Sitronix touch controller through LVDS0 display interface connector on Carrier Board */
+	sitronix_lvds0@55 {
+		compatible = "sitronix,sitronix_i2c";
+		reg = <0x55>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lvds0_connector>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+		status = "disabled";
+	};
+};
+
+&i2c2 {
+	/* AR1021 touch controller through LVDS1 display interface connector on Carrier Board */
+	ar1021_lvds1@4d {
+		compatible = "microchip,ar1021-i2c";
+		reg = <0x4d>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lvds1_connector>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <31 IRQ_TYPE_EDGE_FALLING>;
+		ar1021,swap_xy;
+		ar1021,invert_x;
+		#ar1021,invert_y;
+		status = "disabled";
+	};
+
+	/* eGalax touch controller through LVDS1 display interface connector on Carrier Board */
+	egalax_ts_lvds1@04 {
+		compatible = "eeti,egalax_ts";
+		reg = <0x04>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lvds1_connector>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <31 IRQ_TYPE_EDGE_FALLING>;
+		wakeup-gpios = <&gpio2 31 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	/* FocalTech touch controller through LVDS1 display interface connector on Carrier Board */
+	edt-ft5x06_lvds1@38 {
+		compatible = "edt,edt-ft5x06";
+		reg = <0x38>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lvds1_connector>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <31 IRQ_TYPE_EDGE_FALLING>;
+		status = "disabled";
+	};
+
+	/* Ilitek touch controller through LVDS1 display interface connector on Carrier Board */
+	ilitek_aim_lvds1@41 {
+		compatible = "ilitek,ilitek_aim";
+		reg = <0x41>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lvds1_connector>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <31 IRQ_TYPE_EDGE_FALLING>;
+		status = "disabled";
+	};
+
+	/* Sitronix touch controller through LVDS1 display interface connector on Carrier Board */
+	sitronix_lvds1@55 {
+		compatible = "sitronix,sitronix_i2c";
+		reg = <0x55>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lvds1_connector>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <31 IRQ_TYPE_EDGE_FALLING>;
+		status = "disabled";
+	};
+};
+
+&i2c3 {
+	hdmi: edid@50 {
+		compatible = "fsl,imx6-hdmi-i2c";
+		reg = <0x50>;
+	};
+};
+
+
+&iomuxc {
+	pinctrl-0 = <&pinctrl_hog>, <&pinctrl_can_gpios>, <&pinctrl_lcd_gpios>;
+
+	imx6qea-com-kit {
+
+		pinctrl_audmux: audmuxgrp {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT7__AUD3_RXD		0x130b0
+				MX6QDL_PAD_CSI0_DAT4__AUD3_TXC		0x130b0
+				MX6QDL_PAD_CSI0_DAT5__AUD3_TXD		0x110b0
+				MX6QDL_PAD_CSI0_DAT6__AUD3_TXFS		0x130b0
+				MX6QDL_PAD_GPIO_19__CCM_CLKO1		0x130b0
+			>;
+		};
+		
+		pinctrl_rgb_connector: rgb_connector_grp {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_A20__GPIO2_IO18          0x1f0b0
+				MX6QDL_PAD_EIM_DA14__GPIO3_IO14		0x1f0b0
+			>;
+		};
+
+		pinctrl_lvds0_connector: lvds0_connector_grp {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_DA13__GPIO3_IO13		0x1f0b0
+			>;
+		};
+
+		pinctrl_lvds1_connector: lvds1_connector_grp {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_EB3__GPIO2_IO31		0x1f0b0
+			>;
+		};
+
+		pinctrl_hdmi_cec: hdmicecgrp {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_A25__EIM_ADDR25 0x1f8b0
+			>;
+		};
+
+		pinctrl_hdmi_hdcp: hdmihdcpgrp {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL3__HDMI_TX_DDC_SCL 0x4001b8b1
+				MX6QDL_PAD_KEY_ROW3__HDMI_TX_DDC_SDA 0x4001b8b1
+			>;
+		};
+
+
+		pinctrl_ipu1: ipu1grp {
+			fsl,pins = <
+				MX6QDL_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK 0x10
+				MX6QDL_PAD_DI0_PIN15__IPU1_DI0_PIN15       0x10
+				MX6QDL_PAD_DI0_PIN2__IPU1_DI0_PIN02        0x10
+				MX6QDL_PAD_DI0_PIN3__IPU1_DI0_PIN03        0x10
+				MX6QDL_PAD_DI0_PIN4__IPU1_DI0_PIN04        0x80000000
+				MX6QDL_PAD_DISP0_DAT0__IPU1_DISP0_DATA00   0x10
+				MX6QDL_PAD_DISP0_DAT1__IPU1_DISP0_DATA01   0x10
+				MX6QDL_PAD_DISP0_DAT2__IPU1_DISP0_DATA02   0x10
+				MX6QDL_PAD_DISP0_DAT3__IPU1_DISP0_DATA03   0x10
+				MX6QDL_PAD_DISP0_DAT4__IPU1_DISP0_DATA04   0x10
+				MX6QDL_PAD_DISP0_DAT5__IPU1_DISP0_DATA05   0x10
+				MX6QDL_PAD_DISP0_DAT6__IPU1_DISP0_DATA06   0x10
+				MX6QDL_PAD_DISP0_DAT7__IPU1_DISP0_DATA07   0x10
+				MX6QDL_PAD_DISP0_DAT8__IPU1_DISP0_DATA08   0x10
+				MX6QDL_PAD_DISP0_DAT9__IPU1_DISP0_DATA09   0x10
+				MX6QDL_PAD_DISP0_DAT10__IPU1_DISP0_DATA10  0x10
+				MX6QDL_PAD_DISP0_DAT11__IPU1_DISP0_DATA11  0x10
+				MX6QDL_PAD_DISP0_DAT12__IPU1_DISP0_DATA12  0x10
+				MX6QDL_PAD_DISP0_DAT13__IPU1_DISP0_DATA13  0x10
+				MX6QDL_PAD_DISP0_DAT14__IPU1_DISP0_DATA14  0x10
+				MX6QDL_PAD_DISP0_DAT15__IPU1_DISP0_DATA15  0x10
+				MX6QDL_PAD_DISP0_DAT16__IPU1_DISP0_DATA16  0x10
+				MX6QDL_PAD_DISP0_DAT17__IPU1_DISP0_DATA17  0x10
+				MX6QDL_PAD_DISP0_DAT18__IPU1_DISP0_DATA18  0x10
+				MX6QDL_PAD_DISP0_DAT19__IPU1_DISP0_DATA19  0x10
+				MX6QDL_PAD_DISP0_DAT20__IPU1_DISP0_DATA20  0x10
+				MX6QDL_PAD_DISP0_DAT21__IPU1_DISP0_DATA21  0x10
+				MX6QDL_PAD_DISP0_DAT22__IPU1_DISP0_DATA22  0x10
+				MX6QDL_PAD_DISP0_DAT23__IPU1_DISP0_DATA23  0x10
+			>;
+		};
+
+
+		pinctrl_pwm1: pwm1grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_DAT3__PWM1_OUT		0x1b0b1
+			>;
+		};
+
+		pinctrl_pwm2: pwm2grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_DAT2__PWM2_OUT		0x1b0b1
+			>;
+		};
+
+		pinctrl_uart1: uart1grp {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT10__UART1_TX_DATA	0x1b0b1
+				MX6QDL_PAD_CSI0_DAT11__UART1_RX_DATA	0x1b0b1
+			>;
+		};
+
+		pinctrl_uart4: uart4grp {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT12__UART4_TX_DATA	0x1b0b1
+				MX6QDL_PAD_CSI0_DAT13__UART4_RX_DATA	0x1b0b1
+			>;
+		};
+
+		pinctrl_uart5: uart5grp {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT14__UART5_TX_DATA	0x1b0b1
+				MX6QDL_PAD_CSI0_DAT15__UART5_RX_DATA	0x1b0b1
+				MX6QDL_PAD_CSI0_DAT19__UART5_CTS_B	0x1b0b1
+				MX6QDL_PAD_CSI0_DAT18__UART5_RTS_B	0x1b0b1
+
+				/* RF_ON */
+				/* MX6QDL_PAD_EIM_D23__GPIO3_IO23	0x17059*/
+
+				/* RF_DTR */
+				MX6QDL_PAD_CSI0_DAT17__GPIO6_IO03 	0x17059
+
+				/* RF_CD */
+				MX6QDL_PAD_CSI0_DAT16__GPIO6_IO02	0x17059
+
+				/* RF_RST */
+				MX6QDL_PAD_EIM_A19__GPIO2_IO19		0x17059
+			>;
+		};
+
+		pinctrl_usbotg: usbotggrp {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_RX_ER__USB_OTG_ID	0x17059
+			>;
+		};
+
+		pinctrl_usdhc2: usdhc2grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD2_CMD__SD2_CMD		0x17059
+				MX6QDL_PAD_SD2_CLK__SD2_CLK		0x10059
+				MX6QDL_PAD_SD2_DAT0__SD2_DATA0		0x17059
+				MX6QDL_PAD_SD2_DAT1__SD2_DATA1		0x17059
+				MX6QDL_PAD_SD2_DAT2__SD2_DATA2		0x17059
+				MX6QDL_PAD_SD2_DAT3__SD2_DATA3		0x17059
+				MX6QDL_PAD_NANDF_WP_B__GPIO6_IO09	0x17059
+			>;
+		};
+
+		pinctrl_usb_h1: usbh1grp {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_0__GPIO1_IO00	0x1b0b0
+			>;
+		};
+
+		pinctrl_vcc_sd2: vccsd2grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_RST__GPIO7_IO08			0x17059
+			>;
+		};
+
+		pinctrl_can_gpios: can-gpios {
+			fsl,pins = <
+				MX6QDL_PAD_NANDF_CS0__GPIO6_IO11	0x17059
+			>;
+		}; 
+
+		pinctrl_flexcan1: flexcan1grp {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_ROW2__FLEXCAN1_RX	0x1b020
+				MX6QDL_PAD_KEY_COL2__FLEXCAN1_TX	0x1b020
+			>;
+		};
+
+		pinctrl_flexcan2: flexcan2grp {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_ROW4__FLEXCAN2_RX	0x1b020
+				MX6QDL_PAD_KEY_COL4__FLEXCAN2_TX	0x1b020
+			>;
+		};
+
+		pinctrl_lcd_gpios: lcd-gpios {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_BCLK__GPIO6_IO31		0x17059
+				MX6QDL_PAD_EIM_WAIT__GPIO5_IO00		0x17059
+				MX6QDL_PAD_EIM_D20__GPIO3_IO20		0x17059
+				MX6QDL_PAD_EIM_LBA__GPIO2_IO27		0x17059
+			>;
+		};
+
+                pinctrl_gpio_keys: gpio_keysgrp {
+                        fsl,pins = <
+                                MX6QDL_PAD_EIM_D29__GPIO3_IO29 0x80000000
+                        >;
+                };
+
+ 	};
+};
+
+&dcic1 {
+	dcic_id = <0>;
+	dcic_mux = "dcic-hdmi";
+	status = "okay";
+};
+
+&dcic2 {
+	dcic_id = <1>;
+	dcic_mux = "dcic-lvds1";
+	status = "okay";
+};
+
+
+&hdmi_audio {
+	status = "okay";
+};
+
+&hdmi_cec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hdmi_cec>;
+	status = "okay";
+};
+
+&hdmi_core {
+	ipu_id = <0>;
+	disp_id = <1>;
+	status = "okay";
+};
+
+&hdmi_video {
+	fsl,phy_reg_vlev = <0x0294>;
+	fsl,phy_reg_cksymtx = <0x800d>;
+	status = "okay";
+};
+
+&lcd {
+	status = "okay";
+	display = <&display0>;
+
+	display0: display {
+		bits-per-pixel = <32>;
+		bus-width = <24>;
+
+		display-timings {
+			native-mode = <&t_lcd>;
+			t_lcd: t_lcd_default {
+				/* values may be changed in bootscript, default is for EA 7" display */
+				clock-frequency = <33500000>;
+				hactive = <800>;
+				vactive = <480>;
+				hback-porch = <89>;
+				hfront-porch = <164>;
+				vback-porch = <75>;/*<23>;*/
+				vfront-porch = <75>;/*<10>;*/
+				hsync-len = <10>;
+				vsync-len = <10>;
+				hsync-active = <0>;
+				vsync-active = <0>;
+				de-active = <1>;
+				pixelclk-active = <1>;
+			};
+		};
+	};
+};
+
+&ldb {
+	status = "okay";
+
+	lvds-channel@0 {
+		fsl,data-mapping = "spwg";
+		fsl,data-width = <18>;
+		status = "okay";
+
+		display-timings {
+			native-mode = <&t_lvds>;
+			t_lvds: t_lvds_default {
+				/* values may be changed in bootscript */
+				clock-frequency = <65000000>;
+				hactive = <1024>;
+				vactive = <768>;
+				hback-porch = <220>;
+				hfront-porch = <40>;
+				vback-porch = <21>;
+				vfront-porch = <7>;
+				hsync-len = <60>;
+				vsync-len = <10>;
+			};
+		};
+	};
+
+	lvds-channel@1 {
+		fsl,data-mapping = "spwg";
+		fsl,data-width = <18>;
+		primary;
+		status = "okay";
+
+		display-timings {
+			native-mode = <&t_lvds2>;
+			t_lvds2: t_lvds2_default {
+				/* values may be changed in bootscript */
+				clock-frequency = <65000000>;
+				hactive = <1024>;
+				vactive = <768>;
+				hback-porch = <220>;
+				hfront-porch = <40>;
+				vback-porch = <21>;
+				vfront-porch = <7>;
+				hsync-len = <60>;
+				vsync-len = <10>;
+			};
+		};
+	};
+};
+
+&mipi_csi {
+	status = "okay";
+	ipu_id = <0>;
+	csi_id = <1>;
+	v_channel = <0>;
+	lanes = <2>;
+};
+
+/* mipi_dsi has the same ip_id/disp_id as the hdmi_core so only enble one of the */
+&mipi_dsi {
+	dev_id = <0>;
+	disp_id = <1>;
+	lcd_panel = "TRULY-WVGA";
+	status = "disabled";
+};
+
+&pcie {
+	reset-gpio = <&gpio1 1 0>;
+	status = "okay";
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm1>;
+	status = "okay";
+};
+
+&pwm2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm2>;
+	status = "okay";
+};
+
+&ssi2 {
+	fsl,mode = "i2s-master";
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	status = "okay";
+};
+
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart4>;
+	status = "okay";
+};
+
+&uart5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart5>;
+	status = "okay";
+
+	fsl,uart-has-rtscts;
+	#fsl,dte-mode;
+};
+
+&usbh1 {
+	vbus-supply = <&reg_usb_h1_vbus>;
+	status = "okay";
+};
+
+&usbotg {
+	vbus-supply = <&reg_usb_otg_vbus>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbotg>;
+	disable-over-current;
+	status = "okay";
+};
+
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2>;
+	bus-width = <4>;
+	vmmc-supply = <&reg_vcc_sd2>;
+	cd-gpios = <&gpio6 9 0>;
+	no-1-8-v;
+	keep-power-in-suspend;
+	enable-sdio-wakeup;
+	status = "okay";
+};
+
+
+&wdog1 {
+	status = "okay";
+};
+
+&wdog2 {
+	status = "disabled";
+};
+
+
+&ldb {
+	lvds-channel@0 {
+		crtc = "ipu1-di0";
+	};
+
+	lvds-channel@1 {
+		crtc = "ipu1-di1";
+	};
+};
+
+
+
+&mxcfb1 {
+	status = "okay";
+};
+
+
+&mxcfb2 {
+	status = "okay";
+};
+
+
+&flexcan1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1>;
+	xceiver-supply = <&reg_vcc_can>; 
+	trx-en-gpio = <&gpio6 11 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+&flexcan2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan2>;
+	xceiver-supply = <&reg_vcc_can>; 
+	trx-en-gpio = <&gpio6 11 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+
diff --git a/arch/arm/boot/dts/imx6dlea-com.dtsi b/arch/arm/boot/dts/imx6dlea-com.dtsi
new file mode 100644
index 0000000..5fe0227
--- /dev/null
+++ b/arch/arm/boot/dts/imx6dlea-com.dtsi
@@ -0,0 +1,302 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#include <dt-bindings/input/input.h>
+#include "imx6dl.dtsi"
+
+
+/ {
+	model = "Embedded Artists i.MX6 DualLite COM Board";
+	compatible = "fsl,imx6dlea-com", "fsl,imx6dl";
+
+
+	memory {
+		reg = <0x10000000 0x40000000>;
+	};
+
+
+};
+
+
+&cpu0 {
+	arm-supply = <&sw1a_reg>;
+	soc-supply = <&sw1c_reg>;
+};
+
+&gpc {
+	/* use ldo-bypass, u-boot will check it and configure */
+	fsl,ldo-bypass = <1>;
+	fsl,wdog-reset = <1>;
+};
+
+
+&fec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet>;
+	phy-mode = "rgmii";
+	phy-reset-gpios = <&gpio1 25 0>;
+	fsl,magic-packet;
+	status = "okay";
+};
+
+&ecspi1 {
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio2 30 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi1>;
+	status = "okay";
+
+	flash0: n25q256a@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "micron,n25q256a";
+		spi-max-frequency = <29000000>;
+		spi-nor,ddr-quad-read-dummy = <6>;
+		reg = <0>;
+	};
+
+};
+
+
+/* For eMMC socket on EA COM Board */
+&usdhc4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc4>;
+	bus-width = <8>;
+	non-removable;
+	no-1-8-v;
+	keep-power-in-suspend;
+	status = "okay";
+};
+
+&i2c1 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	status = "okay";
+
+	pmic: pfuze100@08 {
+		compatible = "fsl,pfuze100";
+		reg = <0x08>;
+
+		regulators {
+			sw1a_reg: sw1ab {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			sw1c_reg: sw1c {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			sw2_reg: sw2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3a_reg: sw3a {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3b_reg: sw3b {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw4_reg: sw4 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			swbst_reg: swbst {
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5150000>;
+			};
+
+			snvs_reg: vsnvs {
+				regulator-min-microvolt = <1000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vref_reg: vrefddr {
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vgen1_reg: vgen1 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen2_reg: vgen2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen3_reg: vgen3 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			vgen4_reg: vgen4 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen5_reg: vgen5 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen6_reg: vgen6 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+		};
+	};
+
+
+	at24@55 {
+		compatible = "at,24c64";
+		pagesize = <32>;
+		reg = <0x55>;
+	};
+};
+
+
+&i2c2 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2>;
+	status = "okay";
+
+};
+
+&i2c3 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3>;
+	status = "okay";
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog>;
+
+	imx6qea-com {
+		pinctrl_hog: hoggrp {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D22__GPIO3_IO22  0x80000000
+				MX6QDL_PAD_ENET_CRS_DV__GPIO1_IO25 0x80000000
+				MX6QDL_PAD_EIM_D23__GPIO3_IO23 0x80000000
+				MX6QDL_PAD_GPIO_9__WDOG1_B 	0x80000000
+			>;
+		};
+
+
+		pinctrl_ecspi1: ecspi1grp {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D17__ECSPI1_MISO	0x100b1
+				MX6QDL_PAD_EIM_D18__ECSPI1_MOSI	0x100b1
+				MX6QDL_PAD_EIM_D16__ECSPI1_SCLK	0x100b1
+			>;
+		};
+
+		pinctrl_enet: enetgrp {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_MDIO__ENET_MDIO		0x1b0b0
+				MX6QDL_PAD_ENET_MDC__ENET_MDC		0x1b0b0
+				MX6QDL_PAD_RGMII_TXC__RGMII_TXC		0x1b0b0
+				MX6QDL_PAD_RGMII_TD0__RGMII_TD0		0x1b0b0
+				MX6QDL_PAD_RGMII_TD1__RGMII_TD1		0x1b0b0
+				MX6QDL_PAD_RGMII_TD2__RGMII_TD2		0x1b0b0
+				MX6QDL_PAD_RGMII_TD3__RGMII_TD3		0x1b0b0
+				MX6QDL_PAD_RGMII_TX_CTL__RGMII_TX_CTL	0x1b0b0
+				MX6QDL_PAD_ENET_REF_CLK__ENET_TX_CLK	0x1b0b0
+				MX6QDL_PAD_RGMII_RXC__RGMII_RXC		0x1b0b0
+				MX6QDL_PAD_RGMII_RD0__RGMII_RD0		0x1b0b0
+				MX6QDL_PAD_RGMII_RD1__RGMII_RD1		0x1b0b0
+				MX6QDL_PAD_RGMII_RD2__RGMII_RD2		0x1b0b0
+				MX6QDL_PAD_RGMII_RD3__RGMII_RD3		0x1b0b0
+				MX6QDL_PAD_RGMII_RX_CTL__RGMII_RX_CTL	0x1b0b0
+				MX6QDL_PAD_GPIO_16__ENET_REF_CLK	0x4001b0a8
+			>;
+		};
+
+		pinctrl_enet_irq: enetirqgrp {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_TXD0__GPIO1_IO30		0x000b1
+			>;
+		};
+
+
+		pinctrl_i2c1: i2c1grp {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT8__I2C1_SDA		0x4001b8b1
+				MX6QDL_PAD_CSI0_DAT9__I2C1_SCL		0x4001b8b1
+			>;
+		};
+
+		pinctrl_i2c2: i2c2grp {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL3__I2C2_SCL		0x4001b8b1
+				MX6QDL_PAD_KEY_ROW3__I2C2_SDA		0x4001b8b1
+			 >;
+		};
+
+		pinctrl_i2c3: i2c3grp {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_5__I2C3_SCL		0x4001b8b1
+				MX6QDL_PAD_GPIO_6__I2C3_SDA		0x4001b8b1
+			>;
+		};
+
+
+		pinctrl_usdhc4: usdhc4grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD4_CMD__SD4_CMD		0x17059
+				MX6QDL_PAD_SD4_CLK__SD4_CLK		0x10059
+				MX6QDL_PAD_SD4_DAT0__SD4_DATA0		0x17059
+				MX6QDL_PAD_SD4_DAT1__SD4_DATA1		0x17059
+				MX6QDL_PAD_SD4_DAT2__SD4_DATA2		0x17059
+				MX6QDL_PAD_SD4_DAT3__SD4_DATA3		0x17059
+				MX6QDL_PAD_SD4_DAT4__SD4_DATA4		0x17059
+				MX6QDL_PAD_SD4_DAT5__SD4_DATA5		0x17059
+				MX6QDL_PAD_SD4_DAT6__SD4_DATA6		0x17059
+				MX6QDL_PAD_SD4_DAT7__SD4_DATA7		0x17059
+			>;
+		};
+
+
+	};
+};
+
+
+
+
+
diff --git a/arch/arm/boot/dts/imx6qea-com-kit.dts b/arch/arm/boot/dts/imx6qea-com-kit.dts
new file mode 100644
index 0000000..c5900c1
--- /dev/null
+++ b/arch/arm/boot/dts/imx6qea-com-kit.dts
@@ -0,0 +1,890 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+
+#include "imx6qea-com.dtsi"
+
+
+/ {
+	aliases {
+		mxcfb0 = &mxcfb1;
+		mxcfb1 = &mxcfb2;
+		mxcfb2 = &mxcfb3;
+		mxcfb3 = &mxcfb4;
+
+		/* Aliases to allow u-boot to modify the device tree */
+		fb_hdmi = &mxcfb2;
+		fb_rgb = &mxcfb3;
+		fb_lvds0 = &mxcfb1;
+		fb_lvds1 = &mxcfb4;
+		t_rgb = &t_lcd;
+		t_lvds0 = &t_lvds;
+		t_lvds1 = &t_lvds2;
+		bl_rgb = &backlight_lcd;
+		bl_lvds = &backlight_lvds;
+		rgb = &lcd;
+		ldb = &ldb;
+		ts_con_rgb = &i2c1;
+		ts_con_lvds0 = &i2c1;
+		ts_con_lvds1 = &i2c2;
+	};
+
+
+	regulators {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_usb_otg_vbus: regulator@0 {
+			compatible = "regulator-fixed";
+			reg = <0>;
+			regulator-name = "usb_otg_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio3 22 0>;
+			enable-active-high;
+		};
+
+		reg_usb_h1_vbus: regulator@1 {
+			compatible = "regulator-fixed";
+			reg = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_usb_h1>;
+			regulator-name = "usb_h1_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio1 0 0>;
+			enable-active-high;
+		};
+
+		/* For uSD/MMC socket on EA COM Base Board */
+		reg_vcc_sd2: regulator@2 {
+			compatible = "regulator-fixed";
+			reg = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_vcc_sd2>;
+			regulator-name = "VCC_SD2";
+			regulator-min-microvolt = <3000000>;
+			regulator-max-microvolt = <3000000>;
+			gpio = <&gpio7 8 GPIO_ACTIVE_HIGH>;
+			enable-active-high;
+		};
+
+		reg_vcc_can: regulator@4 {
+			compatible = "regulator-fixed";
+			reg = <4>;
+			regulator-name = "VCC_CAN";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			regulator-always-on;
+			/*regulator-boot-on;*/
+		};
+	};
+
+	sound {
+		compatible = "fsl,imx-audio-wm8731";
+		model = "wm8731-audio";
+		ssi-controller = <&ssi2>;
+		src-port = <2>;
+		ext-port = <3>;
+		audio-codec = <&codec>;
+		audio-routing = "LOUT", "ROUT", "LLINEIN", "RLINEIN";
+	};
+
+	sound-hdmi {
+		compatible = "fsl,imx6q-audio-hdmi",
+			     "fsl,imx-audio-hdmi";
+		model = "imx-audio-hdmi";
+		hdmi-controller = <&hdmi_audio>;
+	};
+
+	mxcfb1: fb@0 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "ldb";
+		interface_pix_fmt = "RGB666";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		dispctrl-gpios = <&gpio3 20 GPIO_ACTIVE_HIGH>, <&gpio2 27 GPIO_ACTIVE_HIGH>;
+		status = "disabled";
+	};
+
+	mxcfb2: fb@1 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "hdmi";
+		interface_pix_fmt = "RGB24";
+		mode_str ="1920x1080M@60";
+		default_bpp = <24>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	mxcfb3: fb@2 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "lcd";
+		interface_pix_fmt = "RGB24";
+		mode_str ="EA7-WVGA";
+		default_bpp = <32>;
+		int_clk = <0>;
+		late_init = <0>;
+		dispctrl-gpios = <&gpio6 31 GPIO_ACTIVE_HIGH>, <&gpio5 0 GPIO_ACTIVE_HIGH>;
+		status = "disabled";
+	};
+
+	mxcfb4: fb@3 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "ldb";
+		interface_pix_fmt = "RGB666";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		dispctrl-gpios = <&gpio6 31 GPIO_ACTIVE_HIGH>, <&gpio5 0 GPIO_ACTIVE_HIGH>;
+		status = "disabled";
+	};
+
+	lcd: lcd@0 {
+		compatible = "fsl,lcd";
+		ipu_id = <0>;
+		disp_id = <0>;
+		default_ifmt = "RGB24";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_ipu1>;
+		status = "okay";
+	};
+
+	/* Backlight for LVDS 0 and 1 */
+	backlight_lvds: backlight1 {
+		compatible = "pwm-backlight";
+		pwms = <&pwm1 0 5000000>;
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <7>;
+		status = "okay";
+	};
+
+	/* Backlight for RGB */
+	backlight_lcd: backlight2 {
+		compatible = "pwm-backlight";
+		pwms = <&pwm2 0 5000000>;
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <7>;
+		status = "okay";
+	};
+
+	v4l2_cap_0 {
+		compatible = "fsl,imx6q-v4l2-capture";
+		ipu_id = <0>;
+		csi_id = <0>;
+		mclk_source = <0>;
+		status = "okay";
+	};
+
+	v4l2_cap_1 {
+		compatible = "fsl,imx6q-v4l2-capture";
+		ipu_id = <0>;
+		csi_id = <1>;
+		mclk_source = <0>;
+		status = "okay";
+	};
+
+	v4l2_out {
+		compatible = "fsl,mxc_v4l2_output";
+		status = "okay";
+	};
+
+        gpio-keys {
+                compatible = "gpio-keys";
+                pinctrl-names = "default";
+                pinctrl-0 = <&pinctrl_gpio_keys>;
+
+                power {
+                        label = "Power Button";
+                        gpios = <&gpio3 29 1>;
+                        gpio-key,wakeup;
+                        linux,code = <KEY_POWER>;
+                };
+
+        };
+};
+
+&audmux {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_audmux>;
+	status = "okay";
+};
+
+&i2c1 {
+	
+	codec: wm8731@1a {
+		compatible = "wlf,wm8731";
+		reg = <0x1a>;
+		clocks = <&clks IMX6QDL_CLK_CKO>;
+		AVDD-supply = <&vgen4_reg>;
+		HPVDD-supply = <&vgen4_reg>;
+		DCVDD-supply = <&vgen4_reg>;
+		DBVDD-supply = <&vgen4_reg>;
+	};
+
+	/* AR1021 touch controller through RGB display interface connector on Carrier Board */
+	ar1021_rgb@4d {
+		compatible = "microchip,ar1021-i2c";
+		reg = <0x4d>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_rgb_connector>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <18 IRQ_TYPE_EDGE_FALLING>;
+		ar1021,swap_xy;
+		ar1021,invert_x;
+		#ar1021,invert_y;
+		status = "disabled";
+	};
+	/* AR1021 touch controller through LVDS0 display interface connector on Carrier Board */
+	ar1021_lvds0@4d {
+		compatible = "microchip,ar1021-i2c";
+		reg = <0x4d>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lvds0_connector>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+		ar1021,swap_xy;
+		ar1021,invert_x;
+		#ar1021,invert_y;
+		status = "disabled";
+	};
+	/* eGalax touch controller through RGB display interface connector on Carrier Board */
+	egalax_ts_rgb@04 {
+		compatible = "eeti,egalax_ts";
+		reg = <0x04>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_rgb_connector>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <18 IRQ_TYPE_EDGE_FALLING>;
+		wakeup-gpios = <&gpio2 18 GPIO_ACTIVE_HIGH>;
+		status = "disabled";
+	};
+	/* eGalax touch controller through LVDS0 display interface connector on Carrier Board */
+	egalax_ts_lvds0@04 {
+		compatible = "eeti,egalax_ts";
+		reg = <0x04>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lvds0_connector>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+		wakeup-gpios = <&gpio3 13 GPIO_ACTIVE_HIGH>;
+		status = "disabled";
+	};
+
+	/* FocalTech touch controller through RGB display interface connector on Carrier Board */
+	edt-ft5x06_rgb@38 {
+		compatible = "edt,edt-ft5x06";
+		reg = <0x38>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_rgb_connector>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <18 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&gpio3 14 GPIO_ACTIVE_HIGH>;
+		status = "disabled";
+	};
+	/* FocalTech touch controller through LVDS0 display interface connector on Carrier Board */
+	edt-ft5x06_lvds0@38 {
+		compatible = "edt,edt-ft5x06";
+		reg = <0x38>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lvds0_connector>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+		status = "disabled";
+	};
+
+	/* Ilitek touch controller through RGB display interface connector on Carrier Board */
+	ilitek_aim_rgb@41 {
+		compatible = "ilitek,ilitek_aim";
+		reg = <0x41>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_rgb_connector>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <18 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&gpio3 14 GPIO_ACTIVE_HIGH>;
+		status = "disabled";
+	};
+	/* Ilitek touch controller through LVDS0 display interface connector on Carrier Board */
+	ilitek_aim_lvds0@41 {
+		compatible = "ilitek,ilitek_aim";
+		reg = <0x41>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lvds0_connector>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+		status = "disabled";
+	};
+
+	/* Sitronix touch controller through RGB display interface connector on Carrier Board */
+	sitronix_rgb@55 {
+		compatible = "sitronix,sitronix_i2c";
+		reg = <0x55>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_rgb_connector>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <18 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&gpio3 14 GPIO_ACTIVE_HIGH>;
+		status = "disabled";
+	};
+	/* Sitronix touch controller through LVDS0 display interface connector on Carrier Board */
+	sitronix_lvds0@55 {
+		compatible = "sitronix,sitronix_i2c";
+		reg = <0x55>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lvds0_connector>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+		status = "disabled";
+	};
+};
+
+&i2c2 {
+	/* AR1021 touch controller through LVDS1 display interface connector on Carrier Board */
+	ar1021_lvds1@4d {
+		compatible = "microchip,ar1021-i2c";
+		reg = <0x4d>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lvds1_connector>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <31 IRQ_TYPE_EDGE_FALLING>;
+		ar1021,swap_xy;
+		ar1021,invert_x;
+		#ar1021,invert_y;
+		status = "disabled";
+	};
+
+	/* eGalax touch controller through LVDS1 display interface connector on Carrier Board */
+	egalax_ts_lvds1@04 {
+		compatible = "eeti,egalax_ts";
+		reg = <0x04>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lvds1_connector>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <31 IRQ_TYPE_EDGE_FALLING>;
+		wakeup-gpios = <&gpio2 31 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	/* FocalTech touch controller through LVDS1 display interface connector on Carrier Board */
+	edt-ft5x06_lvds1@38 {
+		compatible = "edt,edt-ft5x06";
+		reg = <0x38>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lvds1_connector>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <31 IRQ_TYPE_EDGE_FALLING>;
+		status = "disabled";
+	};
+
+	/* Ilitek touch controller through LVDS1 display interface connector on Carrier Board */
+	ilitek_aim_lvds1@41 {
+		compatible = "ilitek,ilitek_aim";
+		reg = <0x41>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lvds1_connector>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <31 IRQ_TYPE_EDGE_FALLING>;
+		status = "disabled";
+	};
+
+	/* Sitronix touch controller through LVDS1 display interface connector on Carrier Board */
+	sitronix_lvds1@55 {
+		compatible = "sitronix,sitronix_i2c";
+		reg = <0x55>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lvds1_connector>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <31 IRQ_TYPE_EDGE_FALLING>;
+		status = "disabled";
+	};
+};
+
+&i2c3 {
+	hdmi: edid@50 {
+		compatible = "fsl,imx6-hdmi-i2c";
+		reg = <0x50>;
+	};
+};
+
+
+&iomuxc {
+	pinctrl-0 = <&pinctrl_hog>, <&pinctrl_can_gpios>, <&pinctrl_lcd_gpios>;
+
+	imx6qea-com-kit {
+
+		pinctrl_audmux: audmuxgrp {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT7__AUD3_RXD		0x130b0
+				MX6QDL_PAD_CSI0_DAT4__AUD3_TXC		0x130b0
+				MX6QDL_PAD_CSI0_DAT5__AUD3_TXD		0x110b0
+				MX6QDL_PAD_CSI0_DAT6__AUD3_TXFS		0x130b0
+				MX6QDL_PAD_GPIO_19__CCM_CLKO1		0x130b0
+			>;
+		};
+		
+		pinctrl_rgb_connector: rgb_connector_grp {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_A20__GPIO2_IO18		0x1f0b0
+				MX6QDL_PAD_EIM_DA14__GPIO3_IO14		0x1f0b0
+			>;
+		};
+
+		pinctrl_lvds0_connector: lvds0_connector_grp {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_DA13__GPIO3_IO13		0x1f0b0
+			>;
+		};
+
+		pinctrl_lvds1_connector: lvds1_connector_grp {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_EB3__GPIO2_IO31		0x1f0b0
+			>;
+		};
+
+		pinctrl_hdmi_cec: hdmicecgrp {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_A25__EIM_ADDR25 0x1f8b0
+			>;
+		};
+
+		pinctrl_hdmi_hdcp: hdmihdcpgrp {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL3__HDMI_TX_DDC_SCL 0x4001b8b1
+				MX6QDL_PAD_KEY_ROW3__HDMI_TX_DDC_SDA 0x4001b8b1
+			>;
+		};
+
+
+		pinctrl_ipu1: ipu1grp {
+			fsl,pins = <
+				MX6QDL_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK 0x10
+				MX6QDL_PAD_DI0_PIN15__IPU1_DI0_PIN15       0x10
+				MX6QDL_PAD_DI0_PIN2__IPU1_DI0_PIN02        0x10
+				MX6QDL_PAD_DI0_PIN3__IPU1_DI0_PIN03        0x10
+				MX6QDL_PAD_DI0_PIN4__IPU1_DI0_PIN04        0x80000000
+				MX6QDL_PAD_DISP0_DAT0__IPU1_DISP0_DATA00   0x10
+				MX6QDL_PAD_DISP0_DAT1__IPU1_DISP0_DATA01   0x10
+				MX6QDL_PAD_DISP0_DAT2__IPU1_DISP0_DATA02   0x10
+				MX6QDL_PAD_DISP0_DAT3__IPU1_DISP0_DATA03   0x10
+				MX6QDL_PAD_DISP0_DAT4__IPU1_DISP0_DATA04   0x10
+				MX6QDL_PAD_DISP0_DAT5__IPU1_DISP0_DATA05   0x10
+				MX6QDL_PAD_DISP0_DAT6__IPU1_DISP0_DATA06   0x10
+				MX6QDL_PAD_DISP0_DAT7__IPU1_DISP0_DATA07   0x10
+				MX6QDL_PAD_DISP0_DAT8__IPU1_DISP0_DATA08   0x10
+				MX6QDL_PAD_DISP0_DAT9__IPU1_DISP0_DATA09   0x10
+				MX6QDL_PAD_DISP0_DAT10__IPU1_DISP0_DATA10  0x10
+				MX6QDL_PAD_DISP0_DAT11__IPU1_DISP0_DATA11  0x10
+				MX6QDL_PAD_DISP0_DAT12__IPU1_DISP0_DATA12  0x10
+				MX6QDL_PAD_DISP0_DAT13__IPU1_DISP0_DATA13  0x10
+				MX6QDL_PAD_DISP0_DAT14__IPU1_DISP0_DATA14  0x10
+				MX6QDL_PAD_DISP0_DAT15__IPU1_DISP0_DATA15  0x10
+				MX6QDL_PAD_DISP0_DAT16__IPU1_DISP0_DATA16  0x10
+				MX6QDL_PAD_DISP0_DAT17__IPU1_DISP0_DATA17  0x10
+				MX6QDL_PAD_DISP0_DAT18__IPU1_DISP0_DATA18  0x10
+				MX6QDL_PAD_DISP0_DAT19__IPU1_DISP0_DATA19  0x10
+				MX6QDL_PAD_DISP0_DAT20__IPU1_DISP0_DATA20  0x10
+				MX6QDL_PAD_DISP0_DAT21__IPU1_DISP0_DATA21  0x10
+				MX6QDL_PAD_DISP0_DAT22__IPU1_DISP0_DATA22  0x10
+				MX6QDL_PAD_DISP0_DAT23__IPU1_DISP0_DATA23  0x10
+			>;
+		};
+
+		pinctrl_ipu1_2: ipu1grp-2 { /* parallel camera */
+			fsl,pins = <
+				MX6QDL_PAD_EIM_A17__IPU2_CSI1_DATA12    0x80000000				
+				MX6QDL_PAD_EIM_A18__IPU2_CSI1_DATA13    0x80000000
+				MX6QDL_PAD_EIM_A19__IPU2_CSI1_DATA14    0x80000000
+				MX6QDL_PAD_EIM_A20__IPU2_CSI1_DATA15    0x80000000
+				MX6QDL_PAD_EIM_A21__IPU2_CSI1_DATA16    0x80000000
+				MX6QDL_PAD_EIM_A22__IPU2_CSI1_DATA17    0x80000000
+				MX6QDL_PAD_EIM_A23__IPU2_CSI1_DATA18    0x80000000
+				MX6QDL_PAD_EIM_A24__IPU2_CSI1_DATA19    0x80000000
+				MX6QDL_PAD_EIM_A16__IPU2_CSI1_PIXCLK   0x80000000
+				MX6QDL_PAD_EIM_DA11__IPU2_CSI1_HSYNC      0x80000000
+				MX6QDL_PAD_EIM_DA12__IPU2_CSI1_VSYNC     0x80000000
+			>;
+		};
+
+		pinctrl_pwm1: pwm1grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_DAT3__PWM1_OUT		0x1b0b1
+			>;
+		};
+
+		pinctrl_pwm2: pwm2grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_DAT2__PWM2_OUT		0x1b0b1
+			>;
+		};
+
+		pinctrl_uart1: uart1grp {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT10__UART1_TX_DATA	0x1b0b1
+				MX6QDL_PAD_CSI0_DAT11__UART1_RX_DATA	0x1b0b1
+			>;
+		};
+
+		pinctrl_uart4: uart4grp {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT12__UART4_TX_DATA	0x1b0b1
+				MX6QDL_PAD_CSI0_DAT13__UART4_RX_DATA	0x1b0b1
+			>;
+		};
+
+		pinctrl_uart5: uart5grp {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT14__UART5_TX_DATA	0x1b0b1
+				MX6QDL_PAD_CSI0_DAT15__UART5_RX_DATA	0x1b0b1
+				MX6QDL_PAD_CSI0_DAT19__UART5_CTS_B	0x1b0b1
+				MX6QDL_PAD_CSI0_DAT18__UART5_RTS_B	0x1b0b1
+
+				/* RF_ON */
+				/* MX6QDL_PAD_EIM_D23__GPIO3_IO23	0x17059*/
+
+				/* RF_DTR */
+				MX6QDL_PAD_CSI0_DAT17__GPIO6_IO03 	0x17059
+
+				/* RF_CD */
+				MX6QDL_PAD_CSI0_DAT16__GPIO6_IO02	0x17059
+
+				/* RF_RST */
+				MX6QDL_PAD_EIM_A19__GPIO2_IO19		0x17059
+			>;
+		};
+
+		pinctrl_usbotg: usbotggrp {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_RX_ER__USB_OTG_ID	0x17059
+			>;
+		};
+
+		pinctrl_usdhc2: usdhc2grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD2_CMD__SD2_CMD		0x17059
+				MX6QDL_PAD_SD2_CLK__SD2_CLK		0x10059
+				MX6QDL_PAD_SD2_DAT0__SD2_DATA0		0x17059
+				MX6QDL_PAD_SD2_DAT1__SD2_DATA1		0x17059
+				MX6QDL_PAD_SD2_DAT2__SD2_DATA2		0x17059
+				MX6QDL_PAD_SD2_DAT3__SD2_DATA3		0x17059
+				MX6QDL_PAD_NANDF_WP_B__GPIO6_IO09	0x17059
+			>;
+		};
+
+		pinctrl_usb_h1: usbh1grp {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_0__GPIO1_IO00	0x1b0b0
+			>;
+		};
+
+		pinctrl_vcc_sd2: vccsd2grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_RST__GPIO7_IO08			0x17059
+			>;
+		};
+
+		pinctrl_can_gpios: can-gpios {
+			fsl,pins = <
+				MX6QDL_PAD_NANDF_CS0__GPIO6_IO11	0x17059
+			>;
+		}; 
+
+		pinctrl_flexcan1: flexcan1grp {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_ROW2__FLEXCAN1_RX	0x1b020
+				MX6QDL_PAD_KEY_COL2__FLEXCAN1_TX	0x1b020
+			>;
+		};
+
+		pinctrl_flexcan2: flexcan2grp {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_ROW4__FLEXCAN2_RX	0x1b020
+				MX6QDL_PAD_KEY_COL4__FLEXCAN2_TX	0x1b020
+			>;
+		};
+
+		pinctrl_lcd_gpios: lcd-gpios {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_BCLK__GPIO6_IO31		0x17059
+				MX6QDL_PAD_EIM_WAIT__GPIO5_IO00		0x17059
+				MX6QDL_PAD_EIM_D20__GPIO3_IO20		0x17059
+				MX6QDL_PAD_EIM_LBA__GPIO2_IO27		0x17059
+			>;
+		};
+
+                pinctrl_gpio_keys: gpio_keysgrp {
+                        fsl,pins = <
+                                MX6QDL_PAD_EIM_D29__GPIO3_IO29 0x80000000
+                        >;
+                };
+
+ 	};
+};
+
+&dcic1 {
+	dcic_id = <0>;
+	dcic_mux = "dcic-hdmi";
+	status = "okay";
+};
+
+&dcic2 {
+	dcic_id = <1>;
+	dcic_mux = "dcic-lvds1";
+	status = "okay";
+};
+
+
+&hdmi_audio {
+	status = "okay";
+};
+
+&hdmi_cec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hdmi_cec>;
+	status = "okay";
+};
+
+&hdmi_core {
+	ipu_id = <0>;
+	disp_id = <1>;
+	status = "okay";
+};
+
+&hdmi_video {
+	fsl,phy_reg_vlev = <0x0294>;
+	fsl,phy_reg_cksymtx = <0x800d>;
+	status = "okay";
+};
+
+&lcd {
+	status = "okay";
+	display = <&display0>;
+
+	display0: display {
+		bits-per-pixel = <32>;
+		bus-width = <24>;
+
+		display-timings {
+			native-mode = <&t_lcd>;
+			t_lcd: t_lcd_default {
+				/* values may be changed in bootscript, default is for EA 7" display */
+				clock-frequency = <33500000>;
+				hactive = <800>;
+				vactive = <480>;
+				hback-porch = <89>;
+				hfront-porch = <164>;
+				vback-porch = <75>;/*<23>;*/
+				vfront-porch = <75>;/*<10>;*/
+				hsync-len = <10>;
+				vsync-len = <10>;
+				hsync-active = <0>;
+				vsync-active = <0>;
+				de-active = <1>;
+				pixelclk-active = <1>;
+			};
+		};
+	};
+};
+
+&ldb {
+	status = "okay";
+
+	lvds-channel@0 {
+		fsl,data-mapping = "spwg";
+		fsl,data-width = <18>;
+		status = "okay";
+
+		display-timings {
+			native-mode = <&t_lvds>;
+			t_lvds: t_lvds_default {
+				/* values may be changed in bootscript */
+				clock-frequency = <65000000>;
+				hactive = <1024>;
+				vactive = <768>;
+				hback-porch = <220>;
+				hfront-porch = <40>;
+				vback-porch = <21>;
+				vfront-porch = <7>;
+				hsync-len = <60>;
+				vsync-len = <10>;
+			};
+		};
+	};
+
+	lvds-channel@1 {
+		fsl,data-mapping = "spwg";
+		fsl,data-width = <18>;
+		primary;
+		status = "okay";
+
+		display-timings {
+			native-mode = <&t_lvds2>;
+			t_lvds2: t_lvds2_default {
+				/* values may be changed in bootscript */
+				clock-frequency = <65000000>;
+				hactive = <1024>;
+				vactive = <768>;
+				hback-porch = <220>;
+				hfront-porch = <40>;
+				vback-porch = <21>;
+				vfront-porch = <7>;
+				hsync-len = <60>;
+				vsync-len = <10>;
+			};
+		};
+	};
+};
+
+&mipi_csi {
+	status = "okay";
+	ipu_id = <0>;
+	csi_id = <1>;
+	v_channel = <0>;
+	lanes = <2>;
+};
+
+/* mipi_dsi has the same ip_id/disp_id as the hdmi_core so only enble one of the */
+&mipi_dsi {
+	dev_id = <0>;
+	disp_id = <1>;
+	lcd_panel = "TRULY-WVGA";
+	status = "disabled";
+};
+
+&pcie {
+	reset-gpio = <&gpio1 1 0>;
+	status = "okay";
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm1>;
+	status = "okay";
+};
+
+&pwm2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm2>;
+	status = "okay";
+};
+
+&ssi2 {
+	fsl,mode = "i2s-master";
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	status = "okay";
+};
+
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart4>;
+	status = "okay";
+};
+
+&uart5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart5>;
+	status = "okay";
+
+	fsl,uart-has-rtscts;
+	#fsl,dte-mode;
+};
+
+&usbh1 {
+	vbus-supply = <&reg_usb_h1_vbus>;
+	status = "okay";
+};
+
+&usbotg {
+	vbus-supply = <&reg_usb_otg_vbus>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbotg>;
+	disable-over-current;
+	status = "okay";
+};
+
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2>;
+	bus-width = <4>;
+	vmmc-supply = <&reg_vcc_sd2>;
+	cd-gpios = <&gpio6 9 0>;
+	no-1-8-v;
+	keep-power-in-suspend;
+	enable-sdio-wakeup;
+	status = "okay";
+};
+
+
+&wdog1 {
+	status = "okay";
+};
+
+&wdog2 {
+	status = "disabled";
+};
+
+
+&ldb {
+	lvds-channel@0 {
+		crtc = "ipu2-di0";
+	};
+
+	lvds-channel@1 {
+		crtc = "ipu2-di1";
+	};
+};
+
+&mxcfb1 {
+	status = "okay";
+};
+
+&mxcfb2 {
+	status = "okay";
+};
+
+&mxcfb3 {
+	status = "okay";
+};
+
+&mxcfb4 {
+	status = "okay";
+};
+
+&sata {
+	status = "okay";
+};
+
+&flexcan1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1>;
+	xceiver-supply = <&reg_vcc_can>; 
+	trx-en-gpio = <&gpio6 11 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+&flexcan2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan2>;
+	xceiver-supply = <&reg_vcc_can>; 
+	trx-en-gpio = <&gpio6 11 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+
diff --git a/arch/arm/boot/dts/imx6qea-com.dtsi b/arch/arm/boot/dts/imx6qea-com.dtsi
new file mode 100644
index 0000000..c7083f6
--- /dev/null
+++ b/arch/arm/boot/dts/imx6qea-com.dtsi
@@ -0,0 +1,302 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#include <dt-bindings/input/input.h>
+#include "imx6q.dtsi"
+
+
+/ {
+	model = "Embedded Artists i.MX6 Quad COM Board";
+	compatible = "fsl,imx6qea-com", "fsl,imx6q";
+
+
+	memory {
+		reg = <0x10000000 0x40000000>;
+	};
+
+
+};
+
+
+&cpu0 {
+	arm-supply = <&sw1a_reg>;
+	soc-supply = <&sw1c_reg>;
+};
+
+&gpc {
+	/* use ldo-bypass, u-boot will check it and configure */
+	fsl,ldo-bypass = <1>;
+	fsl,wdog-reset = <1>;
+};
+
+
+&fec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet>;
+	phy-mode = "rgmii";
+	phy-reset-gpios = <&gpio1 25 0>;
+	fsl,magic-packet;
+	status = "okay";
+};
+
+&ecspi1 {
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio2 30 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi1>;
+	status = "okay";
+
+	flash0: n25q256a@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "micron,n25q256a";
+		spi-max-frequency = <29000000>;
+		spi-nor,ddr-quad-read-dummy = <6>;
+		reg = <0>;
+	};
+
+};
+
+
+/* For eMMC socket on EA COM Board */
+&usdhc4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc4>;
+	bus-width = <8>;
+	non-removable;
+	no-1-8-v;
+	keep-power-in-suspend;
+	status = "okay";
+};
+
+&i2c1 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	status = "okay";
+
+	pmic: pfuze100@08 {
+		compatible = "fsl,pfuze100";
+		reg = <0x08>;
+
+		regulators {
+			sw1a_reg: sw1ab {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			sw1c_reg: sw1c {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			sw2_reg: sw2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3a_reg: sw3a {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3b_reg: sw3b {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw4_reg: sw4 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			swbst_reg: swbst {
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5150000>;
+			};
+
+			snvs_reg: vsnvs {
+				regulator-min-microvolt = <1000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vref_reg: vrefddr {
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vgen1_reg: vgen1 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen2_reg: vgen2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen3_reg: vgen3 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			vgen4_reg: vgen4 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen5_reg: vgen5 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen6_reg: vgen6 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+		};
+	};
+
+
+	at24@55 {
+		compatible = "at,24c64";
+		pagesize = <32>;
+		reg = <0x55>;
+	};
+};
+
+
+&i2c2 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2>;
+	status = "okay";
+
+};
+
+&i2c3 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3>;
+	status = "okay";
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog>;
+
+	imx6qea-com {
+		pinctrl_hog: hoggrp {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D22__GPIO3_IO22  0x80000000
+				MX6QDL_PAD_ENET_CRS_DV__GPIO1_IO25 0x80000000
+				MX6QDL_PAD_EIM_D23__GPIO3_IO23 0x80000000
+				MX6QDL_PAD_GPIO_9__WDOG1_B 	0x80000000
+			>;
+		};
+
+
+		pinctrl_ecspi1: ecspi1grp {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D17__ECSPI1_MISO	0x100b1
+				MX6QDL_PAD_EIM_D18__ECSPI1_MOSI	0x100b1
+				MX6QDL_PAD_EIM_D16__ECSPI1_SCLK	0x100b1
+			>;
+		};
+
+		pinctrl_enet: enetgrp {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_MDIO__ENET_MDIO		0x1b0b0
+				MX6QDL_PAD_ENET_MDC__ENET_MDC		0x1b0b0
+				MX6QDL_PAD_RGMII_TXC__RGMII_TXC		0x1b0b0
+				MX6QDL_PAD_RGMII_TD0__RGMII_TD0		0x1b0b0
+				MX6QDL_PAD_RGMII_TD1__RGMII_TD1		0x1b0b0
+				MX6QDL_PAD_RGMII_TD2__RGMII_TD2		0x1b0b0
+				MX6QDL_PAD_RGMII_TD3__RGMII_TD3		0x1b0b0
+				MX6QDL_PAD_RGMII_TX_CTL__RGMII_TX_CTL	0x1b0b0
+				MX6QDL_PAD_ENET_REF_CLK__ENET_TX_CLK	0x1b0b0
+				MX6QDL_PAD_RGMII_RXC__RGMII_RXC		0x1b0b0
+				MX6QDL_PAD_RGMII_RD0__RGMII_RD0		0x1b0b0
+				MX6QDL_PAD_RGMII_RD1__RGMII_RD1		0x1b0b0
+				MX6QDL_PAD_RGMII_RD2__RGMII_RD2		0x1b0b0
+				MX6QDL_PAD_RGMII_RD3__RGMII_RD3		0x1b0b0
+				MX6QDL_PAD_RGMII_RX_CTL__RGMII_RX_CTL	0x1b0b0
+				MX6QDL_PAD_GPIO_16__ENET_REF_CLK	0x4001b0a8
+			>;
+		};
+
+		pinctrl_enet_irq: enetirqgrp {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_TXD0__GPIO1_IO30		0x000b1
+			>;
+		};
+
+
+		pinctrl_i2c1: i2c1grp {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT8__I2C1_SDA		0x4001b8b1
+				MX6QDL_PAD_CSI0_DAT9__I2C1_SCL		0x4001b8b1
+			>;
+		};
+
+		pinctrl_i2c2: i2c2grp {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL3__I2C2_SCL		0x4001b8b1
+				MX6QDL_PAD_KEY_ROW3__I2C2_SDA		0x4001b8b1
+			 >;
+		};
+
+		pinctrl_i2c3: i2c3grp {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_5__I2C3_SCL		0x4001b8b1
+				MX6QDL_PAD_GPIO_6__I2C3_SDA		0x4001b8b1
+			>;
+		};
+
+
+		pinctrl_usdhc4: usdhc4grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD4_CMD__SD4_CMD		0x17059
+				MX6QDL_PAD_SD4_CLK__SD4_CLK		0x10059
+				MX6QDL_PAD_SD4_DAT0__SD4_DATA0		0x17059
+				MX6QDL_PAD_SD4_DAT1__SD4_DATA1		0x17059
+				MX6QDL_PAD_SD4_DAT2__SD4_DATA2		0x17059
+				MX6QDL_PAD_SD4_DAT3__SD4_DATA3		0x17059
+				MX6QDL_PAD_SD4_DAT4__SD4_DATA4		0x17059
+				MX6QDL_PAD_SD4_DAT5__SD4_DATA5		0x17059
+				MX6QDL_PAD_SD4_DAT6__SD4_DATA6		0x17059
+				MX6QDL_PAD_SD4_DAT7__SD4_DATA7		0x17059
+			>;
+		};
+
+
+	};
+};
+
+
+
+
+
diff --git a/arch/arm/boot/dts/imx6sxea-com-kit-lvds.dts b/arch/arm/boot/dts/imx6sxea-com-kit-lvds.dts
new file mode 100644
index 0000000..239e7cd
--- /dev/null
+++ b/arch/arm/boot/dts/imx6sxea-com-kit-lvds.dts
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "imx6sxea-com-kit.dts"
+
+
+
+/*
+ * Disable the RGB interface to only have LVDS enabled
+ */
+&lcdif1 {
+	status = "disabled";
+};
+
+
diff --git a/arch/arm/boot/dts/imx6sxea-com-kit-m4.dts b/arch/arm/boot/dts/imx6sxea-com-kit-m4.dts
new file mode 100644
index 0000000..875b524
--- /dev/null
+++ b/arch/arm/boot/dts/imx6sxea-com-kit-m4.dts
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "imx6sxea-com-kit.dts"
+
+/{
+	memory {
+		linux,usable-memory = <0x80000000 0x3ff00000>;
+		reg = <0x80000000 0x40000000>;
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog>;
+};
+
+/*
+ * The following modules are conflicting with M4, disable them when m4
+ * is running.
+ */
+&flexcan1 {
+	status = "disabled";
+};
+
+&flexcan2 {
+	status = "disabled";
+};
+
+&i2c3 {
+        status = "disabled";
+};
+
+&mcctest{
+	status = "okay";
+};
+
+&mcctty{
+	status = "okay";
+};
+
+&rpmsg {
+	status = "okay";
+};
+
+&uart2 {
+	status = "disabled";
+};
+
+&adc1 {
+        status = "disabled";
+};
+
+&adc2 {
+        status = "disabled";
+};
+
+&qspi2 {
+	status = "disabled";
+};
+
+&qspi_m4 {
+	status = "okay";
+};
+
+&ocram {
+	reg = <0x00901000 0x1E000>;
+};
+
+&clks {
+	fsl,shared-clks-number = <0x23>;
+	fsl,shared-clks-index = <IMX6SX_CLK_PLL2_BUS IMX6SX_CLK_PLL2_PFD0
+			IMX6SX_CLK_PLL2_PFD2 IMX6SX_CLK_PLL3_USB_OTG
+			IMX6SX_CLK_PLL3_PFD1 IMX6SX_CLK_PLL3_PFD2
+			IMX6SX_CLK_PLL3_PFD3 IMX6SX_CLK_PLL4_AUDIO
+			IMX6SX_CLK_PLL5_VIDEO
+			IMX6SX_CLK_OCRAM IMX6SX_CLK_CAN1_SERIAL
+			IMX6SX_CLK_CAN1_IPG IMX6SX_CLK_CAN2_SERIAL
+			IMX6SX_CLK_CAN2_IPG IMX6SX_CLK_CANFD
+			IMX6SX_CLK_ECSPI1 IMX6SX_CLK_ECSPI2
+			IMX6SX_CLK_ECSPI3 IMX6SX_CLK_ECSPI4
+			IMX6SX_CLK_ECSPI5 IMX6SX_CLK_QSPI1
+			IMX6SX_CLK_QSPI2 IMX6SX_CLK_SSI1
+			IMX6SX_CLK_SSI2 IMX6SX_CLK_SSI3
+			IMX6SX_CLK_UART_SERIAL IMX6SX_CLK_UART_IPG
+			IMX6SX_CLK_PERIPH_CLK2_SEL IMX6SX_CLK_OCRAM_ALT_SEL
+			IMX6SX_CLK_I2C1 IMX6SX_CLK_I2C2
+			IMX6SX_CLK_I2C3 IMX6SX_CLK_I2C4
+			IMX6SX_CLK_EPIT1 IMX6SX_CLK_EPIT2>;
+	fsl,shared-mem-addr = <0x91F000>;
+	fsl,shared-mem-size = <0x1000>;
+};
+
diff --git a/arch/arm/boot/dts/imx6sxea-com-kit-rgb.dts b/arch/arm/boot/dts/imx6sxea-com-kit-rgb.dts
new file mode 100644
index 0000000..31312d6
--- /dev/null
+++ b/arch/arm/boot/dts/imx6sxea-com-kit-rgb.dts
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "imx6sxea-com-kit.dts"
+
+
+
+/*
+ * Disable the LVDS interface to only have RGB enabled
+ */
+&lcdif2 {
+	status = "disabled";
+};
+
+
diff --git a/arch/arm/boot/dts/imx6sxea-com-kit.dts b/arch/arm/boot/dts/imx6sxea-com-kit.dts
new file mode 100644
index 0000000..04f31cd
--- /dev/null
+++ b/arch/arm/boot/dts/imx6sxea-com-kit.dts
@@ -0,0 +1,720 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/dts-v1/;
+
+#include "imx6sxea-com.dtsi"
+
+/ {
+	model = "Embedded Artists i.MX6 SoloX COM Kit";
+	compatible = "fsl,imx6sxea-com", "fsl,imx6sx";
+
+	/* Aliases to allow u-boot to modify the device tree */
+	aliases {
+		fb_rgb = &lcdif1;
+		fb_lvds0 = &lcdif2;
+		t_rgb = &t_lcd;
+		t_lvds0 = &t_lvds;
+		bl_rgb = &backlight_lcd;
+		bl_lvds = &backlight_lvds;
+		rgb = &display0;
+		lvds0 = &display1;
+		ldb = &ldb;
+		ts_con_rgb = &i2c1;
+		ts_con_lvds0 = &i2c1;
+	};
+
+	chosen {
+		stdout-path = &uart1;
+	};
+
+
+	backlight_lvds: backlight1 {
+		compatible = "pwm-backlight";
+		pwms = <&pwm1 0 5000000>;
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <6>;
+		fb-names = "mxs-lcdif0";
+		enable-gpios = <&gpio1 9 GPIO_ACTIVE_HIGH>;
+	};
+
+	backlight_lcd: backlight2 {
+		compatible = "pwm-backlight";
+		pwms = <&pwm2 0 5000000>;
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <6>;
+		fb-names = "mxs-lcdif1";
+	};
+
+/*
+	hannstar_cabc {
+		compatible = "hannstar,cabc";
+
+		lvds0 {
+			gpios = <&gpio2 1 GPIO_ACTIVE_HIGH>, <&gpio1 9 GPIO_ACTIVE_HIGH>;
+		};
+	};
+*/
+	pxp_v4l2_out {
+		compatible = "fsl,imx6sx-pxp-v4l2", "fsl,imx6sl-pxp-v4l2";
+		status = "okay";
+	};
+
+	regulators {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_lcd_3v3: lcd-3v3 {
+			compatible = "regulator-fixed";
+			regulator-name = "lcd-3v3";
+			gpio = <&gpio2 1 1>;
+			enable-active-high;
+			status = "okay";
+		};
+
+		/* For uSD/MMC socket on EA COM Base Board */
+		vcc_sd2: regulator@0 {
+			compatible = "regulator-fixed";
+			reg = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_vcc_sd2>;
+			regulator-name = "VCC_SD2";
+			regulator-min-microvolt = <3000000>;
+			regulator-max-microvolt = <3000000>;
+			gpio = <&gpio6 22 GPIO_ACTIVE_HIGH>;
+			enable-active-high;
+		};
+
+		reg_psu_5v: regulator@1 {
+			compatible = "regulator-fixed";
+			reg = <1>;
+			regulator-name = "PSU-5V0";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			regulator-boot-on;
+		};
+
+
+		reg_usb_otg1_vbus: regulator@3 {
+			compatible = "regulator-fixed";
+			reg = <3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_usb_otg1>;
+			regulator-name = "usb_otg1_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio4 18 GPIO_ACTIVE_HIGH>;
+			enable-active-high;
+		};
+ 
+		reg_usb_otg2_vbus: regulator@4 {
+			compatible = "regulator-fixed";
+			reg = <4>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_usb_otg2>;
+			regulator-name = "usb_otg2_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio1 12 GPIO_ACTIVE_HIGH>;
+			enable-active-high;
+		};
+
+		reg_pcie: regulator@5 {
+			compatible = "regulator-fixed";
+			reg = <5>;
+			regulator-name = "MPCIE_3V3";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;			
+			regulator-always-on;
+		};
+	};
+
+	sound {
+		compatible = "fsl,imx-audio-wm8731";
+		model = "wm8731-audio";
+		ssi-controller = <&ssi2>;
+		src-port = <2>;
+		ext-port = <6>;
+		audio-codec = <&codec>;
+		audio-routing = "LOUT", "ROUT", "LLINEIN", "RLINEIN";
+	};
+
+};
+
+&audmux {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_audmux>;
+	status = "okay";
+};
+
+&csi2 {
+	status = "okay";
+	port {
+		csi2_ep: endpoint {
+			remote-endpoint = <&vadc_ep>;
+		};
+	};
+};
+
+
+&lcdif1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_lcdif_dat>;
+	lcd-supply = <&reg_lcd_3v3>;
+	display = <&display0>;
+	status = "okay";
+
+	display0: display {
+		bits-per-pixel = <32>;
+		bus-width = <24>;
+
+		display-timings {
+			native-mode = <&t_lcd>;
+			t_lcd: t_lcd_default {
+				/* values may be changed in bootscript, default is for EA 7" display */
+				clock-frequency = <33500000>;
+				hactive = <800>;
+				vactive = <480>;
+				hback-porch = <89>;
+				hfront-porch = <164>;
+				vback-porch = <75>;/*<23>;*/
+				vfront-porch = <75>;/*<10>;*/
+				hsync-len = <10>;
+				vsync-len = <10>;
+				hsync-active = <0>;
+				vsync-active = <0>;
+				de-active = <1>;
+				pixelclk-active = <1>;
+			};
+		};
+	};
+};
+
+&lcdif2 {
+        lcd-supply = <&reg_lcd_3v3>;
+
+	display = <&display1>;
+	disp-dev = "ldb";
+	status = "okay";
+
+	assigned-clocks = <&clks IMX6SX_CLK_LCDIF2_SEL>;
+	assigned-clock-parents = <&clks IMX6SX_CLK_LDB_DI0>;
+	assigned-clock-rates = <0>;
+
+	display1: display {
+		bits-per-pixel = <16>;
+		bus-width = <18>;
+	};
+};
+
+&ldb {
+	status = "okay";
+
+	lvds-channel@0 {
+		fsl,data-mapping = "spwg";
+		fsl,data-width = <18>;
+		crtc = "lcdif2";
+		status = "okay";
+
+		display-timings {
+			native-mode = <&t_lvds>;
+			t_lvds: t_lvds_default {
+				/* values may be changed in bootscript, default is for Hannstar 10" display */
+				clock-frequency = <65000000>;
+				hactive = <1024>;
+				vactive = <768>;
+				hback-porch = <220>;
+				hfront-porch = <40>;
+				vback-porch = <21>;
+				vfront-porch = <7>;
+				hsync-len = <60>;
+				vsync-len = <10>;
+			};
+		};
+	};
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm1>;
+	status = "okay";
+};
+
+&pwm2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm2>;
+	status = "okay";
+};
+
+&dcic1 {
+	dcic_id = <0>;
+	dcic_mux = "dcic-lcdif1";
+	status = "okay";
+};
+
+&dcic2 {
+	dcic_id = <1>;
+	dcic_mux = "dcic-lvds";
+	status = "okay";
+};
+
+&flexcan1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1>;
+	xceiver-supply = <&reg_psu_5v>;
+	trx-en-gpio = <&gpio4 25 GPIO_ACTIVE_LOW>;
+	trx-stby-gpio = <&gpio2 17 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+&flexcan2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan2>;
+	xceiver-supply = <&reg_psu_5v>;
+	trx-en-gpio = <&gpio4 25 GPIO_ACTIVE_LOW>;
+	trx-stby-gpio = <&gpio2 17 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+&pcie {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcie>;
+	reset-gpio = <&gpio6 1 0>;
+	status = "okay";
+};
+
+&pxp {
+	status = "okay";
+};
+
+&sai1 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_sai1>;
+        status = "disabled";
+};
+
+&spdif {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_spdif>;
+	status = "okay";
+};
+
+&ssi2 {
+	fsl,mode = "i2s-master";
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	status = "okay";
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "okay";
+
+	fsl,uart-has-rtscts;
+	#fsl,irda-mode;
+	#fsl,dte-mode;
+};
+
+&uart5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart5>;
+	status = "okay";
+};
+
+&usbotg1 {
+	vbus-supply = <&reg_usb_otg1_vbus>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usb_otg1_id>;
+	status = "okay";
+};
+
+&usbotg2 {
+	vbus-supply = <&reg_usb_otg2_vbus>;
+	dr_mode = "host";
+	status = "okay";
+};
+
+/* For uSD/MMC socket on EA COM Base Board */
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2>;
+	cd-gpios = <&gpio2 16 GPIO_ACTIVE_HIGH>;
+	vmmc-supply = <&vcc_sd2>;
+	no-1-8-v;
+	keep-power-in-suspend;
+	enable-sdio-wakeup;
+	status = "okay";
+};
+
+
+&i2c1 {
+	
+	codec: wm8731@1a {
+		compatible = "wlf,wm8731";
+		reg = <0x1a>;
+		clocks = <&clks IMX6SX_CLK_AUDIO>;
+		AVDD-supply = <&vgen4_reg>;
+		HPVDD-supply = <&vgen4_reg>;
+		DCVDD-supply = <&vgen4_reg>;
+		DBVDD-supply = <&vgen4_reg>;
+	};
+
+	/* AR1021 touch controller through RGB display interface connector on Carrier Board */
+	ar1021_rgb@4d {
+		compatible = "microchip,ar1021-i2c";
+		reg = <0x4d>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_rgb_connector>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <17 IRQ_TYPE_EDGE_FALLING>;
+		ar1021,swap_xy;
+		ar1021,invert_x;
+		#ar1021,invert_y;
+		status = "disabled";
+	};
+	/* AR1021 touch controller through LVDS0 display interface connector on Carrier Board */
+	ar1021_lvds0@4d {
+		compatible = "microchip,ar1021-i2c";
+		reg = <0x4d>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lvds0_connector>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <15 IRQ_TYPE_EDGE_FALLING>;
+		ar1021,swap_xy;
+		ar1021,invert_x;
+		#ar1021,invert_y;
+		status = "disabled";
+	};
+
+	/* eGalax touch controller through RGB display interface connector on Carrier Board */
+	egalax_ts_rgb@04 {
+		compatible = "eeti,egalax_ts";
+		reg = <0x04>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_rgb_connector>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <17 IRQ_TYPE_EDGE_FALLING>;
+		wakeup-gpios = <&gpio1 17 GPIO_ACTIVE_HIGH>;
+		status = "disabled";
+	};
+	/* eGalax touch controller through LVDS0 display interface connector on Carrier Board */
+	egalax_ts_lvds0@04 {
+		compatible = "eeti,egalax_ts";
+		reg = <0x04>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lvds0_connector>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <15 IRQ_TYPE_EDGE_FALLING>;
+		wakeup-gpios = <&gpio2 15 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	/* FocalTech touch controller through RGB display interface connector on Carrier Board */
+	edt-ft5x06_rgb@38 {
+		compatible = "edt,edt-ft5x06";
+		reg = <0x38>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_rgb_connector>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <17 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&gpio4 19 GPIO_ACTIVE_HIGH>;
+		status = "disabled";
+	};
+	/* FocalTech touch controller through LVDS0 display interface connector on Carrier Board */
+	edt-ft5x06_lvds0@38 {
+		compatible = "edt,edt-ft5x06";
+		reg = <0x38>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lvds0_connector>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <15 IRQ_TYPE_EDGE_FALLING>;
+		status = "disabled";
+	};
+
+	/* Ilitek touch controller through RGB display interface connector on Carrier Board */
+	ilitek_aim_rgb@41 {
+		compatible = "ilitek,ilitek_aim";
+		reg = <0x41>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_rgb_connector>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <17 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&gpio4 19 GPIO_ACTIVE_HIGH>;
+		status = "disabled";
+	};
+	/* Ilitek touch controller through LVDS0 display interface connector on Carrier Board */
+	ilitek_aim_lvds0@41 {
+		compatible = "ilitek,ilitek_aim";
+		reg = <0x41>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lvds0_connector>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <15 IRQ_TYPE_EDGE_FALLING>;
+		status = "disabled";
+	};
+
+	/* Sitronix touch controller through RGB display interface connector on Carrier Board */
+	sitronix_rgb@55 {
+		compatible = "sitronix,sitronix_i2c";
+		reg = <0x55>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_rgb_connector>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <17 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&gpio4 19 GPIO_ACTIVE_HIGH>;
+		status = "disabled";
+	};
+	/* Sitronix touch controller through LVDS0 display interface connector on Carrier Board */
+	sitronix_lvds0@55 {
+		compatible = "sitronix,sitronix_i2c";
+		reg = <0x55>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lvds0_connector>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <15 IRQ_TYPE_EDGE_FALLING>;
+		status = "disabled";
+	};
+};
+
+&i2c2 {
+
+};
+
+
+&vadc {
+	vadc_in = <0>;
+	csi_id = <1>;
+	status = "okay";
+	port {
+		vadc_ep: endpoint {
+			remote-endpoint = <&csi2_ep>;
+		};
+	};
+};
+
+&iomuxc {
+	pinctrl-0 = <&pinctrl_can_gpios>, <&pinctrl_lcdif_ctrl>;
+
+	imx6xea-com-kit {
+
+		pinctrl_audmux: audmuxgrp {
+			fsl,pins = <
+				MX6SX_PAD_CSI_DATA00__AUDMUX_AUD6_TXC   0x130b0
+				MX6SX_PAD_CSI_DATA01__AUDMUX_AUD6_TXFS  0x130b0
+				MX6SX_PAD_CSI_HSYNC__AUDMUX_AUD6_TXD    0x120b0
+				MX6SX_PAD_CSI_VSYNC__AUDMUX_AUD6_RXD    0x130b0
+				MX6SX_PAD_CSI_PIXCLK__AUDMUX_MCLK       0x130b0
+			>;
+		};
+
+		pinctrl_canfd1: canfd1grp-1 {
+			fsl,pins = <
+				MX6SX_PAD_QSPI1B_DQS__CANFD_TX1         0x1b0b0
+				MX6SX_PAD_QSPI1A_SS1_B__CANFD_RX1       0x1b0b0
+			>;
+		};
+
+		pinctrl_canfd2: canfd2grp-1 {
+			fsl,pins = <
+				MX6SX_PAD_QSPI1B_SS1_B__CANFD_RX2       0x1b0b0
+				MX6SX_PAD_QSPI1A_DQS__CANFD_TX2         0x1b0b0
+			>;
+		};
+
+		pinctrl_rgb_connector: rgb_connector_grp {
+			fsl,pins = <
+				MX6SX_PAD_CSI_DATA03__GPIO1_IO_17       0x1f0b0
+				MX6SX_PAD_QSPI1A_DATA3__GPIO4_IO_19     0x1f0b0
+			>;
+		};
+
+		pinctrl_lvds0_connector: lvds0_connector_grp {
+			fsl,pins = <
+				MX6SX_PAD_KEY_ROW0__GPIO2_IO_15 0x80000000
+			>;
+		};
+
+		pinctrl_flexcan1: flexcan1grp {
+			fsl,pins = <
+				MX6SX_PAD_QSPI1B_DQS__CAN1_TX		0x1b020
+				MX6SX_PAD_QSPI1A_SS1_B__CAN1_RX		0x1b020
+			>;
+		};
+
+		pinctrl_flexcan2: flexcan2grp {
+			fsl,pins = <
+				MX6SX_PAD_QSPI1B_SS1_B__CAN2_RX		0x1b020
+				MX6SX_PAD_QSPI1A_DQS__CAN2_TX		0x1b020
+			>;
+		};
+
+
+		pinctrl_can_gpios: can-gpios {
+			fsl,pins = <
+				/*MX6SX_PAD_QSPI1B_DATA1__GPIO4_IO_25 0x17059*/
+				MX6SX_PAD_KEY_ROW2__GPIO2_IO_17 0x17059
+			>;
+		};
+
+
+		pinctrl_lcdif_dat: lcdifdatgrp {
+			fsl,pins = <
+				MX6SX_PAD_LCD1_DATA00__LCDIF1_DATA_0 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA01__LCDIF1_DATA_1 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA02__LCDIF1_DATA_2 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA03__LCDIF1_DATA_3 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA04__LCDIF1_DATA_4 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA05__LCDIF1_DATA_5 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA06__LCDIF1_DATA_6 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA07__LCDIF1_DATA_7 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA08__LCDIF1_DATA_8 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA09__LCDIF1_DATA_9 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA10__LCDIF1_DATA_10 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA11__LCDIF1_DATA_11 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA12__LCDIF1_DATA_12 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA13__LCDIF1_DATA_13 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA14__LCDIF1_DATA_14 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA15__LCDIF1_DATA_15 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA16__LCDIF1_DATA_16 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA17__LCDIF1_DATA_17 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA18__LCDIF1_DATA_18 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA19__LCDIF1_DATA_19 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA20__LCDIF1_DATA_20 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA21__LCDIF1_DATA_21 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA22__LCDIF1_DATA_22 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA23__LCDIF1_DATA_23 0x4001b0b0
+			>;
+		};
+
+		pinctrl_lcdif_ctrl: lcdifctrlgrp {
+			fsl,pins = <
+				MX6SX_PAD_LCD1_CLK__LCDIF1_CLK	0x4001b0b0
+				MX6SX_PAD_LCD1_ENABLE__LCDIF1_ENABLE 0x4001b0b0
+				MX6SX_PAD_LCD1_VSYNC__LCDIF1_VSYNC 0x4001b0b0
+				MX6SX_PAD_LCD1_HSYNC__LCDIF1_HSYNC 0x4001b0b0
+				MX6SX_PAD_LCD1_RESET__GPIO3_IO_27 0x4001b0b0
+				MX6SX_PAD_GPIO1_IO09__GPIO1_IO_9 0x4001b0b0
+				MX6SX_PAD_ENET1_CRS__GPIO2_IO_1 0x110b0
+			>;
+		};
+
+		pinctrl_pwm1: pwm1grp {
+			fsl,pins = <
+				MX6SX_PAD_USB_H_STROBE__PWM1_OUT 0x110b0
+			>;
+		};
+
+		pinctrl_pwm2: pwm2grp {
+			fsl,pins = <
+				MX6SX_PAD_USB_H_DATA__PWM2_OUT 0x110b0
+			>;
+		};
+
+
+		pinctrl_sai1: sai1grp {
+				fsl,pins = <
+						MX6SX_PAD_CSI_DATA00__SAI1_TX_BCLK     0x130b0
+						MX6SX_PAD_CSI_DATA01__SAI1_TX_SYNC     0x130b0
+						MX6SX_PAD_CSI_HSYNC__SAI1_TX_DATA_0    0x120b0
+						MX6SX_PAD_CSI_VSYNC__SAI1_RX_DATA_0    0x130b0
+						MX6SX_PAD_CSI_PIXCLK__AUDMUX_MCLK      0x130b0
+				>;
+		};
+
+		pinctrl_spdif: spdifgrp {
+			fsl,pins = <
+				MX6SX_PAD_ENET1_RX_CLK__SPDIF_OUT          0x1b0b0
+			>;
+		};
+
+		pinctrl_pcie: pciegrp {
+			fsl,pins = <
+				MX6SX_PAD_SD1_CMD__GPIO6_IO_1 0x10b0
+			>;
+		};
+
+
+		pinctrl_vcc_sd2: vccsd2grp {
+			fsl,pins = <
+				MX6SX_PAD_SD4_RESET_B__GPIO6_IO_22		0x17059
+			>;
+		};
+
+		pinctrl_uart1: uart1grp {
+			fsl,pins = <
+				MX6SX_PAD_GPIO1_IO04__UART1_TX		0x1f0b1
+				MX6SX_PAD_GPIO1_IO05__UART1_RX		0x1f0b1
+			>;
+		};
+
+		pinctrl_uart2: uart2grp {
+			fsl,pins = <
+				MX6SX_PAD_SD1_DATA1__UART2_TX		0x1f0b1
+				MX6SX_PAD_SD1_DATA0__UART2_RX		0x1f0b1
+				MX6SX_PAD_SD1_DATA3__UART2_RTS_B	0x1b0b1
+				MX6SX_PAD_SD1_DATA2__UART2_CTS_B	0x1b0b1
+
+				/* RF_ON - Not Connected */
+				/* RF_CD */
+				MX6SX_PAD_GPIO1_IO06__GPIO1_IO_6	0x1b0b1
+
+				/* RF_DTR */
+				MX6SX_PAD_GPIO1_IO07__GPIO1_IO_7	0x1b0b1
+
+				/* RF_RST */
+				MX6SX_PAD_CSI_DATA02__GPIO1_IO_16	0x1b0b1
+			>;
+		};
+
+		pinctrl_uart5: uart5grp {
+			fsl,pins = <
+				MX6SX_PAD_KEY_COL3__UART5_TX		0x1f0b1
+				MX6SX_PAD_KEY_ROW3__UART5_RX		0x1f0b1
+			>;
+		};
+
+		pinctrl_usb_otg1: usbotg1grp {
+			fsl,pins = <
+				MX6SX_PAD_QSPI1A_DATA2__USB_OTG1_PWR	0x10b0
+			>;
+		};
+
+		pinctrl_usb_otg1_id: usbotg1idgrp {
+			fsl,pins = <
+				MX6SX_PAD_GPIO1_IO10__ANATOP_OTG1_ID	0x17059
+			>;
+		};
+
+		pinctrl_usb_otg2: usbot2ggrp {
+			fsl,pins = <
+				MX6SX_PAD_GPIO1_IO12__GPIO1_IO_12	0x10b0
+			>;
+		};
+
+		pinctrl_usdhc2: usdhc2grp {
+			fsl,pins = <
+				MX6SX_PAD_SD2_CMD__USDHC2_CMD		0x17059
+				MX6SX_PAD_SD2_CLK__USDHC2_CLK		0x10059
+				MX6SX_PAD_SD2_DATA0__USDHC2_DATA0	0x17059
+				MX6SX_PAD_SD2_DATA1__USDHC2_DATA1	0x17059
+				MX6SX_PAD_SD2_DATA2__USDHC2_DATA2	0x17059
+				MX6SX_PAD_SD2_DATA3__USDHC2_DATA3	0x17059
+				MX6SX_PAD_KEY_ROW1__GPIO2_IO_16		0x17059 /* CD */
+			>;
+		};
+
+
+
+	};
+};
diff --git a/arch/arm/boot/dts/imx6sxea-com.dtsi b/arch/arm/boot/dts/imx6sxea-com.dtsi
new file mode 100644
index 0000000..7156e4b
--- /dev/null
+++ b/arch/arm/boot/dts/imx6sxea-com.dtsi
@@ -0,0 +1,406 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#include <dt-bindings/input/input.h>
+#include "imx6sx.dtsi"
+
+/ {
+	model = "Embedded Artists i.MX6 SoloX COM Board";
+	compatible = "fsl,imx6sxea-com", "fsl,imx6sx";
+
+	memory {
+		reg = <0x80000000 0x40000000>;
+	};
+
+	regulators {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+
+		reg_vref_3v3: regulator@2 {
+			compatible = "regulator-fixed";
+			regulator-name = "vref-3v3";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+		};
+
+	};
+
+
+};
+
+&adc1 {
+	vref-supply = <&reg_vref_3v3>;
+	status = "okay";
+};
+
+&adc2 {
+	vref-supply = <&reg_vref_3v3>;
+	status = "okay";
+};
+
+
+&cpu0 {
+	operating-points = <
+		/* kHz    uV */
+		996000  1250000
+		792000  1175000
+		396000  1175000
+		198000	1175000
+		>;
+	fsl,soc-operating-points = <
+		/* ARM kHz      SOC uV */
+		996000	1250000
+		792000	1175000
+		396000	1175000
+		198000	1175000
+	>;
+	arm-supply = <&sw1a_reg>;
+	soc-supply = <&sw1a_reg>;
+	fsl,arm-soc-shared = <1>;
+};
+
+&gpc {
+	/* use ldo-bypass, u-boot will check it and configure */
+	fsl,ldo-bypass = <1>;
+};
+
+&fec1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet1>;
+	pinctrl-assert-gpios = <&gpio4 26 GPIO_ACTIVE_HIGH>, <&gpio2 0 GPIO_ACTIVE_LOW>;
+	phy-mode = "rgmii";
+	local-mac-address = [00 1a f1 01 7f 28]; 
+	status = "okay";
+};
+
+&fec2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet2>;
+	phy-mode = "rgmii";
+	local-mac-address = [00 1a f1 01 7f 29]; 
+	status = "okay";
+};
+
+&qspi2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_qspi2_1>;
+	status = "okay";
+
+	ddrsmp=<0>;
+
+	flash0: n25q256a@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "micron,n25q256a";
+		spi-max-frequency = <29000000>;
+		spi-nor,ddr-quad-read-dummy = <6>;
+		reg = <0>;
+	};
+
+	flash1: n25q256a@1 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "micron,n25q256a";
+		spi-max-frequency = <29000000>;
+		spi-nor,ddr-quad-read-dummy = <6>;
+		reg = <1>;
+	};
+
+};
+
+
+/* For eMMC socket on EA COM Board */
+&usdhc3 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc3>;
+	pinctrl-1 = <&pinctrl_usdhc3_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc3_200mhz>;
+	bus-width = <8>;
+	non-removable;
+	status = "okay";
+};
+
+
+&i2c1 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	status = "okay";
+
+	pmic: pfuze100@08 {
+		compatible = "fsl,pfuze200";
+		reg = <0x08>;
+
+		regulators {
+			sw1a_reg: sw1ab {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			sw2_reg: sw2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3a_reg: sw3a {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3b_reg: sw3b {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			swbst_reg: swbst {
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5150000>;
+			};
+
+			snvs_reg: vsnvs {
+				regulator-min-microvolt = <1000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vref_reg: vrefddr {
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vgen1_reg: vgen1 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+				regulator-always-on;
+			};
+
+			vgen2_reg: vgen2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen3_reg: vgen3 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen4_reg: vgen4 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen5_reg: vgen5 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen6_reg: vgen6 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+		};
+	};
+
+
+	at24@55 {
+		compatible = "at,24c64";
+		pagesize = <32>;
+		reg = <0x55>;
+	};
+};
+
+&i2c2 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2>;
+	status = "okay";
+
+};
+
+&i2c3 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3>;
+	status = "okay";
+
+};
+
+
+&vadc {
+	vadc_in = <0>;
+	csi_id = <1>;
+	status = "okay";
+	port {
+		vadc_ep: endpoint {
+			remote-endpoint = <&csi2_ep>;
+		};
+	};
+};
+
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog &pinctrl_can_gpios>;
+
+	imx6xea-com {
+		pinctrl_hog: hoggrp {
+			fsl,pins = <
+				/*MX6SX_PAD_SD1_DATA0__GPIO6_IO_2 0x17059
+				MX6SX_PAD_SD1_DATA3__GPIO6_IO_5 0xb000
+				MX6SX_PAD_CSI_DATA03__GPIO1_IO_17 0x17059*/
+				MX6SX_PAD_GPIO1_IO13__WDOG1_WDOG_ANY 0x30b0
+				/*MX6SX_PAD_QSPI1A_SCLK__GPIO4_IO_21  0x17059*/
+			>;
+		};
+
+		pinctrl_enet1: enet1grp {
+			fsl,pins = <
+				MX6SX_PAD_ENET1_MDIO__ENET1_MDIO	0xa0b1
+				MX6SX_PAD_ENET1_MDC__ENET1_MDC		0xa0b1
+				MX6SX_PAD_RGMII1_TXC__ENET1_RGMII_TXC	0xa0b9
+				MX6SX_PAD_RGMII1_TD0__ENET1_TX_DATA_0	0xa0b1
+				MX6SX_PAD_RGMII1_TD1__ENET1_TX_DATA_1	0xa0b1
+				MX6SX_PAD_RGMII1_TD2__ENET1_TX_DATA_2	0xa0b1
+				MX6SX_PAD_RGMII1_TD3__ENET1_TX_DATA_3	0xa0b1
+				MX6SX_PAD_RGMII1_TX_CTL__ENET1_TX_EN	0xa0b1
+				MX6SX_PAD_RGMII1_RXC__ENET1_RX_CLK	0x3081
+				MX6SX_PAD_RGMII1_RD0__ENET1_RX_DATA_0	0x3081
+				MX6SX_PAD_RGMII1_RD1__ENET1_RX_DATA_1	0x3081
+				MX6SX_PAD_RGMII1_RD2__ENET1_RX_DATA_2	0x3081
+				MX6SX_PAD_RGMII1_RD3__ENET1_RX_DATA_3	0x3081
+				MX6SX_PAD_RGMII1_RX_CTL__ENET1_RX_EN	0x3081
+				MX6SX_PAD_QSPI1A_DATA0__GPIO4_IO_16	0x80000000
+				MX6SX_PAD_ENET1_COL__GPIO2_IO_0 	0x80000000
+				MX6SX_PAD_ENET2_RX_CLK__ENET2_REF_CLK_25M	0x91
+			>;
+		};
+
+		pinctrl_enet2: enet2grp {
+			fsl,pins = <
+				MX6SX_PAD_RGMII2_TXC__ENET2_RGMII_TXC	0xa0b9
+				MX6SX_PAD_RGMII2_TD0__ENET2_TX_DATA_0	0xa0b1
+				MX6SX_PAD_RGMII2_TD1__ENET2_TX_DATA_1	0xa0b1
+				MX6SX_PAD_RGMII2_TD2__ENET2_TX_DATA_2	0xa0b1
+				MX6SX_PAD_RGMII2_TD3__ENET2_TX_DATA_3	0xa0b1
+				MX6SX_PAD_RGMII2_TX_CTL__ENET2_TX_EN	0xa0b1
+				MX6SX_PAD_RGMII2_RXC__ENET2_RX_CLK	0x3081
+				MX6SX_PAD_RGMII2_RD0__ENET2_RX_DATA_0	0x3081
+				MX6SX_PAD_RGMII2_RD1__ENET2_RX_DATA_1	0x3081
+				MX6SX_PAD_RGMII2_RD2__ENET2_RX_DATA_2	0x3081
+				MX6SX_PAD_RGMII2_RD3__ENET2_RX_DATA_3	0x3081
+				MX6SX_PAD_RGMII2_RX_CTL__ENET2_RX_EN	0x3081
+			>;
+		};
+
+
+		pinctrl_i2c1: i2c1grp {
+			fsl,pins = <
+				MX6SX_PAD_GPIO1_IO01__I2C1_SDA 0x4001b8b1
+				MX6SX_PAD_GPIO1_IO00__I2C1_SCL 0x4001b8b1
+			>;
+		};
+
+		pinctrl_i2c2: i2c2grp {
+			fsl,pins = <
+				MX6SX_PAD_GPIO1_IO03__I2C2_SDA 0x4001b8b1
+				MX6SX_PAD_GPIO1_IO02__I2C2_SCL 0x4001b8b1
+			>;
+		};
+
+		pinctrl_i2c3: i2c3grp {
+			fsl,pins = <
+				MX6SX_PAD_KEY_ROW4__I2C3_SDA 0x4001b8b1
+				MX6SX_PAD_KEY_COL4__I2C3_SCL 0x4001b8b1
+			>;
+		};
+
+		pinctrl_qspi2_1: qspi2grp_1 {
+			fsl,pins = <
+				MX6SX_PAD_NAND_WP_B__QSPI2_A_DATA_0     0x70f1
+				MX6SX_PAD_NAND_READY_B__QSPI2_A_DATA_1  0x70f1
+				MX6SX_PAD_NAND_CE0_B__QSPI2_A_DATA_2    0x70f1
+				MX6SX_PAD_NAND_CE1_B__QSPI2_A_DATA_3    0x70f1
+				MX6SX_PAD_NAND_CLE__QSPI2_A_SCLK        0x70f1
+				MX6SX_PAD_NAND_ALE__QSPI2_A_SS0_B       0x70f1
+				MX6SX_PAD_NAND_DATA01__QSPI2_B_DATA_0   0x70f1
+				MX6SX_PAD_NAND_DATA00__QSPI2_B_DATA_1   0x70f1
+				MX6SX_PAD_NAND_WE_B__QSPI2_B_DATA_2     0x70f1
+				MX6SX_PAD_NAND_RE_B__QSPI2_B_DATA_3     0x70f1
+				MX6SX_PAD_NAND_DATA02__QSPI2_B_SCLK     0x70f1
+				/*MX6SX_PAD_NAND_DATA03__QSPI2_B_SS0_B    0x70f1*/
+			>;
+		};
+
+
+		pinctrl_usdhc3: usdhc3grp {
+			fsl,pins = <
+				MX6SX_PAD_SD3_CMD__USDHC3_CMD		0x17069
+				MX6SX_PAD_SD3_CLK__USDHC3_CLK		0x10071
+				MX6SX_PAD_SD3_DATA0__USDHC3_DATA0	0x17069
+				MX6SX_PAD_SD3_DATA1__USDHC3_DATA1	0x17069
+				MX6SX_PAD_SD3_DATA2__USDHC3_DATA2	0x17069
+				MX6SX_PAD_SD3_DATA3__USDHC3_DATA3	0x17069
+				MX6SX_PAD_SD3_DATA4__USDHC3_DATA4	0x17069
+				MX6SX_PAD_SD3_DATA5__USDHC3_DATA5	0x17069
+				MX6SX_PAD_SD3_DATA6__USDHC3_DATA6	0x17069
+				MX6SX_PAD_SD3_DATA7__USDHC3_DATA7	0x17069
+				/*MX6SX_PAD_KEY_COL0__GPIO2_IO_10		0x17059 /* CD * / */
+				/*MX6SX_PAD_KEY_ROW0__GPIO2_IO_15		0x17059 /* WP * / */
+			>;
+		};
+
+		pinctrl_usdhc3_100mhz: usdhc3grp-100mhz {
+			fsl,pins = <
+				MX6SX_PAD_SD3_CMD__USDHC3_CMD		0x170b9
+				MX6SX_PAD_SD3_CLK__USDHC3_CLK		0x100b9
+				MX6SX_PAD_SD3_DATA0__USDHC3_DATA0	0x170b9
+				MX6SX_PAD_SD3_DATA1__USDHC3_DATA1	0x170b9
+				MX6SX_PAD_SD3_DATA2__USDHC3_DATA2	0x170b9
+				MX6SX_PAD_SD3_DATA3__USDHC3_DATA3	0x170b9
+				MX6SX_PAD_SD3_DATA4__USDHC3_DATA4	0x170b9
+				MX6SX_PAD_SD3_DATA5__USDHC3_DATA5	0x170b9
+				MX6SX_PAD_SD3_DATA6__USDHC3_DATA6	0x170b9
+				MX6SX_PAD_SD3_DATA7__USDHC3_DATA7	0x170b9
+			>;
+		};
+
+		pinctrl_usdhc3_200mhz: usdhc3grp-200mhz {
+			fsl,pins = <
+				MX6SX_PAD_SD3_CMD__USDHC3_CMD		0x170f9
+				MX6SX_PAD_SD3_CLK__USDHC3_CLK		0x100f9
+				MX6SX_PAD_SD3_DATA0__USDHC3_DATA0	0x170f9
+				MX6SX_PAD_SD3_DATA1__USDHC3_DATA1	0x170f9
+				MX6SX_PAD_SD3_DATA2__USDHC3_DATA2	0x170f9
+				MX6SX_PAD_SD3_DATA3__USDHC3_DATA3	0x170f9
+				MX6SX_PAD_SD3_DATA4__USDHC3_DATA4	0x170f9
+				MX6SX_PAD_SD3_DATA5__USDHC3_DATA5	0x170f9
+				MX6SX_PAD_SD3_DATA6__USDHC3_DATA6	0x170f9
+				MX6SX_PAD_SD3_DATA7__USDHC3_DATA7	0x170f9
+			>;
+		};
+
+
+	};
+};
diff --git a/arch/arm/boot/dts/imx6ulea-com-kit-rf.dts b/arch/arm/boot/dts/imx6ulea-com-kit-rf.dts
new file mode 100644
index 0000000..35deaef
--- /dev/null
+++ b/arch/arm/boot/dts/imx6ulea-com-kit-rf.dts
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "imx6ulea-com-kit.dts"
+
+&flexcan2 {
+	status = "disabled";
+};
+
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "okay";
+
+	fsl,uart-has-rtscts;
+	#fsl,irda-mode;
+	#fsl,dte-mode;
+};
+
+&pinctrl_uart2 {
+	fsl,pins = <
+		MX6UL_PAD_UART2_TX_DATA__UART2_DCE_TX	0x1f0b1
+		MX6UL_PAD_UART2_RX_DATA__UART2_DCE_RX	0x1f0b1
+		MX6UL_PAD_UART2_RTS_B__UART2_DCE_RTS 	0x1b0b1
+		MX6UL_PAD_UART2_CTS_B__UART2_DCE_CTS 	0x1b0b1
+
+		/* RF_ON */
+		/* MX6UL_PAD_NAND_DQS__GPIO4_IO16 	0x1b0b1*/
+
+		/* RF_CD */
+		MX6UL_PAD_UART1_RTS_B__GPIO1_IO19 	0x1b0b1
+
+		/* RF_DTR */
+		MX6UL_PAD_UART1_CTS_B__GPIO1_IO18 	0x1b0b1
+
+		/* RF_RST */
+		MX6UL_PAD_CSI_DATA02__GPIO4_IO23 	0x1b0b1
+	>;
+};
diff --git a/arch/arm/boot/dts/imx6ulea-com-kit.dts b/arch/arm/boot/dts/imx6ulea-com-kit.dts
new file mode 100644
index 0000000..51be0c1
--- /dev/null
+++ b/arch/arm/boot/dts/imx6ulea-com-kit.dts
@@ -0,0 +1,426 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/dts-v1/;
+
+#include "imx6ulea-com.dtsi"
+
+/ {
+	model = "Embedded Artists i.MX6 UltraLite COM Kit";
+	compatible = "fsl,imx6ulea-com", "fsl,imx6ul";
+
+	/* Aliases to allow u-boot to modify the device tree */
+	aliases {
+		fb_rgb = &lcdif;
+		t_rgb = &t_lcd;
+		bl_rgb = &backlight_lcd;
+		rgb = &display0;
+		ts_con_rgb = &i2c1;
+	};
+
+	chosen {
+		stdout-path = &uart1;
+	};
+
+	backlight_lcd: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pwm1 0 5000000>;
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <6>;
+		status = "okay";
+	};
+
+	pxp_v4l2 {
+		compatible = "fsl,imx6ul-pxp-v4l2", "fsl,imx6sx-pxp-v4l2", "fsl,imx6sl-pxp-v4l2";
+		status = "okay";
+	};
+
+	regulators {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_can_3v3: regulator@0 {
+			compatible = "regulator-fixed";
+			reg = <0>;
+			regulator-name = "can-3v3";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			gpios = <&gpio5 1 GPIO_ACTIVE_LOW>;
+		};
+
+		reg_sd1_vmmc: regulator@1 {
+			compatible = "regulator-fixed";
+			regulator-name = "VSD_3V3";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			gpio = <&gpio1 9 GPIO_ACTIVE_HIGH>;
+			enable-active-high;
+		};
+
+		reg_3v3: regulator@2 {
+			compatible = "regulator-fixed";
+			reg = <2>;
+			regulator-name = "reg-3v3";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+		};
+
+	};
+
+	sound {
+		compatible = "fsl,imx-audio-wm8731";
+		model = "wm8731-audio";
+		ssi-controller = <&sai2>;
+		src-port = <2>;
+		ext-port = <3>;
+		audio-codec = <&codec>;
+		audio-routing = "LOUT", "ROUT", "LLINEIN", "RLINEIN";
+		gpr = <&gpr 0x4 20>;
+	};
+
+
+};
+
+
+&clks {
+	assigned-clocks = <&clks IMX6UL_CLK_PLL4_AUDIO_DIV>;
+	assigned-clock-rates = <860160000>;
+};
+
+
+&flexcan1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1>;
+	xceiver-supply = <&reg_can_3v3>;
+	trx-en-gpio = <&gpio5 1 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+&flexcan2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan2>;
+	xceiver-supply = <&reg_can_3v3>;
+	trx-en-gpio = <&gpio5 1 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+
+&lcdif {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_lcdif_dat
+		     &pinctrl_lcdif_ctrl>;
+	display = <&display0>;
+	status = "okay";
+
+	display0: display {
+		bits-per-pixel = <32>;
+		bus-width = <24>;
+
+		/* EA 7" display */
+		display-timings {
+			native-mode = <&t_lcd>;
+			t_lcd: t_lcd_default {
+				/* values may be changed in bootscript */
+				clock-frequency = <33500000>;
+				hactive = <800>;
+				vactive = <480>;
+				hback-porch = <89>;
+				hfront-porch = <164>;
+				vback-porch = <75>;/*<23>;*/
+				vfront-porch = <75>;/*<10>;*/
+				hsync-len = <10>;
+				vsync-len = <10>;
+				hsync-active = <0>;
+				vsync-active = <0>;
+				de-active = <1>;
+				pixelclk-active = <1>;
+			};
+		};
+	};
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm1>;
+	status = "okay";
+};
+
+&pxp {
+	status = "okay";
+};
+
+&sai2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai2>;
+
+	assigned-clocks = <&clks IMX6UL_CLK_SAI2_SEL>,
+			  <&clks IMX6UL_CLK_SAI2>;
+	assigned-clock-parents = <&clks IMX6UL_CLK_PLL4_AUDIO_DIV>;
+	assigned-clock-rates = <0>, <12288000>;
+
+	status = "okay";
+};
+
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	status = "okay";
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "okay";
+};
+
+&uart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart3>;
+	status = "okay";
+};
+
+&usbotg1 {
+	vbus-supply = <&reg_3v3>;
+	status = "okay";
+};
+
+&usbotg2 {
+	dr_mode = "host";
+	disable-over-current;
+	status = "okay";
+};
+
+
+&usdhc1 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc1>;
+	pinctrl-1 = <&pinctrl_usdhc1_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc1_200mhz>;
+	cd-gpios = <&gpio1 3 0>;
+	keep-power-in-suspend;
+	enable-sdio-wakeup;
+	vmmc-supply = <&reg_sd1_vmmc>;
+	status = "okay";
+};
+
+
+&i2c1 {
+
+	codec: wm8731@1a {
+		compatible = "wlf,wm8731";
+		reg = <0x1a>;
+		clocks = <&clks IMX6UL_CLK_SAI2>;
+
+		AVDD-supply = <&vgen5_reg>;
+		HPVDD-supply = <&vgen5_reg>;
+		DCVDD-supply = <&vgen5_reg>;
+		DBVDD-supply = <&vgen5_reg>;
+
+	};
+
+	/* AR1021 touch controller through RGB display interface connector on Carrier Board */
+	ar1021_rgb@4d {
+		compatible = "microchip,ar1021-i2c";
+		reg = <0x4d>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_rgb_connector>;
+		interrupt-parent = <&gpio4>;
+		interrupts = <24 IRQ_TYPE_EDGE_FALLING>;
+		ar1021,swap_xy;
+		ar1021,invert_x;
+		#ar1021,invert_y;
+	};
+
+	/* eGalax touch controller through RGB display interface connector on Carrier Board */
+	egalax_ts_rgb@04 {
+		compatible = "eeti,egalax_ts";
+		reg = <0x04>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_rgb_connector>;
+		interrupt-parent = <&gpio4>;
+		interrupts = <24 IRQ_TYPE_EDGE_FALLING>;
+		wakeup-gpios = <&gpio4 24 GPIO_ACTIVE_HIGH>;
+	};
+
+	/* FocalTech touch controller through RGB display interface connector on Carrier Board */
+	edt-ft5x06_rgb@38 {
+		compatible = "edt,edt-ft5x06";
+		reg = <0x38>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_rgb_connector>;
+		interrupt-parent = <&gpio4>;
+		interrupts = <24 IRQ_TYPE_EDGE_FALLING>;
+		status = "disabled";
+	};
+
+	/* Ilitek touch controller through RGB display interface connector on Carrier Board */
+	ilitek_aim_rgb@41 {
+		compatible = "ilitek,ilitek_aim";
+		reg = <0x41>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_rgb_connector>;
+		interrupt-parent = <&gpio4>;
+		interrupts = <24 IRQ_TYPE_EDGE_FALLING>;
+	};
+
+	/* Sitronix touch controller through RGB display interface connector on Carrier Board */
+	sitronix_rgb@55 {
+		compatible = "sitronix,sitronix_i2c";
+		reg = <0x55>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_rgb_connector>;
+		interrupt-parent = <&gpio4>;
+		interrupts = <24 IRQ_TYPE_EDGE_FALLING>;
+	};
+};
+
+
+
+&iomuxc {
+
+	imx6ulea-com-kit {
+
+
+		pinctrl_flexcan1: flexcan1grp{
+			fsl,pins = <
+				MX6UL_PAD_UART3_RTS_B__FLEXCAN1_RX	0x1b020
+				MX6UL_PAD_UART3_CTS_B__FLEXCAN1_TX	0x1b020
+			>;
+		};
+
+		pinctrl_flexcan2: flexcan2grp{
+			fsl,pins = <
+				MX6UL_PAD_UART2_RTS_B__FLEXCAN2_RX	0x1b020
+				MX6UL_PAD_UART2_CTS_B__FLEXCAN2_TX	0x1b020
+			>;
+		};
+
+		pinctrl_lcdif_dat: lcdifdatgrp {
+			fsl,pins = <
+				MX6UL_PAD_LCD_DATA00__LCDIF_DATA00  0x79
+				MX6UL_PAD_LCD_DATA01__LCDIF_DATA01  0x79
+				MX6UL_PAD_LCD_DATA02__LCDIF_DATA02  0x79
+				MX6UL_PAD_LCD_DATA03__LCDIF_DATA03  0x79
+				MX6UL_PAD_LCD_DATA04__LCDIF_DATA04  0x79
+				MX6UL_PAD_LCD_DATA05__LCDIF_DATA05  0x79
+				MX6UL_PAD_LCD_DATA06__LCDIF_DATA06  0x79
+				MX6UL_PAD_LCD_DATA07__LCDIF_DATA07  0x79
+				MX6UL_PAD_LCD_DATA08__LCDIF_DATA08  0x79
+				MX6UL_PAD_LCD_DATA09__LCDIF_DATA09  0x79
+				MX6UL_PAD_LCD_DATA10__LCDIF_DATA10  0x79
+				MX6UL_PAD_LCD_DATA11__LCDIF_DATA11  0x79
+				MX6UL_PAD_LCD_DATA12__LCDIF_DATA12  0x79
+				MX6UL_PAD_LCD_DATA13__LCDIF_DATA13  0x79
+				MX6UL_PAD_LCD_DATA14__LCDIF_DATA14  0x79
+				MX6UL_PAD_LCD_DATA15__LCDIF_DATA15  0x79
+				MX6UL_PAD_LCD_DATA16__LCDIF_DATA16  0x79
+				MX6UL_PAD_LCD_DATA17__LCDIF_DATA17  0x79
+				MX6UL_PAD_LCD_DATA18__LCDIF_DATA18  0x79
+				MX6UL_PAD_LCD_DATA19__LCDIF_DATA19  0x79
+				MX6UL_PAD_LCD_DATA20__LCDIF_DATA20  0x79
+				MX6UL_PAD_LCD_DATA21__LCDIF_DATA21  0x79
+				MX6UL_PAD_LCD_DATA22__LCDIF_DATA22  0x79
+				MX6UL_PAD_LCD_DATA23__LCDIF_DATA23  0x79
+			>;
+		};
+
+		pinctrl_lcdif_ctrl: lcdifctrlgrp {
+			fsl,pins = <
+				MX6UL_PAD_LCD_CLK__LCDIF_CLK	    0x79
+				MX6UL_PAD_LCD_ENABLE__LCDIF_ENABLE  0x79
+				MX6UL_PAD_LCD_HSYNC__LCDIF_HSYNC    0x79
+				MX6UL_PAD_LCD_VSYNC__LCDIF_VSYNC    0x79
+				/* Display power enable */
+				MX6UL_PAD_GPIO1_IO02__GPIO1_IO02    0x79
+			>;
+		};
+
+		pinctrl_pwm1: pwm1grp {
+			fsl,pins = <
+				MX6UL_PAD_GPIO1_IO08__PWM1_OUT   0x110b0
+			>;
+		};
+
+
+		pinctrl_uart1: uart1grp {
+			fsl,pins = <
+				MX6UL_PAD_UART1_TX_DATA__UART1_DCE_TX 0x1f0b1
+				MX6UL_PAD_UART1_RX_DATA__UART1_DCE_RX 0x1f0b1
+			>;
+		};
+
+		pinctrl_uart2: uart2grp {
+			fsl,pins = <
+				MX6UL_PAD_UART2_TX_DATA__UART2_DCE_TX	0x1f0b1
+				MX6UL_PAD_UART2_RX_DATA__UART2_DCE_RX	0x1f0b1
+			>;
+		};
+
+		pinctrl_uart3: uart3grp {
+			fsl,pins = <
+				MX6UL_PAD_UART3_TX_DATA__UART3_DCE_TX	0x1f0b1
+				MX6UL_PAD_UART3_RX_DATA__UART3_DCE_RX	0x1f0b1
+			>;
+		};
+
+
+		pinctrl_usdhc1: usdhc1grp {
+			fsl,pins = <
+				MX6UL_PAD_SD1_CMD__USDHC1_CMD     0x17059
+				MX6UL_PAD_SD1_CLK__USDHC1_CLK     0x10071
+				MX6UL_PAD_SD1_DATA0__USDHC1_DATA0 0x17059
+				MX6UL_PAD_SD1_DATA1__USDHC1_DATA1 0x17059
+				MX6UL_PAD_SD1_DATA2__USDHC1_DATA2 0x17059
+				MX6UL_PAD_SD1_DATA3__USDHC1_DATA3 0x17059
+				MX6UL_PAD_GPIO1_IO03__GPIO1_IO03  0x17059
+			>;
+		};
+
+		pinctrl_usdhc1_100mhz: usdhc1grp100mhz {
+			fsl,pins = <
+				MX6UL_PAD_SD1_CMD__USDHC1_CMD     0x170b9
+				MX6UL_PAD_SD1_CLK__USDHC1_CLK     0x100b9
+				MX6UL_PAD_SD1_DATA0__USDHC1_DATA0 0x170b9
+				MX6UL_PAD_SD1_DATA1__USDHC1_DATA1 0x170b9
+				MX6UL_PAD_SD1_DATA2__USDHC1_DATA2 0x170b9
+				MX6UL_PAD_SD1_DATA3__USDHC1_DATA3 0x170b9
+			>;
+		};
+
+		pinctrl_usdhc1_200mhz: usdhc1grp200mhz {
+			fsl,pins = <
+				MX6UL_PAD_SD1_CMD__USDHC1_CMD     0x170f9
+				MX6UL_PAD_SD1_CLK__USDHC1_CLK     0x100f9
+				MX6UL_PAD_SD1_DATA0__USDHC1_DATA0 0x170f9
+				MX6UL_PAD_SD1_DATA1__USDHC1_DATA1 0x170f9
+				MX6UL_PAD_SD1_DATA2__USDHC1_DATA2 0x170f9
+				MX6UL_PAD_SD1_DATA3__USDHC1_DATA3 0x170f9
+			>;
+		};
+
+
+		pinctrl_sai2: sai2grp {
+			fsl,pins = <
+				MX6UL_PAD_JTAG_TDI__SAI2_TX_BCLK	0x17088
+				MX6UL_PAD_JTAG_TDO__SAI2_TX_SYNC	0x17088
+				MX6UL_PAD_JTAG_TRST_B__SAI2_TX_DATA	0x11088
+				MX6UL_PAD_JTAG_TCK__SAI2_RX_DATA	0x11088
+				MX6UL_PAD_JTAG_TMS__SAI2_MCLK		0x17088
+			>;
+		};
+
+		pinctrl_rgb_connector: rgb_connector_grp {
+			fsl,pins = <
+				MX6UL_PAD_CSI_DATA03__GPIO4_IO24       0x1b0b0
+			>;
+		};
+
+	};
+};
diff --git a/arch/arm/boot/dts/imx6ulea-com.dtsi b/arch/arm/boot/dts/imx6ulea-com.dtsi
new file mode 100644
index 0000000..312f485
--- /dev/null
+++ b/arch/arm/boot/dts/imx6ulea-com.dtsi
@@ -0,0 +1,305 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#include <dt-bindings/input/input.h>
+#include "imx6ul.dtsi"
+
+/ {
+	model = "Embedded Artists i.MX6 UltraLite COM Board";
+	compatible = "fsl,imx6ulea-com", "fsl,imx6ul";
+
+	memory {
+		reg = <0x80000000 0x20000000>;
+	};
+
+};
+
+&cpu0 {
+	operating-points = <
+		/* kHz	uV */
+		528000	1175000
+		396000	1175000
+		198000	1175000
+	>;
+	fsl,soc-operating-points = <
+		/* KHz	uV */
+		528000	1175000
+		396000	1175000
+		198000	1175000
+	>;
+
+	arm-supply = <&sw1c_reg>;
+	soc-supply = <&sw1c_reg>;
+	fsl,arm-soc-shared = <1>;
+};
+
+
+&fec1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet1>;
+	phy-mode = "rmii";
+	phy-handle = <&ethphy0>;
+	status = "okay";
+};
+
+&fec2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet2>;
+	phy-mode = "rmii";
+	phy-handle = <&ethphy1>;
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy0: ethernet-phy@2 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <2>;
+		};
+
+		ethphy1: ethernet-phy@1 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <1>;
+		};
+	};
+};
+
+&gpc {
+	fsl,cpu_pupscr_sw2iso = <0x1>;
+	fsl,cpu_pupscr_sw = <0x0>;
+	fsl,cpu_pdnscr_iso2sw = <0x1>;
+	fsl,cpu_pdnscr_iso = <0x1>;
+	fsl,wdog-reset = <1>; /* watchdog select of reset source */
+	fsl,ldo-bypass = <1>; /* use ldo-bypass, u-boot will check it and configure */
+};
+
+
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2>;
+	bus-width = <8>;
+	non-removable;
+	status = "okay";
+};
+
+&i2c1 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	status = "okay";
+
+	pmic: pfuze3000@08 {
+		compatible = "fsl,pfuze3000";
+		reg = <0x08>;
+
+		regulators {
+			sw1a_reg: sw1a {
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			/* use sw1c_reg to align with pfuze100/pfuze200 */
+			sw1c_reg: sw1b {
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1475000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			sw2_reg: sw2 {
+				regulator-min-microvolt = <1500000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3a_reg: sw3 {
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <1650000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			swbst_reg: swbst {
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5150000>;
+			};
+
+			snvs_reg: vsnvs {
+				regulator-min-microvolt = <1000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vref_reg: vrefddr {
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vgen1_reg: vldo1 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen2_reg: vldo2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+				regulator-always-on;
+			};
+
+			vgen3_reg: vccsd {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen4_reg: v33 {
+				regulator-min-microvolt = <2850000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen5_reg: vldo3 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen6_reg: vldo4 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+		};
+	};
+
+	at24@55 {
+		compatible = "at,24c64";
+		pagesize = <32>;
+		reg = <0x55>;
+	};
+
+};
+
+&i2c2 {
+	clock_frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2>;
+	status = "okay";
+};
+
+&qspi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_qspi>;
+	status = "okay";
+	ddrsmp=<0>;
+
+	flash0: n25q256a@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "micron,n25q256a";
+		spi-max-frequency = <29000000>;
+		spi-nor,ddr-quad-read-dummy = <6>;
+		reg = <0>;
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog_1>;
+	imx6ulea-com {
+		pinctrl_hog_1: hoggrp-1 {
+			fsl,pins = <
+				MX6UL_PAD_LCD_RESET__WDOG1_WDOG_ANY    0x30b0
+				MX6UL_PAD_GPIO1_IO05__USDHC1_VSELECT	0x17059 /* SD1 VSELECT */
+				MX6UL_PAD_GPIO1_IO09__GPIO1_IO09        0x17059 /* SD1 RESET */
+				MX6UL_PAD_SNVS_TAMPER1__GPIO5_IO01      0x17059 /* CAN Regulator */
+			>;
+		};
+
+
+		pinctrl_enet1: enet1grp {
+			fsl,pins = <
+				MX6UL_PAD_ENET1_RX_EN__ENET1_RX_EN	0x1b0b0
+				MX6UL_PAD_ENET1_RX_ER__ENET1_RX_ER	0x1b0b0
+				MX6UL_PAD_ENET1_RX_DATA0__ENET1_RDATA00	0x1b0b0
+				MX6UL_PAD_ENET1_RX_DATA1__ENET1_RDATA01	0x1b0b0
+				MX6UL_PAD_ENET1_TX_EN__ENET1_TX_EN	0x1b0b0
+				MX6UL_PAD_ENET1_TX_DATA0__ENET1_TDATA00	0x1b0b0
+				MX6UL_PAD_ENET1_TX_DATA1__ENET1_TDATA01	0x1b0b0
+				MX6UL_PAD_ENET1_TX_CLK__ENET1_REF_CLK1	0x4001b031
+			>;
+		};
+
+		pinctrl_enet2: enet2grp {
+			fsl,pins = <
+				MX6UL_PAD_GPIO1_IO07__ENET2_MDC		0x1b0b0
+				MX6UL_PAD_GPIO1_IO06__ENET2_MDIO	0x1b0b0
+				MX6UL_PAD_ENET2_RX_EN__ENET2_RX_EN	0x1b0b0
+				MX6UL_PAD_ENET2_RX_ER__ENET2_RX_ER	0x1b0b0
+				MX6UL_PAD_ENET2_RX_DATA0__ENET2_RDATA00	0x1b0b0
+				MX6UL_PAD_ENET2_RX_DATA1__ENET2_RDATA01	0x1b0b0
+				MX6UL_PAD_ENET2_TX_EN__ENET2_TX_EN	0x1b0b0
+				MX6UL_PAD_ENET2_TX_DATA0__ENET2_TDATA00	0x1b0b0
+				MX6UL_PAD_ENET2_TX_DATA1__ENET2_TDATA01	0x1b0b0
+				MX6UL_PAD_ENET2_TX_CLK__ENET2_REF_CLK2	0x4001b031
+				MX6UL_PAD_SNVS_TAMPER0__GPIO5_IO00	0x80000000
+			>;
+		};
+
+
+
+		pinctrl_usdhc2: usdhc2grp {
+			fsl,pins = <
+				MX6UL_PAD_NAND_RE_B__USDHC2_CLK     0x10069
+				MX6UL_PAD_NAND_WE_B__USDHC2_CMD     0x17059
+				MX6UL_PAD_NAND_DATA00__USDHC2_DATA0 0x17059
+				MX6UL_PAD_NAND_DATA01__USDHC2_DATA1 0x17059
+				MX6UL_PAD_NAND_DATA02__USDHC2_DATA2 0x17059
+				MX6UL_PAD_NAND_DATA03__USDHC2_DATA3 0x17059
+			>;
+		};
+
+
+		pinctrl_i2c1: i2c1grp {
+			fsl,pins = <
+				MX6UL_PAD_UART4_TX_DATA__I2C1_SCL 0x4001b8b0
+				MX6UL_PAD_UART4_RX_DATA__I2C1_SDA 0x4001b8b0
+			>;
+		};
+
+		pinctrl_i2c2: i2c2grp {
+			fsl,pins = <
+				MX6UL_PAD_UART5_TX_DATA__I2C2_SCL 0x4001b8b0
+				MX6UL_PAD_UART5_RX_DATA__I2C2_SDA 0x4001b8b0
+			>;
+		};
+
+		pinctrl_qspi: qspigrp {
+			fsl,pins = <
+				MX6UL_PAD_NAND_WP_B__QSPI_A_SCLK      0x70a1
+				MX6UL_PAD_NAND_READY_B__QSPI_A_DATA00 0x70a1
+				MX6UL_PAD_NAND_CE0_B__QSPI_A_DATA01   0x70a1
+				MX6UL_PAD_NAND_CE1_B__QSPI_A_DATA02   0x70a1
+				MX6UL_PAD_NAND_CLE__QSPI_A_DATA03     0x70a1
+				MX6UL_PAD_NAND_DQS__QSPI_A_SS0_B      0x70a1
+			>;
+		};
+
+
+
+	};
+};
diff --git a/arch/arm/boot/dts/imx7dea-ucom-kit-lvds.dts b/arch/arm/boot/dts/imx7dea-ucom-kit-lvds.dts
new file mode 100644
index 0000000..6bd5eec
--- /dev/null
+++ b/arch/arm/boot/dts/imx7dea-ucom-kit-lvds.dts
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "imx7dea-ucom-kit.dts"
+
+
+
+/*
+ * Disable the RGB interface to only have LVDS enabled
+ */
+
+
+&ar1021 {
+	status = "disabled";
+};
+
+&egalax {
+	status = "okay";
+};
+
+&timing0 {
+        hactive = <1024>;
+        vactive = <768>;
+};
+
+&backlight {
+	pwms = <&pwm3 0 5000000>;
+};
+
+
+
diff --git a/arch/arm/boot/dts/imx7dea-ucom-kit.dts b/arch/arm/boot/dts/imx7dea-ucom-kit.dts
new file mode 100644
index 0000000..31e8c17
--- /dev/null
+++ b/arch/arm/boot/dts/imx7dea-ucom-kit.dts
@@ -0,0 +1,939 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/input/input.h>
+#include "imx7d.dtsi"
+
+/ {
+	model = "Embedded Artists i.MX7 Dual uCOM Kit";
+	compatible = "fsl,imx7dea-ucom", "fsl,imx7d";
+
+ 	memory {
+		reg = <0x80000000 0x80000000>;
+	};
+
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pwm1 0 5000000>;
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <6>;
+		enable-gpios = <&gpio2 24 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	pxp_v4l2_out {
+		compatible = "fsl,imx7d-pxp-v4l2", "fsl,imx6sx-pxp-v4l2", "fsl,imx6sl-pxp-v4l2";
+		status = "okay";
+	};
+
+	regulators {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_usb_otg1_vbus: regulator@0 {
+			compatible = "regulator-fixed";
+			reg = <0>;
+			regulator-name = "usb_otg1_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio1 5 GPIO_ACTIVE_HIGH>;
+			enable-active-high;
+		};
+
+		reg_usb_otg2_vbus: regulator@1 {
+			compatible = "regulator-fixed";
+			reg = <1>;
+			regulator-name = "usb_otg2_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio4 7 GPIO_ACTIVE_HIGH>;
+			enable-active-high;
+		};
+
+		reg_can2_3v3: regulator@2 {
+			compatible = "regulator-fixed";
+			reg = <2>;
+			regulator-name = "can2-3v3";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			gpio = <&gpio2 14 GPIO_ACTIVE_LOW>;
+		};
+
+		reg_vref_1v8: regulator@3 {
+			compatible = "regulator-fixed";
+			regulator-name = "vref-1v8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+		};
+
+		reg_pcie: regulator@4 {
+			compatible = "regulator-fixed";
+			reg = <4>;
+			regulator-name = "MPCIE_3V3";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+			enable-active-high;
+		};
+
+		reg_sd1_vmmc: regulator@5 {
+			compatible = "regulator-fixed";
+			regulator-name = "VDD_SD1";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			gpio = <&gpio5 2 GPIO_ACTIVE_HIGH>;
+			startup-delay-us = <200000>;
+			enable-active-high;
+		};
+
+		wlreg_on: fixedregulator@100 {
+			compatible = "regulator-fixed";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			regulator-name = "wlreg_on";
+			gpio = <&gpio4 21 GPIO_ACTIVE_HIGH>;
+			enable-active-high;
+		};
+	};
+
+        sound {
+                compatible = "fsl,imx-audio-wm8731";
+                model = "wm8731-audio";
+                ssi-controller = <&sai1>;
+                src-port = <2>;
+                ext-port = <3>;
+                audio-codec = <&codec>;
+                audio-routing = "LOUT", "ROUT", "LLINEIN", "RLINEIN";
+        };
+
+
+};
+
+&adc1 {
+	vref-supply = <&reg_vref_1v8>;
+	status = "okay";
+};
+
+&adc2 {
+	vref-supply = <&reg_vref_1v8>;
+	status = "okay";
+};
+
+&clks {
+	assigned-clocks = <&clks IMX7D_PLL_AUDIO_POST_DIV>;
+	assigned-clock-rates = <869299200>;
+};
+
+&cpu0 {
+	arm-supply = <&buck1_reg>;
+};
+
+&csi1 {
+	csi-mux-mipi = <&gpr 0x14 4>;
+	status = "okay";
+
+	port {
+		csi_ep: endpoint {
+			remote-endpoint = <&csi_mipi_ep>;
+		};
+	};
+};
+
+&epxp {
+	status = "okay";
+};
+
+
+&fec1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet1>;
+	pinctrl-assert-gpios = <&gpio7 15 GPIO_ACTIVE_LOW>;
+	assigned-clocks = <&clks IMX7D_ENET1_TIME_ROOT_SRC>,
+			  <&clks IMX7D_ENET1_TIME_ROOT_CLK>;
+	assigned-clock-parents = <&clks IMX7D_PLL_ENET_MAIN_100M_CLK>;
+	assigned-clock-rates = <0>, <100000000>;
+	phy-mode = "rgmii";
+	phy-handle = <&ethphy0>;
+	fsl,magic-packet;
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy0: ethernet-phy@1 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <1>;
+		};
+	};
+};
+
+
+&flexcan2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan2>;
+	xceiver-supply = <&reg_can2_3v3>;
+	status = "okay";
+};
+
+&mipi_csi {
+	clock-frequency = <240000000>;
+	status = "okay";
+	port {
+		mipi_sensor_ep: endpoint1 {
+			remote-endpoint = <&ov5647_mipi_ep>;
+			data-lanes = <2>;
+			csis-hs-settle = <13>;
+			csis-wclk;
+		};
+
+		csi_mipi_ep: endpoint2 {
+			remote-endpoint = <&csi_ep>;
+		};
+	};
+};
+
+&i2c1 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	status = "okay";
+
+	pmic: bd7181x@4b {
+		reg = <0x4b>;
+		compatible = "rohm,bd71815";
+		/* PMIC_INT_B GPIO1_IO12 */
+		gpio_intr = <&gpio1 12 0>;
+
+		gpo {
+			rohm,mode = <0x30>;	/* 0b0011_0000 all gpos with cmos output mode */
+		};
+
+		regulators {
+			/* #address-cells = <1>;
+			#size-cells = <0>; */
+
+                        buck1_reg: buck1 {
+                                regulator-min-microvolt = <800000>;
+                                regulator-max-microvolt = <2000000>;
+                                regulator-boot-on;
+                                regulator-always-on;
+                                regulator-ramp-delay = <6250>;
+                        };
+
+                        buck2_reg: buck2 {
+                                regulator-min-microvolt = <800000>;
+                                regulator-max-microvolt = <2000000>;
+                                regulator-boot-on;
+                                regulator-always-on;
+                                regulator-ramp-delay = <6250>;
+                        };
+
+                        buck3_reg: buck3 {
+                                regulator-min-microvolt = <1200000>;
+                                regulator-max-microvolt = <2700000>;
+                                regulator-boot-on;
+                                regulator-always-on;
+                        };
+
+                        buck4_reg: buck4 {
+                                regulator-min-microvolt = <1100000>;
+                                regulator-max-microvolt = <1850000>;
+                                regulator-boot-on;
+                                regulator-always-on;
+                        };
+
+                        buck5_reg: buck5 {
+                                regulator-min-microvolt = <1800000>;
+                                regulator-max-microvolt = <3300000>;
+                                regulator-boot-on;
+                                regulator-always-on;
+                        };
+
+                        ldo1_reg: ldo1 {
+                                regulator-min-microvolt = <800000>;
+                                regulator-max-microvolt = <3300000>;
+                                regulator-boot-on;
+                                regulator-always-on;
+                        };
+
+                        ldo2_reg: ldo2 {
+                                regulator-min-microvolt = <800000>;
+                                regulator-max-microvolt = <3300000>;
+                                regulator-boot-on;
+                                regulator-always-on;
+                        };
+
+                        ldo3_reg: ldo3 {
+                                regulator-min-microvolt = <800000>;
+                                regulator-max-microvolt = <3300000>;
+                                regulator-boot-on;
+                                regulator-always-on;
+                        };
+
+                        ldo4_reg: ldo4 {
+                                regulator-min-microvolt = <800000>;
+                                regulator-max-microvolt = <3300000>;
+                                regulator-boot-on;
+                                regulator-always-on;
+                        };
+
+                        ldo5_reg: ldo5 {
+                                regulator-min-microvolt = <800000>;
+                                regulator-max-microvolt = <3300000>;
+                                regulator-boot-on;
+                                regulator-always-on;
+                        };
+
+                        dvref_reg: dvref {
+                                regulator-boot-on;
+                                regulator-always-on;
+                        };
+
+                        lpsr_reg: lpsr {
+                                regulator-boot-on;
+                                regulator-always-on;
+                        };
+
+                        wled_reg: wled {
+                                regulator-min-microamp = <10>;
+                                regulator-max-microamp = <25000>;
+                                regulator-boot-on;
+                                regulator-always-on;
+                        };
+
+		};
+		regulator-virtuals {
+			compatible = "simple-bus";
+
+			virt-buck1 {
+				compatible = "regulator-virtual";
+				virtual-supply = "buck1";
+			};
+			virt-buck2 {
+				compatible = "regulator-virtual";
+				virtual-supply = "buck2";
+			};
+			virt-buck3 {
+				compatible = "regulator-virtual";
+				virtual-supply = "buck3";
+			};
+			virt-buck4 {
+				compatible = "regulator-virtual";
+				virtual-supply = "buck4";
+			};
+			virt-buck5 {
+				compatible = "regulator-virtual";
+				virtual-supply = "buck5";
+			};
+			virt-ldo1 {
+				compatible = "regulator-virtual";
+				virtual-supply = "ldo1";
+			};
+			virt-ldo2 {
+				compatible = "regulator-virtual";
+				virtual-supply = "ldo2";
+			};
+			virt-ldo3 {
+				compatible = "regulator-virtual";
+				virtual-supply = "ldo3";
+			};
+			virt-ldo4 {
+				compatible = "regulator-virtual";
+				virtual-supply = "ldo4";
+			};
+			virt-ldo5 {
+				compatible = "regulator-virtual";
+				virtual-supply = "ldo5";
+			};
+			user-dvref {
+				compatible = "userspace_consumer";
+				uc-name = "dvref";
+				suck-supply = "dvref";
+			};
+			user-lpsr {
+				compatible = "userspace_consumer";
+				uc-name = "lpsr";
+				suck-supply = "lpsr";
+			};
+
+			virt-wled {
+				compatible = "regulator-virtual";
+				virtual-supply = "wled";
+			};
+		};
+	};
+
+        ov5647_mipi: ov5647_mipi@36 {
+                compatible = "ovti,ov5647_mipi";
+                reg = <0x36>;
+                clocks = <&clks IMX7D_CLK_DUMMY>;
+                clock-names = "csi_mclk";
+                csi_id = <0>;
+                pinctrl-names = "default";
+                pinctrl-0 = <&pinctrl_ov5647>;
+                pwn-gpios = <&gpio4 15 GPIO_ACTIVE_HIGH>;
+                rst-gpios = <&gpio4 14 GPIO_ACTIVE_HIGH>;
+                mclk = <24000000>;
+                mclk_source = <0>;
+                port {
+                        ov5647_mipi_ep: endpoint {
+                                remote-endpoint = <&mipi_sensor_ep>;
+                        };
+                };
+        };
+
+        codec: wm8731@1a {
+                compatible = "wlf,wm8731";
+                reg = <0x1a>;
+                clocks = <&clks IMX7D_AUDIO_MCLK_ROOT_CLK>;
+        };
+
+        ar1021: ar1021@4d {
+                compatible = "microchip,ar1021-i2c";
+                reg = <0x4d>;
+                pinctrl-names = "default";
+                pinctrl-0 = <&pinctrl_ar1021_int>;
+                interrupt-parent = <&gpio5>;
+                interrupts = <9 IRQ_TYPE_EDGE_FALLING>;
+                ar1021,swap_xy;
+                ar1021,invert_x;
+                #ar1021,invert_y;
+        };
+
+        egalax: egalax_ts_lvds0@04 {
+                compatible = "eeti,egalax_ts";
+                reg = <0x04>;
+                pinctrl-names = "default";
+                pinctrl-0 = <&pinctrl_lvds0>;
+                interrupt-parent = <&gpio2>;
+                interrupts = <26 IRQ_TYPE_EDGE_FALLING>;
+                wakeup-gpios = <&gpio2 26 GPIO_ACTIVE_HIGH>;
+                status = "disabled";
+        };
+
+};
+
+&i2c2 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2>;
+	status = "okay";
+};
+
+&i2c3 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3>;
+	status = "okay";
+
+};
+
+&i2c4 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c4>;
+	status = "disabled";
+
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog_1>;
+
+	imx7d-sdb {
+		pinctrl_hog_1: hoggrp-1 {
+			fsl,pins = <
+				MX7D_PAD_UART3_CTS_B__GPIO4_IO7	0x14
+				MX7D_PAD_ECSPI2_SS0__GPIO4_IO23	 0x80000000  /* bt reg on */
+				MX7D_PAD_GPIO1_IO08__SD1_VSELECT	0x59 /* VSELECT */
+				MX7D_PAD_SD1_CD_B__GPIO5_IO0		0x59 /* CD */
+				MX7D_PAD_SD1_RESET_B__GPIO5_IO2		0x59 /* vmmc */
+			>;
+		};
+
+		pinctrl_ar1021_int: ar1021_intgrp {
+			fsl,pins = <
+				MX7D_PAD_SD2_CD_B__GPIO5_IO9          0x1f0b0
+ 			>;
+		};
+
+                pinctrl_lvds0: lvds0_intgrp {
+                        fsl,pins = <
+                                MX7D_PAD_EPDC_GDRL__GPIO2_IO26          0x1f0b0
+                        >;
+                };
+
+
+		pinctrl_ov5647: ov5647grp-1 {
+			fsl,pins = <
+				MX7D_PAD_I2C4_SCL__GPIO4_IO14           0x39
+				MX7D_PAD_I2C4_SDA__GPIO4_IO15           0x39
+			>;
+		};
+
+                pinctrl_epdc0: epdcgrp0 {
+                        fsl,pins = <
+				MX7D_PAD_EPDC_DATA00__EPDC_DATA0  0x2
+				MX7D_PAD_EPDC_DATA01__EPDC_DATA1  0x2
+				MX7D_PAD_EPDC_DATA02__EPDC_DATA2  0x2
+				MX7D_PAD_EPDC_DATA03__EPDC_DATA3  0x2
+				MX7D_PAD_EPDC_DATA04__EPDC_DATA4  0x2
+				MX7D_PAD_EPDC_DATA05__EPDC_DATA5  0x2
+				MX7D_PAD_EPDC_DATA06__EPDC_DATA6  0x2
+				MX7D_PAD_EPDC_DATA07__EPDC_DATA7  0x2
+				MX7D_PAD_EPDC_DATA08__EPDC_DATA8  0x2
+				MX7D_PAD_EPDC_DATA09__EPDC_DATA9  0x2
+				MX7D_PAD_EPDC_DATA10__EPDC_DATA10 0x2
+				MX7D_PAD_EPDC_DATA11__EPDC_DATA11 0x2
+				MX7D_PAD_EPDC_DATA12__EPDC_DATA12 0x2
+				MX7D_PAD_EPDC_DATA13__EPDC_DATA13 0x2
+				MX7D_PAD_EPDC_DATA14__EPDC_DATA14 0x2
+				MX7D_PAD_EPDC_DATA15__EPDC_DATA15 0x2
+				MX7D_PAD_EPDC_SDCLK__EPDC_SDCLK   0x2
+				MX7D_PAD_EPDC_SDLE__EPDC_SDLE     0x2
+				MX7D_PAD_EPDC_SDOE__EPDC_SDOE     0x2
+				MX7D_PAD_EPDC_SDSHR__EPDC_SDSHR   0x2
+				MX7D_PAD_EPDC_SDCE0__EPDC_SDCE0   0x2
+				MX7D_PAD_EPDC_SDCE1__EPDC_SDCE1   0x2
+				MX7D_PAD_EPDC_GDCLK__EPDC_GDCLK   0x2
+				MX7D_PAD_EPDC_GDOE__EPDC_GDOE     0x2
+				MX7D_PAD_EPDC_GDRL__EPDC_GDRL     0x2
+				MX7D_PAD_EPDC_GDSP__EPDC_GDSP     0x2
+				MX7D_PAD_EPDC_BDR0__EPDC_BDR0     0x2
+				MX7D_PAD_EPDC_BDR1__EPDC_BDR1     0x2
+                        >;
+                };
+
+		pinctrl_enet1: enet1grp {
+			fsl,pins = <
+				MX7D_PAD_GPIO1_IO10__ENET1_MDIO		0x3
+				MX7D_PAD_GPIO1_IO11__ENET1_MDC		0x3
+				MX7D_PAD_ENET1_RGMII_TXC__ENET1_RGMII_TXC	0x1
+				MX7D_PAD_ENET1_RGMII_TD0__ENET1_RGMII_TD0	0x1
+				MX7D_PAD_ENET1_RGMII_TD1__ENET1_RGMII_TD1	0x1
+				MX7D_PAD_ENET1_RGMII_TD2__ENET1_RGMII_TD2	0x1
+				MX7D_PAD_ENET1_RGMII_TD3__ENET1_RGMII_TD3	0x1
+				MX7D_PAD_ENET1_RGMII_TX_CTL__ENET1_RGMII_TX_CTL	0x1
+				MX7D_PAD_ENET1_RGMII_RXC__ENET1_RGMII_RXC	0x1
+				MX7D_PAD_ENET1_RGMII_RD0__ENET1_RGMII_RD0	0x1
+				MX7D_PAD_ENET1_RGMII_RD1__ENET1_RGMII_RD1	0x1
+				MX7D_PAD_ENET1_RGMII_RD2__ENET1_RGMII_RD2	0x1
+				MX7D_PAD_ENET1_RGMII_RD3__ENET1_RGMII_RD3	0x1
+				MX7D_PAD_ENET1_RGMII_RX_CTL__ENET1_RGMII_RX_CTL	0x1
+				MX7D_PAD_ENET1_COL__GPIO7_IO15                  0x1
+				MX7D_PAD_ENET1_RX_CLK__GPIO7_IO13               0x1
+			>;
+		};
+
+		pinctrl_ecspi3_cs: ecspi3_cs_grp {
+			fsl,pins = <
+				MX7D_PAD_SD2_CD_B__GPIO5_IO9	0x80000000
+			>;
+		};
+
+		pinctrl_ecspi3: ecspi3grp {
+			fsl,pins = <
+				MX7D_PAD_SAI2_TX_SYNC__ECSPI3_MISO	0x2
+				MX7D_PAD_SAI2_TX_BCLK__ECSPI3_MOSI	0x2
+				MX7D_PAD_SAI2_RX_DATA__ECSPI3_SCLK	0x2
+			>;
+		};
+
+		pinctrl_flexcan2: flexcan2grp {
+			fsl,pins = <
+				MX7D_PAD_GPIO1_IO14__FLEXCAN2_RX	0x59
+				MX7D_PAD_GPIO1_IO15__FLEXCAN2_TX	0x59
+			>;
+		};
+
+		pinctrl_i2c1: i2c1grp {
+			fsl,pins = <
+				MX7D_PAD_I2C1_SDA__I2C1_SDA	0x4000007f
+				MX7D_PAD_I2C1_SCL__I2C1_SCL	0x4000007f
+			>;
+		};
+
+		pinctrl_i2c2: i2c2grp {
+			fsl,pins = <
+				MX7D_PAD_I2C2_SDA__I2C2_SDA	0x4000007f
+				MX7D_PAD_I2C2_SCL__I2C2_SCL	0x4000007f
+			>;
+		};
+
+		pinctrl_i2c3: i2c3grp {
+			fsl,pins = <
+				MX7D_PAD_I2C3_SDA__I2C3_SDA          0x4000007f
+				MX7D_PAD_I2C3_SCL__I2C3_SCL          0x4000007f
+			>;
+		};
+
+		pinctrl_i2c4: i2c4grp {
+			fsl,pins = <
+				MX7D_PAD_SAI1_RX_BCLK__I2C4_SDA		0x4000007f
+				MX7D_PAD_SAI1_RX_SYNC__I2C4_SCL		0x4000007f
+			>;
+		};
+
+		pinctrl_lcdif_dat: lcdifdatgrp {
+			fsl,pins = <
+				MX7D_PAD_LCD_DATA00__LCD_DATA0	0x79
+				MX7D_PAD_LCD_DATA01__LCD_DATA1	0x79
+				MX7D_PAD_LCD_DATA02__LCD_DATA2	0x79
+				MX7D_PAD_LCD_DATA03__LCD_DATA3	0x79
+				MX7D_PAD_LCD_DATA04__LCD_DATA4	0x79
+				MX7D_PAD_LCD_DATA05__LCD_DATA5	0x79
+				MX7D_PAD_LCD_DATA06__LCD_DATA6	0x79
+				MX7D_PAD_LCD_DATA07__LCD_DATA7	0x79
+				MX7D_PAD_LCD_DATA08__LCD_DATA8	0x79
+				MX7D_PAD_LCD_DATA09__LCD_DATA9	0x79
+				MX7D_PAD_LCD_DATA10__LCD_DATA10	0x79
+				MX7D_PAD_LCD_DATA11__LCD_DATA11	0x79
+				MX7D_PAD_LCD_DATA12__LCD_DATA12	0x79
+				MX7D_PAD_LCD_DATA13__LCD_DATA13	0x79
+				MX7D_PAD_LCD_DATA14__LCD_DATA14	0x79
+				MX7D_PAD_LCD_DATA15__LCD_DATA15	0x79
+				MX7D_PAD_LCD_DATA16__LCD_DATA16	0x79
+				MX7D_PAD_LCD_DATA17__LCD_DATA17	0x79
+				MX7D_PAD_LCD_DATA18__LCD_DATA18	0x79
+				MX7D_PAD_LCD_DATA19__LCD_DATA19	0x79
+				MX7D_PAD_LCD_DATA20__LCD_DATA20	0x79
+				MX7D_PAD_LCD_DATA21__LCD_DATA21	0x79
+				MX7D_PAD_LCD_DATA22__LCD_DATA22	0x79
+				MX7D_PAD_LCD_DATA23__LCD_DATA23	0x79
+			>;
+		};
+
+		pinctrl_lcdif_ctrl: lcdifctrlgrp {
+			fsl,pins = <
+				MX7D_PAD_LCD_CLK__LCD_CLK	0x79
+				MX7D_PAD_LCD_ENABLE__LCD_ENABLE	0x79
+				MX7D_PAD_LCD_VSYNC__LCD_VSYNC	0x79
+				MX7D_PAD_LCD_HSYNC__LCD_HSYNC	0x79
+				MX7D_PAD_LCD_RESET__LCD_RESET	0x79
+				MX7D_PAD_EPDC_GDCLK__GPIO2_IO24 0x79
+				MX7D_PAD_EPDC_GDOE__GPIO2_IO25  0x79
+			>;
+		};
+
+		pinctrl_uart1: uart1grp {
+			fsl,pins = <
+				MX7D_PAD_UART1_TX_DATA__UART1_DCE_TX 0x79
+				MX7D_PAD_UART1_RX_DATA__UART1_DCE_RX 0x79
+			>;
+		};
+
+
+		pinctrl_usdhc1: usdhc1grp {
+			fsl,pins = <
+				MX7D_PAD_SD1_CMD__SD1_CMD	0x59
+				MX7D_PAD_SD1_CLK__SD1_CLK	0x19
+				MX7D_PAD_SD1_DATA0__SD1_DATA0	0x59
+				MX7D_PAD_SD1_DATA1__SD1_DATA1	0x59
+				MX7D_PAD_SD1_DATA2__SD1_DATA2	0x59
+				MX7D_PAD_SD1_DATA3__SD1_DATA3	0x59
+			>;
+		};
+
+		pinctrl_usdhc1_100mhz: usdhc1grp_100mhz {
+			fsl,pins = <
+				MX7D_PAD_SD1_CMD__SD1_CMD	0x5a
+				MX7D_PAD_SD1_CLK__SD1_CLK	0x1a
+				MX7D_PAD_SD1_DATA0__SD1_DATA0	0x5a
+				MX7D_PAD_SD1_DATA1__SD1_DATA1	0x5a
+				MX7D_PAD_SD1_DATA2__SD1_DATA2	0x5a
+				MX7D_PAD_SD1_DATA3__SD1_DATA3	0x5a
+			>;
+		};
+
+		pinctrl_usdhc1_200mhz: usdhc1grp_200mhz {
+			fsl,pins = <
+				MX7D_PAD_SD1_CMD__SD1_CMD	0x5b
+				MX7D_PAD_SD1_CLK__SD1_CLK	0x1b
+				MX7D_PAD_SD1_DATA0__SD1_DATA0	0x5b
+				MX7D_PAD_SD1_DATA1__SD1_DATA1	0x5b
+				MX7D_PAD_SD1_DATA2__SD1_DATA2	0x5b
+				MX7D_PAD_SD1_DATA3__SD1_DATA3	0x5b
+			>;
+		};
+
+		pinctrl_usdhc2: usdhc2grp {
+			fsl,pins = <
+				MX7D_PAD_SD2_CMD__SD2_CMD       0x59
+				MX7D_PAD_SD2_CLK__SD2_CLK       0x19
+				MX7D_PAD_SD2_DATA0__SD2_DATA0   0x59
+				MX7D_PAD_SD2_DATA1__SD2_DATA1   0x59
+				MX7D_PAD_SD2_DATA2__SD2_DATA2   0x59
+				MX7D_PAD_SD2_DATA3__SD2_DATA3   0x59
+				MX7D_PAD_ECSPI2_MOSI__GPIO4_IO21	0x59 /* WL_REG_ON */
+			>;
+		};
+
+		pinctrl_usdhc2_100mhz: usdhc2grp_100mhz {
+			fsl,pins = <
+				MX7D_PAD_SD2_CMD__SD2_CMD       0x5a
+				MX7D_PAD_SD2_CLK__SD2_CLK       0x1a
+				MX7D_PAD_SD2_DATA0__SD2_DATA0   0x5a
+				MX7D_PAD_SD2_DATA1__SD2_DATA1   0x5a
+				MX7D_PAD_SD2_DATA2__SD2_DATA2   0x5a
+				MX7D_PAD_SD2_DATA3__SD2_DATA3   0x5a
+			>;
+		};
+
+		pinctrl_usdhc2_200mhz: usdhc2grp_200mhz {
+			fsl,pins = <
+				MX7D_PAD_SD2_CMD__SD2_CMD       0x5b
+				MX7D_PAD_SD2_CLK__SD2_CLK       0x1b
+				MX7D_PAD_SD2_DATA0__SD2_DATA0   0x5b
+				MX7D_PAD_SD2_DATA1__SD2_DATA1   0x5b
+				MX7D_PAD_SD2_DATA2__SD2_DATA2   0x5b
+				MX7D_PAD_SD2_DATA3__SD2_DATA3   0x5b
+			>;
+		};
+
+		pinctrl_usdhc3: usdhc3grp {
+			fsl,pins = <
+				MX7D_PAD_SD3_CMD__SD3_CMD	0x59
+				MX7D_PAD_SD3_CLK__SD3_CLK	0x19
+				MX7D_PAD_SD3_DATA0__SD3_DATA0	0x59
+				MX7D_PAD_SD3_DATA1__SD3_DATA1	0x59
+				MX7D_PAD_SD3_DATA2__SD3_DATA2	0x59
+				MX7D_PAD_SD3_DATA3__SD3_DATA3	0x59
+				MX7D_PAD_SD3_DATA4__SD3_DATA4	0x59
+				MX7D_PAD_SD3_DATA5__SD3_DATA5	0x59
+				MX7D_PAD_SD3_DATA6__SD3_DATA6	0x59
+				MX7D_PAD_SD3_DATA7__SD3_DATA7	0x59
+				MX7D_PAD_SD3_STROBE__SD3_STROBE	0x19
+				MX7D_PAD_SD3_RESET_B__SD3_RESET 0x59
+			>;
+		};
+
+		pinctrl_usdhc3_100mhz: usdhc3grp_100mhz {
+			fsl,pins = <
+				MX7D_PAD_SD3_CMD__SD3_CMD	0x5a
+				MX7D_PAD_SD3_CLK__SD3_CLK	0x1a
+				MX7D_PAD_SD3_DATA0__SD3_DATA0	0x5a
+				MX7D_PAD_SD3_DATA1__SD3_DATA1	0x5a
+				MX7D_PAD_SD3_DATA2__SD3_DATA2	0x5a
+				MX7D_PAD_SD3_DATA3__SD3_DATA3	0x5a
+				MX7D_PAD_SD3_DATA4__SD3_DATA4	0x5a
+				MX7D_PAD_SD3_DATA5__SD3_DATA5	0x5a
+				MX7D_PAD_SD3_DATA6__SD3_DATA6	0x5a
+				MX7D_PAD_SD3_DATA7__SD3_DATA7	0x5a
+				MX7D_PAD_SD3_STROBE__SD3_STROBE	0x1a
+				MX7D_PAD_SD3_RESET_B__SD3_RESET 0x59
+			>;
+		};
+
+		pinctrl_usdhc3_200mhz: usdhc3grp_200mhz {
+			fsl,pins = <
+				MX7D_PAD_SD3_CMD__SD3_CMD	0x5b
+				MX7D_PAD_SD3_CLK__SD3_CLK	0x1b
+				MX7D_PAD_SD3_DATA0__SD3_DATA0	0x5b
+				MX7D_PAD_SD3_DATA1__SD3_DATA1	0x5b
+				MX7D_PAD_SD3_DATA2__SD3_DATA2	0x5b
+				MX7D_PAD_SD3_DATA3__SD3_DATA3	0x5b
+				MX7D_PAD_SD3_DATA4__SD3_DATA4	0x5b
+				MX7D_PAD_SD3_DATA5__SD3_DATA5	0x5b
+				MX7D_PAD_SD3_DATA6__SD3_DATA6	0x5b
+				MX7D_PAD_SD3_DATA7__SD3_DATA7	0x5b
+				MX7D_PAD_SD3_STROBE__SD3_STROBE	0x1b
+				MX7D_PAD_SD3_RESET_B__SD3_RESET 0x59
+			>;
+		};
+
+                pinctrl_sai1: sai1grp {
+                        fsl,pins = <
+                                MX7D_PAD_SAI1_MCLK__SAI1_MCLK           0x1f
+				MX7D_PAD_SAI1_TX_BCLK__SAI1_TX_BCLK     0x1f
+				MX7D_PAD_SAI1_TX_SYNC__SAI1_TX_SYNC     0x1f
+				MX7D_PAD_SAI1_TX_DATA__SAI1_TX_DATA0    0x30
+				MX7D_PAD_SAI1_RX_DATA__SAI1_RX_DATA0    0x1f
+                        >;
+                };
+
+
+		pinctrl_spi1: spi1grp {
+			fsl,pins = <
+				MX7D_PAD_GPIO1_IO09__GPIO1_IO9	0x59
+				MX7D_PAD_GPIO1_IO12__GPIO1_IO12	0x59
+				MX7D_PAD_GPIO1_IO13__GPIO1_IO13	0x59
+			>;
+		};
+
+	};
+};
+
+&iomuxc_lpsr {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog_2>;
+
+	imx7d-sdb {
+		pinctrl_hog_2: hoggrp-2 {
+			fsl,pins = <
+				MX7D_PAD_GPIO1_IO05__GPIO1_IO5	0x14
+				MX7D_PAD_EPDC_DATA14__GPIO2_IO14 0x59  /* CAN_STBY */
+				MX7D_PAD_GPIO1_IO00__WDOD1_WDOG_B 0x74
+			>;
+		};
+
+		pinctrl_pwm1: pwm1grp {
+			fsl,pins = <
+				MX7D_PAD_GPIO1_IO01__PWM1_OUT	0x110b0
+			>;
+		};
+
+                pinctrl_pwm3: pwm3grp {
+                        fsl,pins = <
+                                MX7D_PAD_GPIO1_IO03__PWM3_OUT   0x110b0
+                        >;
+                };
+
+	};
+};
+
+&lcdif {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_lcdif_dat
+		     &pinctrl_lcdif_ctrl>;
+	pinctrl-assert-gpios = <&gpio2 25 GPIO_ACTIVE_HIGH>;
+	display = <&display0>;
+	status = "okay";
+
+	display0: display {
+		bits-per-pixel = <24>;
+		bus-width = <24>;
+
+                display-timings {
+                        native-mode = <&timing0>;
+
+                        timing0: timing0 {
+                                clock-frequency = <33500000>;
+                                hactive = <800>;
+                                vactive = <480>;
+                                hback-porch = <89>;
+                                hfront-porch = <164>;
+                                vback-porch = <75>;
+                                vfront-porch = <75>;
+                                hsync-len = <10>;
+                                vsync-len = <10>;
+                                hsync-active = <0>;
+                                vsync-active = <0>;
+                                de-active = <1>;
+                                pixelclk-active = <1>;
+                        };
+
+
+                };
+
+	};
+};
+
+&pcie {
+	pinctrl-names = "default";
+	reset-gpio = <&gpio2 21 GPIO_ACTIVE_LOW>;
+	disable-gpio = <&gpio2 22 GPIO_ACTIVE_LOW>;
+	status = "disabled";
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm1>;
+	status = "okay";
+};
+
+&pwm3 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_pwm3>;
+        status = "okay";
+};
+
+
+
+&sai1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai1>;
+	assigned-clocks = <&clks IMX7D_SAI1_ROOT_SRC>,
+			  <&clks IMX7D_SAI1_ROOT_CLK>;
+	assigned-clock-parents = <&clks IMX7D_PLL_AUDIO_POST_DIV>;
+	assigned-clock-rates = <0>, <11289600>;
+	status = "okay";
+};
+
+
+&sdma {
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	assigned-clocks = <&clks IMX7D_UART1_ROOT_SRC>;
+	assigned-clock-parents = <&clks IMX7D_OSC_24M_CLK>;
+	status = "okay";
+};
+
+&usbotg1 {
+	vbus-supply = <&reg_usb_otg1_vbus>;
+	srp-disable;
+	hnp-disable;
+	adp-disable;
+	status = "okay";
+};
+
+&usbotg2 {
+	vbus-supply = <&reg_usb_otg2_vbus>;
+	dr_mode = "host";
+	status = "okay";
+};
+
+
+&usdhc1 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc1>;
+	pinctrl-1 = <&pinctrl_usdhc1_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc1_200mhz>;
+	cd-gpios = <&gpio5 0 0>;
+	tuning-step = <2>;
+	vmmc-supply = <&reg_sd1_vmmc>;
+	enable-sdio-wakeup;
+	keep-power-in-suspend;
+	status = "okay";
+};
+/*
+&usdhc2 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc2>;
+	pinctrl-1 = <&pinctrl_usdhc2_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc2_200mhz>;
+	enable-sdio-wakeup;
+	keep-power-in-suspend;
+	tuning-step = <2>;
+	wifi-host;
+	status = "okay";
+};
+*/
+&usdhc3 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc3>;
+	pinctrl-1 = <&pinctrl_usdhc3_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc3_200mhz>;
+	assigned-clocks = <&clks IMX7D_USDHC3_ROOT_CLK>;
+	assigned-clock-rates = <100000000>;
+	bus-width = <8>;
+	tuning-step = <2>;
+	non-removable;
+	status = "okay";
+};
+
+
+
+
diff --git a/arch/arm/configs/imx6_ea_android_defconfig b/arch/arm/configs/imx6_ea_android_defconfig
new file mode 100644
index 0000000..35c76bb
--- /dev/null
+++ b/arch/arm/configs/imx6_ea_android_defconfig
@@ -0,0 +1,1120 @@
+CONFIG_KERNEL_LZO=y
+CONFIG_SYSVIPC=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_DEBUG=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_EMBEDDED=y
+CONFIG_PERF_EVENTS=y
+# CONFIG_SLUB_DEBUG is not set
+# CONFIG_COMPAT_BRK is not set
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_GPIO_PCA953X=y
+CONFIG_ARCH_MXC=y
+CONFIG_MACH_IMX51_DT=y
+CONFIG_MACH_EUKREA_CPUIMX51SD=y
+CONFIG_SOC_IMX50=y
+CONFIG_SOC_IMX53=y
+CONFIG_SOC_IMX6Q=y
+CONFIG_SOC_IMX6SL=y
+CONFIG_SOC_IMX6SX=y
+CONFIG_SOC_IMX6UL=y
+CONFIG_SOC_IMX7D=y
+CONFIG_SOC_VF610=y
+CONFIG_MXC_REBOOT_ANDROID_CMD=y
+CONFIG_MX6_RAMOOPS=y
+CONFIG_MACH_IMX_BLUETOOTH_RFKILL=y
+# CONFIG_SWP_EMULATE is not set
+CONFIG_SMP=y
+CONFIG_HAVE_ARM_ARCH_TIMER=y
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+CONFIG_HIGHMEM=y
+CONFIG_KSM=y
+CONFIG_CMA=y
+CONFIG_ZSMALLOC=y
+CONFIG_SECCOMP=y
+CONFIG_CMDLINE="noinitrd console=ttymxc0,115200"
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_ARM_IMX6Q_CPUFREQ=y
+CONFIG_ARM_IMX7D_CPUFREQ=y
+CONFIG_CPU_IDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_BINFMT_MISC=y
+CONFIG_PM_AUTOSLEEP=y
+CONFIG_PM_WAKELOCKS=y
+CONFIG_PM_WAKELOCKS_LIMIT=0
+# CONFIG_PM_WAKELOCKS_GC is not set
+CONFIG_PM_RUNTIME=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_TEST_SUSPEND=y
+CONFIG_SUSPEND_TIME=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_INET_ESP=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_TRACE=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_NF_NAT_IPV4=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_IP6_NF_IPTABLES=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+CONFIG_NF_NAT_IPV6=y
+CONFIG_IP6_NF_TARGET_MASQUERADE=y
+CONFIG_VLAN_8021Q=y
+CONFIG_LLC2=y
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_HTB=y
+CONFIG_NET_CLS_U32=y
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_U32=y
+CONFIG_NET_CLS_ACT=y
+CONFIG_CAN=y
+CONFIG_CAN_FLEXCAN=y
+CONFIG_CAN_M_CAN=y
+CONFIG_BT=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=y
+CONFIG_BT_HCIBTUSB=y
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+CONFIG_BT_HCIUART_BCSP=y
+CONFIG_BT_HCIUART_ATH3K=y
+CONFIG_BT_HCIBCM203X=y
+CONFIG_CFG80211=m
+CONFIG_CFG80211_WEXT=y
+CONFIG_MAC80211=m
+CONFIG_RFKILL=y
+CONFIG_RFKILL_INPUT=y
+CONFIG_RFKILL_GPIO=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+CONFIG_DMA_CMA=y
+CONFIG_CMA_SIZE_MBYTES=320
+CONFIG_IMX_WEIM=y
+CONFIG_CONNECTOR=y
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_PHYSMAP_OF=y
+CONFIG_MTD_DATAFLASH=y
+CONFIG_MTD_M25P80=y
+CONFIG_MTD_SST25L=y
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_GPMI_NAND=y
+CONFIG_MTD_NAND_MXC=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_SPI_FSL_QUADSPI=y
+CONFIG_MTD_UBI=y
+CONFIG_ZRAM=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_SENSORS_FXOS8700=y
+CONFIG_SENSORS_FXAS2100X=y
+CONFIG_UID_STAT=y
+CONFIG_EEPROM_AT24=y
+CONFIG_EEPROM_AT25=y
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+# CONFIG_SCSI_LOWLEVEL is not set
+CONFIG_ATA=y
+CONFIG_SATA_AHCI_PLATFORM=y
+CONFIG_AHCI_IMX=y
+CONFIG_PATA_IMX=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_CRYPT=y
+CONFIG_DM_UEVENT=y
+CONFIG_DM_VERITY=y
+CONFIG_NETDEVICES=y
+CONFIG_TUN=y
+# CONFIG_NET_VENDOR_BROADCOM is not set
+CONFIG_CS89x0=y
+CONFIG_CS89x0_PLATFORM=y
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+CONFIG_SMC91X=y
+CONFIG_SMC911X=y
+CONFIG_SMSC911X=y
+# CONFIG_NET_VENDOR_STMICRO is not set
+CONFIG_MICREL_PHY=y
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPPOE=y
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_USB_PEGASUS=y
+CONFIG_USB_RTL8150=y
+CONFIG_USB_RTL8152=y
+CONFIG_USB_USBNET=y
+CONFIG_USB_NET_CDC_EEM=y
+CONFIG_ATH_CARDS=m
+CONFIG_ATH6KL=m
+CONFIG_ATH6KL_SDIO=m
+CONFIG_BCMDHD=m
+CONFIG_BCMDHD_SDIO=y
+CONFIG_BCMDHD_FW_PATH="/system/etc/firmware/bcm/fw_bcmdhd.bin"
+CONFIG_BCMDHD_NVRAM_PATH="/system/etc/firmware/bcm/bcmdhd.cal"
+CONFIG_BRCMFMAC=m
+CONFIG_RTL8821AS=m
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_KEYRESET=y
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_KEYBOARD_SNVS_PWRKEY=y
+CONFIG_KEYBOARD_IMX=y
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_JOYSTICK=y
+CONFIG_JOYSTICK_XPAD=y
+CONFIG_JOYSTICK_XPAD_FF=y
+CONFIG_JOYSTICK_XPAD_LEDS=y
+CONFIG_INPUT_TABLET=y
+CONFIG_TABLET_USB_ACECAD=y
+CONFIG_TABLET_USB_AIPTEK=y
+CONFIG_TABLET_USB_GTCO=y
+CONFIG_TABLET_USB_HANWANG=y
+CONFIG_TABLET_USB_KBTAB=y
+CONFIG_TABLET_USB_WACOM=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ADS7846=y
+CONFIG_TOUCHSCREEN_EGALAX=y
+CONFIG_TOUCHSCREEN_ELAN=y
+CONFIG_TOUCHSCREEN_MAX11801=y
+CONFIG_TOUCHSCREEN_IMX6UL_TSC=y
+CONFIG_TOUCHSCREEN_MC13783=y
+CONFIG_TOUCHSCREEN_TSC2007=y
+CONFIG_TOUCHSCREEN_STMPE=y
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_MMA8450=y
+CONFIG_INPUT_KEYCHORD=y
+CONFIG_INPUT_UINPUT=y
+CONFIG_INPUT_GPIO=y
+CONFIG_INPUT_ISL29023=y
+CONFIG_INPUT_MPL3115=y
+CONFIG_SENSOR_FXLS8471=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_IMX=y
+CONFIG_SERIAL_IMX_CONSOLE=y
+CONFIG_SERIAL_FSL_LPUART=y
+CONFIG_SERIAL_FSL_LPUART_CONSOLE=y
+CONFIG_FSL_OTP=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_HELPER_AUTO is not set
+CONFIG_I2C_ALGOPCF=y
+CONFIG_I2C_ALGOPCA=y
+CONFIG_I2C_IMX=y
+CONFIG_SPI=y
+CONFIG_SPI_GPIO=y
+CONFIG_SPI_IMX=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_MAX732X=y
+CONFIG_GPIO_74X164=y
+CONFIG_SABRESD_MAX8903=y
+CONFIG_SENSORS_MAX17135=y
+CONFIG_SENSORS_MAG3110=y
+CONFIG_THERMAL=y
+CONFIG_CPU_THERMAL=y
+CONFIG_IMX_THERMAL=y
+CONFIG_DEVICE_THERMAL=y
+CONFIG_WATCHDOG=y
+CONFIG_IMX2_WDT=y
+CONFIG_MFD_DA9052_I2C=y
+CONFIG_MFD_MXC_HDMI_ANDROID=y
+CONFIG_MFD_MC13XXX_SPI=y
+CONFIG_MFD_MC13XXX_I2C=y
+CONFIG_MFD_MAX17135=y
+CONFIG_MFD_SI476X_CORE=y
+CONFIG_MFD_STMPE=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_ANATOP=y
+CONFIG_REGULATOR_DA9052=y
+CONFIG_REGULATOR_MAX17135=y
+CONFIG_REGULATOR_MC13783=y
+CONFIG_REGULATOR_MC13892=y
+CONFIG_REGULATOR_PFUZE100=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_RADIO_SUPPORT=y
+CONFIG_MEDIA_RC_SUPPORT=y
+CONFIG_RC_DEVICES=y
+CONFIG_IR_GPIO_CIR=y
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_USB_GSPCA=y
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_VIDEO_MXC_OUTPUT=y
+CONFIG_VIDEO_MXC_CAPTURE=y
+CONFIG_MXC_CAMERA_OV5640=y
+CONFIG_MXC_CAMERA_OV5642=y
+CONFIG_MXC_CAMERA_OV5640_MIPI=y
+CONFIG_MXC_TVIN_ADV7180=y
+CONFIG_MXC_IPU_DEVICE_QUEUE_SDC=y
+CONFIG_VIDEO_MXC_IPU_OUTPUT=y
+CONFIG_VIDEO_MXC_PXP_V4L2=y
+CONFIG_VIDEO_MXC_CSI_CAMERA=y
+CONFIG_MXC_VADC=y
+CONFIG_MXC_MIPI_CSI=y
+CONFIG_SOC_CAMERA=y
+CONFIG_VIDEO_MX3=y
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+CONFIG_VIDEO_CODA=y
+CONFIG_RADIO_SI476X=y
+CONFIG_SOC_CAMERA_OV2640=y
+CONFIG_DRM=y
+CONFIG_DRM_VIVANTE=y
+CONFIG_FB=y
+CONFIG_FB_MXS=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+CONFIG_LCD_L4F00242T03=y
+CONFIG_LCD_PLATFORM=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_FB_MXC_SYNC_PANEL=y
+CONFIG_FB_MXC_LDB=y
+CONFIG_FB_MXC_MIPI_DSI=y
+CONFIG_FB_MXC_TRULY_WVGA_SYNC_PANEL=y
+CONFIG_FB_MXC_HDMI=y
+CONFIG_FB_MXC_EINK_PANEL=y
+CONFIG_FB_MXC_EINK_V2_PANEL=y
+CONFIG_FB_MXS_SII902X=y
+CONFIG_FB_MXC_DCIC=y
+CONFIG_HANNSTAR_CABC=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+CONFIG_LOGO=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_USB_AUDIO=y
+CONFIG_SND_SOC=y
+CONFIG_SND_IMX_SOC=y
+CONFIG_SND_SOC_EUKREA_TLV320=y
+CONFIG_SND_SOC_IMX_CS42888=y
+CONFIG_SND_SOC_IMX_SII902X=y
+CONFIG_SND_SOC_IMX_WM8958=y
+CONFIG_SND_SOC_IMX_WM8960=y
+CONFIG_SND_SOC_IMX_WM8962=y
+CONFIG_SND_SOC_IMX_SGTL5000=y
+CONFIG_SND_SOC_IMX_MQS=y
+CONFIG_SND_SOC_IMX_SPDIF=y
+CONFIG_SND_SOC_IMX_MC13783=y
+CONFIG_SND_SOC_IMX_HDMI=y
+CONFIG_SND_SOC_IMX_SI476X=y
+CONFIG_HIDRAW=y
+CONFIG_UHID=y
+CONFIG_HID_A4TECH=y
+CONFIG_HID_ACRUX=y
+CONFIG_HID_ACRUX_FF=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_PRODIKEYS=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+CONFIG_DRAGONRISE_FF=y
+CONFIG_HID_EMS_FF=y
+CONFIG_HID_ELECOM=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_HOLTEK=y
+CONFIG_HID_KEYTOUCH=y
+CONFIG_HID_KYE=y
+CONFIG_HID_UCLOGIC=y
+CONFIG_HID_WALTOP=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_TWINHAN=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LCPOWER=y
+CONFIG_HID_LOGITECH=y
+CONFIG_HID_LOGITECH_DJ=y
+CONFIG_LOGITECH_FF=y
+CONFIG_LOGIRUMBLEPAD2_FF=y
+CONFIG_LOGIG940_FF=y
+CONFIG_HID_MAGICMOUSE=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_MULTITOUCH=y
+CONFIG_HID_NTRIG=y
+CONFIG_HID_ORTEK=y
+CONFIG_HID_PANTHERLORD=y
+CONFIG_PANTHERLORD_FF=y
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_PICOLCD=y
+CONFIG_HID_PRIMAX=y
+CONFIG_HID_ROCCAT=y
+CONFIG_HID_SAITEK=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SPEEDLINK=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+CONFIG_GREENASIA_FF=y
+CONFIG_HID_SMARTJOYPLUS=y
+CONFIG_SMARTJOYPLUS_FF=y
+CONFIG_HID_TIVO=y
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THRUSTMASTER=y
+CONFIG_HID_WACOM=y
+CONFIG_HID_WIIMOTE=y
+CONFIG_HID_ZEROPLUS=y
+CONFIG_HID_ZYDACRON=y
+CONFIG_USB_HIDDEV=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_OTG_FSM=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_MXC=y
+CONFIG_USB_ACM=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_CHIPIDEA=y
+CONFIG_USB_CHIPIDEA_UDC=y
+CONFIG_USB_CHIPIDEA_HOST=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_FTDI_SIO=y
+CONFIG_USB_SERIAL_OPTION=y
+CONFIG_USB_EHSET_TEST_FIXTURE=y
+CONFIG_USB_OTG_WAKELOCK=y
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_USB_MXS_PHY=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_G_ANDROID=y
+CONFIG_MMC=y
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_ESDHC_IMX=y
+CONFIG_MXC_IPU=y
+CONFIG_MXC_GPU_VIV=y
+CONFIG_GPU_LOW_MEMORY_KILLER=y
+CONFIG_MXC_IPU_V3_PRE=y
+CONFIG_MXC_MIPI_CSI2=y
+CONFIG_MXC_MLB150=y
+CONFIG_MXC_SIM=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_ONESHOT=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_BACKLIGHT=y
+CONFIG_LEDS_TRIGGER_GPIO=y
+CONFIG_SWITCH=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+CONFIG_RTC_DRV_MC13XXX=y
+CONFIG_RTC_DRV_MXC=y
+CONFIG_RTC_DRV_SNVS=y
+CONFIG_DMADEVICES=y
+CONFIG_MXC_PXP_V2=y
+CONFIG_MXC_PXP_V3=y
+CONFIG_IMX_SDMA=y
+CONFIG_MXS_DMA=y
+CONFIG_STAGING=y
+CONFIG_STAGING_MEDIA=y
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ASHMEM=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_ANDROID_INTF_ALARM_DEV=y
+CONFIG_SYNC=y
+CONFIG_ION=y
+CONFIG_ION_MXC=y
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_IIO=y
+CONFIG_VF610_ADC=y
+CONFIG_AD2802A=y
+CONFIG_PWM=y
+CONFIG_PWM_IMX=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_NTFS_FS=y
+CONFIG_NTFS_DEBUG=y
+CONFIG_NTFS_RW=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_JFFS2_FS=y
+CONFIG_UBIFS_FS=y
+CONFIG_PSTORE=y
+CONFIG_PSTORE_CONSOLE=y
+CONFIG_PSTORE_RAM=y
+CONFIG_F2FS_FS=y
+CONFIG_F2FS_FS_SECURITY=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_ROOT_NFS=y
+CONFIG_NLS_DEFAULT="cp437"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_15=y
+CONFIG_NLS_UTF8=y
+CONFIG_DEBUG_FS=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_PANIC_TIMEOUT=5
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_FTRACE is not set
+CONFIG_CORESIGHT=y
+CONFIG_CORESIGHT_LINK_AND_SINK_TMC=y
+CONFIG_CORESIGHT_SINK_TPIU=y
+CONFIG_CORESIGHT_SINK_ETBV10=y
+CONFIG_CORESIGHT_SOURCE_ETM3X=y
+CONFIG_SECURITY=y
+CONFIG_SECURITY_SELINUX=y
+CONFIG_SECURITY_APPARMOR=y
+CONFIG_CRYPTO_USER=y
+CONFIG_CRYPTO_TEST=m
+CONFIG_CRYPTO_CCM=y
+CONFIG_CRYPTO_GCM=y
+CONFIG_CRYPTO_CTS=y
+CONFIG_CRYPTO_LRW=y
+CONFIG_CRYPTO_XTS=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_RMD128=y
+CONFIG_CRYPTO_RMD160=y
+CONFIG_CRYPTO_RMD256=y
+CONFIG_CRYPTO_RMD320=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_TGR192=y
+CONFIG_CRYPTO_WP512=y
+CONFIG_CRYPTO_BLOWFISH=y
+CONFIG_CRYPTO_CAMELLIA=y
+CONFIG_CRYPTO_TWOFISH=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_DEV_FSL_CAAM=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM_TEST=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SECVIO=y
+CONFIG_CRC_T10DIF=y
+CONFIG_CRC7=y
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+
+
+
+
+CONFIG_PCI_QUIRKS=y
+CONFIG_PCI=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_PCI_SYSCALL=y
+# CONFIG_PCI_MSI is not set
+# CONFIG_PCI_DEBUG is not set
+# CONFIG_PCI_REALLOC_ENABLE_AUTO is not set
+# CONFIG_PCI_STUB is not set
+# CONFIG_PCI_IOV is not set
+# CONFIG_PCI_PRI is not set
+# CONFIG_PCI_PASID is not set
+
+#
+# PCI host controller drivers
+#
+CONFIG_PCIE_DW=y
+CONFIG_PCI_IMX6=y
+# CONFIG_PCI_IMX6SX_EXTREMELY_PWR_SAVE is not set
+# CONFIG_EP_MODE_IN_EP_RC_SYS is not set
+# CONFIG_RC_MODE_IN_EP_RC_SYS is not set
+# CONFIG_PCI_HOST_GENERIC is not set
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCIEAER=y
+# CONFIG_PCIE_ECRC is not set
+# CONFIG_PCIEAER_INJECT is not set
+CONFIG_PCIEASPM=y
+# CONFIG_PCIEASPM_DEBUG is not set
+CONFIG_PCIEASPM_DEFAULT=y
+# CONFIG_PCIEASPM_POWERSAVE is not set
+# CONFIG_PCIEASPM_PERFORMANCE is not set
+CONFIG_PCIE_PME=y
+# CONFIG_PCH_CAN is not set
+CONFIG_MAC80211_LEDS=y
+# CONFIG_MTD_INTEL_VR_NOR is not set
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_NAND_RICOH is not set
+# CONFIG_MTD_NAND_CAFE is not set
+CONFIG_OF_PCI=y
+CONFIG_OF_PCI_IRQ=y
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_NVME is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_RSXX is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_PCH_PHUB is not set
+# CONFIG_CB710_CORE is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+# CONFIG_SATA_AHCI is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_SATA_ACARD_AHCI is not set
+# CONFIG_SATA_SIL24 is not set
+# CONFIG_PDC_ADMA is not set
+# CONFIG_SATA_QSTOR is not set
+# CONFIG_SATA_SX4 is not set
+# CONFIG_ATA_PIIX is not set
+# CONFIG_SATA_NV is not set
+# CONFIG_SATA_PROMISE is not set
+# CONFIG_SATA_SIL is not set
+# CONFIG_SATA_SIS is not set
+# CONFIG_SATA_SVW is not set
+# CONFIG_SATA_ULI is not set
+# CONFIG_SATA_VIA is not set
+# CONFIG_SATA_VITESSE is not set
+# CONFIG_PATA_ALI is not set
+# CONFIG_PATA_AMD is not set
+# CONFIG_PATA_ARTOP is not set
+# CONFIG_PATA_ATIIXP is not set
+# CONFIG_PATA_ATP867X is not set
+# CONFIG_PATA_CMD64X is not set
+# CONFIG_PATA_CYPRESS is not set
+# CONFIG_PATA_EFAR is not set
+# CONFIG_PATA_HPT366 is not set
+# CONFIG_PATA_HPT37X is not set
+# CONFIG_PATA_HPT3X2N is not set
+# CONFIG_PATA_HPT3X3 is not set
+# CONFIG_PATA_IT8213 is not set
+# CONFIG_PATA_IT821X is not set
+# CONFIG_PATA_JMICRON is not set
+# CONFIG_PATA_MARVELL is not set
+# CONFIG_PATA_NETCELL is not set
+# CONFIG_PATA_NINJA32 is not set
+# CONFIG_PATA_NS87415 is not set
+# CONFIG_PATA_OLDPIIX is not set
+# CONFIG_PATA_OPTIDMA is not set
+# CONFIG_PATA_PDC2027X is not set
+# CONFIG_PATA_PDC_OLD is not set
+# CONFIG_PATA_RADISYS is not set
+# CONFIG_PATA_RDC is not set
+# CONFIG_PATA_SCH is not set
+# CONFIG_PATA_SERVERWORKS is not set
+# CONFIG_PATA_SIL680 is not set
+# CONFIG_PATA_SIS is not set
+# CONFIG_PATA_TOSHIBA is not set
+# CONFIG_PATA_TRIFLEX is not set
+# CONFIG_PATA_VIA is not set
+# CONFIG_PATA_WINBOND is not set
+# CONFIG_PATA_CMD640_PCI is not set
+# CONFIG_PATA_MPIIX is not set
+# CONFIG_PATA_NS87410 is not set
+# CONFIG_PATA_OPTI is not set
+# CONFIG_PATA_RZ1000 is not set
+# CONFIG_ATA_GENERIC is not set
+# CONFIG_PATA_LEGACY is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_I2O is not set
+# CONFIG_NET_FC is not set
+# CONFIG_ARCNET is not set
+CONFIG_NET_VENDOR_3COM=y
+# CONFIG_VORTEX is not set
+# CONFIG_TYPHOON is not set
+CONFIG_NET_VENDOR_ADAPTEC=y
+# CONFIG_ADAPTEC_STARFIRE is not set
+CONFIG_NET_VENDOR_ALTEON=y
+# CONFIG_ACENIC is not set
+CONFIG_NET_VENDOR_AMD=y
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_PCNET32 is not set
+CONFIG_NET_VENDOR_ATHEROS=y
+# CONFIG_ATL2 is not set
+# CONFIG_ATL1 is not set
+# CONFIG_ATL1E is not set
+# CONFIG_ATL1C is not set
+# CONFIG_ALX is not set
+CONFIG_NET_VENDOR_BROCADE=y
+# CONFIG_BNA is not set
+CONFIG_NET_VENDOR_CHELSIO=y
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_CHELSIO_T3 is not set
+# CONFIG_CHELSIO_T4 is not set
+# CONFIG_CHELSIO_T4VF is not set
+CONFIG_NET_VENDOR_CISCO=y
+# CONFIG_ENIC is not set
+CONFIG_NET_VENDOR_DEC=y
+# CONFIG_NET_TULIP is not set
+CONFIG_NET_VENDOR_DLINK=y
+# CONFIG_DL2K is not set
+# CONFIG_SUNDANCE is not set
+CONFIG_NET_VENDOR_EMULEX=y
+# CONFIG_BE2NET is not set
+CONFIG_NET_VENDOR_EXAR=y
+# CONFIG_S2IO is not set
+# CONFIG_VXGE is not set
+CONFIG_NET_VENDOR_HP=y
+# CONFIG_HP100 is not set
+# CONFIG_IP1000 is not set
+# CONFIG_JME is not set
+CONFIG_NET_VENDOR_MELLANOX=y
+# CONFIG_MLX4_EN is not set
+# CONFIG_MLX4_CORE is not set
+# CONFIG_MLX5_CORE is not set
+CONFIG_NET_VENDOR_MYRI=y
+# CONFIG_MYRI10GE is not set
+# CONFIG_FEALNX is not set
+CONFIG_NET_VENDOR_NVIDIA=y
+# CONFIG_FORCEDETH is not set
+CONFIG_NET_VENDOR_OKI=y
+CONFIG_NET_PACKET_ENGINE=y
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+CONFIG_NET_VENDOR_QLOGIC=y
+# CONFIG_QLA3XXX is not set
+# CONFIG_QLCNIC is not set
+# CONFIG_QLGE is not set
+# CONFIG_NETXEN_NIC is not set
+CONFIG_NET_VENDOR_REALTEK=y
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_R8169 is not set
+CONFIG_NET_VENDOR_RDC=y
+# CONFIG_R6040 is not set
+CONFIG_NET_VENDOR_SILAN=y
+# CONFIG_SC92031 is not set
+CONFIG_NET_VENDOR_SIS=y
+# CONFIG_SIS900 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SFC is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SMSC9420 is not set
+CONFIG_NET_VENDOR_SUN=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NIU is not set
+CONFIG_NET_VENDOR_TEHUTI=y
+# CONFIG_TEHUTI is not set
+CONFIG_NET_VENDOR_TI=y
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_ATMEL is not set
+# CONFIG_PRISM54 is not set
+# CONFIG_RTL8180 is not set
+# CONFIG_ADM8211 is not set
+# CONFIG_MWL8K is not set
+# CONFIG_ATH5K is not set
+# CONFIG_ATH5K_PCI is not set
+# CONFIG_WIL6210 is not set
+# CONFIG_IPW2100 is not set
+CONFIG_IWLWIFI=m
+CONFIG_IWLDVM=m
+# CONFIG_IWLMVM is not set
+CONFIG_IWLWIFI_OPMODE_MODULAR=y
+
+#
+# Debugging Options
+#
+# CONFIG_IWLWIFI_DEBUG is not set
+# CONFIG_IWL4965 is not set
+# CONFIG_IWL3945 is not set
+# CONFIG_RTL8192CE is not set
+# CONFIG_RTL8192SE is not set
+# CONFIG_RTL8192DE is not set
+# CONFIG_RTL8723AE is not set
+# CONFIG_RTL8188EE is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_SERIAL_MFD_HSU is not set
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_PCH_UART is not set
+# CONFIG_SERIAL_RP2 is not set
+# CONFIG_APPLICOM is not set
+CONFIG_DEVPORT=y
+# PC SMBus host controller drivers
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+
+#
+# CONFIG_I2C_DESIGNWARE_PCI is not set
+# CONFIG_I2C_EG20T is not set
+# CONFIG_SPI_PXA2XX is not set
+# CONFIG_SPI_TOPCLIFF_PCH is not set
+# CONFIG_GPIO_VX855 is not set
+# CONFIG_GPIO_BT8XX is not set
+# CONFIG_GPIO_AMD8111 is not set
+# CONFIG_GPIO_ML_IOH is not set
+# CONFIG_GPIO_RDC321X is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_ALIM7101_WDT is not set
+# CONFIG_I6300ESB_WDT is not set
+# PCI-based Watchdog Cards
+#
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_WDTPCI is not set
+
+#
+# CONFIG_LPC_ICH is not set
+# CONFIG_LPC_SCH is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_RTSX_PCI is not set
+# CONFIG_MFD_TIMBERDALE is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MEDIA_PCI_SUPPORT is not set
+# CONFIG_VIDEO_CAFE_CCIC is not set
+# CONFIG_RADIO_MAXIRADIO is not set
+CONFIG_VGA_ARB=y
+CONFIG_VGA_ARB_MAX_GPUS=16
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_R128 is not set
+# CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_NOUVEAU is not set
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_VIA is not set
+# CONFIG_DRM_SAVAGE is not set
+# CONFIG_DRM_VMWGFX is not set
+# CONFIG_DRM_AST is not set
+# CONFIG_DRM_MGAG200 is not set
+# CONFIG_DRM_CIRRUS_QEMU is not set
+# CONFIG_DRM_QXL is not set
+# CONFIG_DRM_BOCHS is not set
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I740 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_MB862XX is not set
+CONFIG_SND_PCI=y
+# CONFIG_SND_AD1889 is not set
+# CONFIG_SND_ALS300 is not set
+# CONFIG_SND_ALI5451 is not set
+# CONFIG_SND_ATIIXP is not set
+# CONFIG_SND_ATIIXP_MODEM is not set
+# CONFIG_SND_AU8810 is not set
+# CONFIG_SND_AU8820 is not set
+# CONFIG_SND_AU8830 is not set
+# CONFIG_SND_AW2 is not set
+# CONFIG_SND_AZT3328 is not set
+# CONFIG_SND_BT87X is not set
+# CONFIG_SND_CA0106 is not set
+# CONFIG_SND_CMIPCI is not set
+# CONFIG_SND_OXYGEN is not set
+# CONFIG_SND_CS4281 is not set
+# CONFIG_SND_CS46XX is not set
+# CONFIG_SND_CS5535AUDIO is not set
+# CONFIG_SND_CTXFI is not set
+# CONFIG_SND_DARLA20 is not set
+# CONFIG_SND_GINA20 is not set
+# CONFIG_SND_LAYLA20 is not set
+# CONFIG_SND_DARLA24 is not set
+# CONFIG_SND_GINA24 is not set
+# CONFIG_SND_LAYLA24 is not set
+# CONFIG_SND_MONA is not set
+# CONFIG_SND_MIA is not set
+# CONFIG_SND_ECHO3G is not set
+# CONFIG_SND_INDIGO is not set
+# CONFIG_SND_INDIGOIO is not set
+# CONFIG_SND_INDIGODJ is not set
+# CONFIG_SND_INDIGOIOX is not set
+# CONFIG_SND_INDIGODJX is not set
+# CONFIG_SND_EMU10K1 is not set
+# CONFIG_SND_EMU10K1X is not set
+# CONFIG_SND_ENS1370 is not set
+# CONFIG_SND_ENS1371 is not set
+# CONFIG_SND_ES1938 is not set
+# CONFIG_SND_ES1968 is not set
+# CONFIG_SND_FM801 is not set
+# CONFIG_SND_HDA_INTEL is not set
+# CONFIG_SND_HDSP is not set
+# CONFIG_SND_HDSPM is not set
+# CONFIG_SND_ICE1712 is not set
+# CONFIG_SND_ICE1724 is not set
+# CONFIG_SND_INTEL8X0 is not set
+# CONFIG_SND_INTEL8X0M is not set
+# CONFIG_SND_KORG1212 is not set
+# CONFIG_SND_LOLA is not set
+# CONFIG_SND_LX6464ES is not set
+# CONFIG_SND_MAESTRO3 is not set
+# CONFIG_SND_MIXART is not set
+# CONFIG_SND_NM256 is not set
+# CONFIG_SND_PCXHR is not set
+# CONFIG_SND_RIPTIDE is not set
+# CONFIG_SND_RME32 is not set
+# CONFIG_SND_RME96 is not set
+# CONFIG_SND_RME9652 is not set
+# CONFIG_SND_SONICVIBES is not set
+# CONFIG_SND_TRIDENT is not set
+# CONFIG_SND_VIA82XX is not set
+# CONFIG_SND_VIA82XX_MODEM is not set
+# CONFIG_SND_VIRTUOSO is not set
+# CONFIG_SND_VX222 is not set
+# CONFIG_SND_YMFPCI is not set
+CONFIG_USB_EHCI_PCI=y
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_AMD5536UDC is not set
+# CONFIG_USB_NET2280 is not set
+# CONFIG_USB_GOKU is not set
+# CONFIG_USB_EG20T is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC_SDHCI_PCI is not set
+# CONFIG_MMC_TIFM_SD is not set
+# CONFIG_MMC_CB710 is not set
+# CONFIG_MMC_VIA_SDMMC is not set
+# CONFIG_INFINIBAND is not set
+# CONFIG_DW_DMAC_PCI is not set
+# CONFIG_VIRTIO_PCI is not set
+# CONFIG_ET131X is not set
+# CONFIG_R8187SE is not set
+# CONFIG_RTL8192U is not set
+# CONFIG_R8821AE is not set
+# CONFIG_RTS5208 is not set
+# CONFIG_IDE_PHISON is not set
+# CONFIG_VT6655 is not set
+# CONFIG_DX_SEP is not set
+# CONFIG_FB_SM7XX is not set
+# CONFIG_CRYSTALHD is not set
+# CONFIG_FB_XGI is not set
+# CONFIG_VIDEO_DT3155 is not set
+# CONFIG_SOLO6X10 is not set
+CONFIG_NET_VENDOR_SILICOM=y
+# CONFIG_SBYPASS is not set
+# CONFIG_BPCTL is not set
+# CONFIG_DGNC is not set
+# CONFIG_VME_BUS is not set
+# CONFIG_CRYPTO_DEV_HIFN_795X is not set
+CONFIG_PCI_MSI=y
+CONFIG_RFKILL=y
+CONFIG_RFKILL_LEDS=y
+# CONFIG_RFKILL_INPUT is not set
+# CONFIG_RFKILL_GPIO is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_RADIO_WL128X is not set
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_CFG80211_WEXT=y
+# CONFIG_IPW2200 is not set
+# CONFIG_HERMES is not set
+CONFIG_IWLMVM=m
+
+#
+# EA: Added for the sound codec
+#
+CONFIG_SND_SOC_IMX_WM8731=y
+
+#
+# EA: Possibly needed for CAN
+#
+CONFIG_CAN_VCAN=y
+CONFIG_CAN_DEBUG_DEVICES=y
+
+#
+# EA: Touch controller on Carrier Board
+#
+CONFIG_TOUCHSCREEN_AR1021_I2C=y
+
+#
+# EA: For USB Modem
+#
+CONFIG_USB_NET_RNDIS_HOST=m
+
+#
+# EA: Enable RPMsg Ping-pong demo
+#
+CONFIG_IMX_RPMSG_PINGPONG=m
+
+#
+# EA: BD7181x PMIC
+#
+CONFIG_GPIO_BD7181X=y
+CONFIG_BD7181X_POWER=y
+CONFIG_MFD_BD7181X=y
+CONFIG_REGULATOR_BD7181X=y
+CONFIG_RTC_DRV_BD7181X=y
+
diff --git a/arch/arm/mach-imx/mach-imx6q.c b/arch/arm/mach-imx/mach-imx6q.c
index 039d9c2..95ddc7d 100644
--- a/arch/arm/mach-imx/mach-imx6q.c
+++ b/arch/arm/mach-imx/mach-imx6q.c
@@ -136,6 +136,48 @@ static int __init imx6q_flexcan_fixup_auto(void)
 	return 0;
 }
 
+static void mx6qea_flexcan_switch(void)
+{
+	/* Polarity is inverted on the COM Carrier Board rev A */
+	if (flexcan0_en || flexcan1_en) {
+		gpio_set_value_cansleep(flexcan_en_gpio, 1);
+		gpio_set_value_cansleep(flexcan_en_gpio, 0);
+	} else {
+		gpio_set_value_cansleep(flexcan_en_gpio, 1);
+	}
+}
+
+static void imx6qea_flexcan0_switch_auto(int enable)
+{
+	flexcan0_en = enable;
+	mx6qea_flexcan_switch();
+}
+
+static void imx6qea_flexcan1_switch_auto(int enable)
+{
+	flexcan1_en = enable;
+	mx6qea_flexcan_switch();
+}
+
+static int __init imx6qea_flexcan_fixup_auto(void)
+{
+	struct device_node *np;
+
+	np = of_find_node_by_path("/soc/aips-bus@02000000/can@02090000");
+	if (!np)
+		return -ENODEV;
+
+	flexcan_en_gpio = of_get_named_gpio(np, "trx-en-gpio", 0);
+	if (gpio_is_valid(flexcan_en_gpio) &&
+		!gpio_request_one(flexcan_en_gpio, GPIOF_DIR_OUT, "flexcan-trx-en")) {
+		/* flexcan 0 & 1 are using the same GPIOs for transceiver */
+		flexcan_pdata[0].transceiver_switch = imx6qea_flexcan0_switch_auto;
+		flexcan_pdata[1].transceiver_switch = imx6qea_flexcan1_switch_auto;
+	}
+
+	return 0;
+}
+
 /* For imx6q sabrelite board: set KSZ9021RN RGMII pad skew */
 static int ksz9021rn_phy_fixup(struct phy_device *phydev)
 {
@@ -516,6 +558,10 @@ static void __init imx6q_init_late(void)
 	if (of_machine_is_compatible("fsl,imx6q-sabreauto")
 		|| of_machine_is_compatible("fsl,imx6dl-sabreauto"))
 		imx6q_flexcan_fixup_auto();
+
+	if (of_machine_is_compatible("fsl,imx6qea-com") 
+		|| of_machine_is_compatible("fsl,imx6dlea-com"))
+		imx6qea_flexcan_fixup_auto();
 }
 
 static void __init imx6q_map_io(void)
diff --git a/arch/arm/mach-imx/mach-imx6sx.c b/arch/arm/mach-imx/mach-imx6sx.c
index eda08df..e38775e 100755
--- a/arch/arm/mach-imx/mach-imx6sx.c
+++ b/arch/arm/mach-imx/mach-imx6sx.c
@@ -166,6 +166,8 @@ static int __init imx6sx_arm2_flexcan_fixup(void)
 
 	if (of_machine_is_compatible("fsl,imx6sx-sdb") && canfd_en)
 		imx6sx_arm2_flexcan0_switch(1);
+	if (of_machine_is_compatible("fsl,imx6sxea-com") && canfd_en)
+		imx6sx_arm2_flexcan0_switch(1);
 
 	return 0;
 }
@@ -295,7 +297,8 @@ static void __init imx6sx_init_late(void)
 	}
 
 	if (of_machine_is_compatible("fsl,imx6sx-sdb") ||
-		of_machine_is_compatible("fsl,imx6sx-sabreauto"))
+		of_machine_is_compatible("fsl,imx6sx-sabreauto") ||
+		of_machine_is_compatible("fsl,imx6sxea-com"))
 		imx6sx_arm2_flexcan_fixup();
 
 	imx6sx_cpuidle_init();
diff --git a/arch/arm/mach-imx/mach-imx6ul.c b/arch/arm/mach-imx/mach-imx6ul.c
index 4accb3a..e3d0fea 100644
--- a/arch/arm/mach-imx/mach-imx6ul.c
+++ b/arch/arm/mach-imx/mach-imx6ul.c
@@ -25,6 +25,60 @@
 #include "common.h"
 #include "cpuidle.h"
 
+static struct flexcan_platform_data flexcan_pdata[2];
+static int flexcan_en_gpio;
+static int flexcan_en_active_high;
+static int flexcan0_en;
+static int flexcan1_en;
+
+static void imx6ulea_flexcan_switch(void)
+{
+	if (flexcan0_en || flexcan1_en) {
+		gpio_set_value_cansleep(flexcan_en_gpio,
+					!flexcan_en_active_high);
+		gpio_set_value_cansleep(flexcan_en_gpio,
+					flexcan_en_active_high);
+	} else {
+		gpio_set_value_cansleep(flexcan_en_gpio,
+					!flexcan_en_active_high);
+	}
+}
+
+static void imx6ulea_flexcan0_switch(int enable)
+{
+	flexcan0_en = enable;
+	imx6ulea_flexcan_switch();
+}
+
+static void imx6ulea_flexcan1_switch(int enable)
+{
+	flexcan1_en = enable;
+	imx6ulea_flexcan_switch();
+}
+
+static int __init imx6ulea_flexcan_fixup(void)
+{
+	struct device_node *np;
+	enum of_gpio_flags en_flags, stby_flags;
+
+	np = of_find_node_by_path("/soc/aips-bus@02000000/can@02090000");
+	if (!np)
+		return -ENODEV;
+
+	flexcan_en_gpio = of_get_named_gpio_flags(np, "trx-en-gpio", 0, &en_flags);
+
+	if (gpio_is_valid(flexcan_en_gpio) && 
+		!gpio_request_one(flexcan_en_gpio, GPIOF_DIR_OUT, "flexcan-trx-en")) {
+		/* flexcan 0 & 1 are using the same GPIOs for transceiver */
+		flexcan_pdata[0].transceiver_switch = imx6ulea_flexcan0_switch;
+		flexcan_pdata[1].transceiver_switch = imx6ulea_flexcan1_switch;
+		if (!(en_flags & OF_GPIO_ACTIVE_LOW))
+			flexcan_en_active_high = 1;
+	}
+
+	return 0;
+}
+
 static void __init imx6ul_enet_clk_init(void)
 {
 	struct regmap *gpr;
@@ -99,6 +153,9 @@ static void __init imx6ul_init_late(void)
 {
 	platform_device_register_simple("imx6q-cpufreq", -1, NULL, 0);
 
+	if (of_machine_is_compatible("fsl,imx6ulea-com"))
+		imx6ulea_flexcan_fixup();
+
 	imx6ul_cpuidle_init();
 }
 
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index 903f24d..dcf5f3d 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -626,6 +626,13 @@ config GPIO_ADNP
 	  enough to represent all pins, but the driver will assume a
 	  register layout for 64 pins (8 registers).
 
+config GPIO_BD7181X
+	tristate "BD7181X GPO"
+	depends on MFD_BD7181X
+	help
+	  Say yes here to access the GPO signals of bd71815/bd71817 chip from ROHM.
+
+
 comment "PCI GPIO expanders:"
 
 config GPIO_CS5535
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index 5d50179..406a49f 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -99,3 +99,4 @@ obj-$(CONFIG_GPIO_WM8350)	+= gpio-wm8350.o
 obj-$(CONFIG_GPIO_WM8994)	+= gpio-wm8994.o
 obj-$(CONFIG_GPIO_XILINX)	+= gpio-xilinx.o
 obj-$(CONFIG_GPIO_XTENSA)	+= gpio-xtensa.o
+obj-$(CONFIG_GPIO_BD7181X)	+= gpio-bd7181x.o
diff --git a/drivers/gpio/gpio-bd7181x.c b/drivers/gpio/gpio-bd7181x.c
new file mode 100644
index 0000000..39ffe4c
--- /dev/null
+++ b/drivers/gpio/gpio-bd7181x.c
@@ -0,0 +1,201 @@
+/*
+ * gpio-bd7181x.c
+ * @file Access to GPOs on ROHM BD7181XMWV chip
+ *
+ * Copyright 2014 Embest Technology Co. Ltd. Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kthread.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+
+#include <linux/mfd/bd7181x.h>
+
+/** @brief bd7181x gpio chip core data */
+static struct gpio_chip bd7181xgpo_chip;
+
+/** @brief get gpo output value
+ * @param chip pointer to core data
+ * @param offset gpo number, start from 0
+ * @retval 0 success
+ * @retval negative error number
+ */
+static int bd7181xgpo_get(struct gpio_chip *chip, unsigned offset)
+{
+	struct bd7181x *bd7181x = dev_get_drvdata(chip->dev->parent);
+	int ret = 0;
+
+	ret = bd7181x_reg_read(bd7181x, BD7181X_REG_GPO);
+	if (ret < 0)
+		return ret;
+
+	return (ret >> offset) & 1;
+}
+
+/** @brief set gpo direction as output
+ * @param chip pointer to core data
+ * @param offset gpo number, start from 0
+ * @param value output value when set direction out
+ * @retval 0 success
+ */
+static int bd7181xgpo_direction_out(struct gpio_chip *chip, unsigned offset,
+				    int value)
+{
+	/* This only drives GPOs, and can't change direction */
+	return 0;
+}
+
+/** @brief set gpo output value
+ * @param chip pointer to core data
+ * @param offset gpo number, start from 0
+ * @param value output value, not zero as high level, 0 as low level
+ * @retval 0 success
+ * @retval negative error number
+ */
+static void bd7181xgpo_set(struct gpio_chip *chip, unsigned offset, int value)
+{
+	struct bd7181x *bd7181x = dev_get_drvdata(chip->dev->parent);
+	int ret;
+	u8 gpoctl;
+
+	ret = bd7181x_reg_read(bd7181x, BD7181X_REG_GPO);
+	if (ret < 0)
+		return;
+
+	if (value)
+		gpoctl = ret | (1 << offset);
+	else
+		gpoctl = ret & ~(1 << offset);
+
+	bd7181x_reg_write(bd7181x, BD7181X_REG_GPO, gpoctl);
+}
+
+/** @brief bd7181x gpio chip core data */
+static struct gpio_chip bd7181xgpo_chip = {
+	.label			= "bd7181x",		///< gpio chip name
+	.owner			= THIS_MODULE,
+	.get			= bd7181xgpo_get,
+	.direction_output	= bd7181xgpo_direction_out,
+	.set			= bd7181xgpo_set,
+	.can_sleep		= 1,
+};
+
+/*----------------------------------------------------------------------*/
+#ifdef CONFIG_OF
+/** @brief retrive gpo platform data from device tree
+ * @param pdev platfrom device pointer
+ * @return pointer to platform data
+ * @retval NULL error
+ */
+static struct bd7181x_gpo_plat_data *of_gpio_bd7181x(
+	struct platform_device *pdev)
+{
+	struct bd7181x_gpo_plat_data *platform_data;
+	struct device_node *np, *gpio_np;
+
+	platform_data = devm_kzalloc(&pdev->dev, sizeof(*platform_data), GFP_KERNEL);
+	if (!platform_data) {
+		return NULL;
+	}
+
+	np = of_node_get(pdev->dev.parent->of_node);
+	gpio_np = of_find_node_by_name(np, "gpo");
+	if (!gpio_np) {
+		dev_err(&pdev->dev, "gpio node not found\n");
+		return NULL;
+	}
+
+	pdev->dev.of_node = gpio_np;
+	
+	if (of_property_read_u32(gpio_np, "rohm,mode", &platform_data->mode)) {
+		platform_data->mode = -1;
+	}
+	
+	return platform_data;
+}
+#endif
+
+/** @brief probe bd7181x gpo device
+ * @param pdev platfrom device pointer
+ * @retval 0 success
+ * @retval negative error number
+ */
+static int gpo_bd7181x_probe(struct platform_device *pdev)
+{
+	struct bd7181x_gpo_plat_data *pdata = pdev->dev.platform_data;
+	struct device *mfd_dev = pdev->dev.parent;
+	struct bd7181x *bd7181x = dev_get_drvdata(mfd_dev);
+	int ret;
+
+#ifdef CONFIG_OF
+	pdata = of_gpio_bd7181x(pdev);
+#endif
+	if (pdata && pdata->gpio_base > 0)
+		bd7181xgpo_chip.base = pdata->gpio_base;
+	else
+		bd7181xgpo_chip.base = -1;
+
+	bd7181xgpo_chip.ngpio = 2;	/* bd71815/bd71817 have 2 GPO */
+
+	bd7181xgpo_chip.dev = &pdev->dev;
+
+	ret = gpiochip_add(&bd7181xgpo_chip);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "could not register gpiochip, %d\n", ret);
+		bd7181xgpo_chip.ngpio = 0;
+		return ret;
+	}
+
+	if (pdata && pdata->mode != -1UL) {
+		bd7181x_update_bits(bd7181x, BD7181X_REG_GPO, 0x70, pdata->mode);
+	}
+
+	return ret;
+}
+
+/** @brief remove bd7181x gpo device
+ * @param pdev platfrom device pointer
+ * @retval 0 success
+ * @retval negative error number
+ */
+static int gpo_bd7181x_remove(struct platform_device *pdev)
+{
+	return gpiochip_remove(&bd7181xgpo_chip);
+}
+
+/* Note:  this hardware lives inside an I2C-based multi-function device. */
+MODULE_ALIAS("platform:bd7181x-gpo");
+
+/** @brief bd7181x gpo driver core data */
+static struct platform_driver gpo_bd7181x_driver = {
+	.driver = {
+		.name	= "bd7181x-gpo",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= gpo_bd7181x_probe,
+	.remove		= gpo_bd7181x_remove,
+};
+
+module_platform_driver(gpo_bd7181x_driver);
+
+MODULE_AUTHOR("Peter Yang <yanglsh@embest-tech.com>");
+MODULE_DESCRIPTION("GPO interface for BD71815/BD71817");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index e013025..9d66b2b 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -86,6 +86,18 @@ config TOUCHSCREEN_AD7879_SPI
 	  To compile this driver as a module, choose M here: the
 	  module will be called ad7879-spi.
 
+config TOUCHSCREEN_AR1021_I2C
+	tristate "Microchip AR1021 i2c touchscreen"
+	depends on I2C && OF
+	help
+	  Say Y here if you have the Microchip AR1021 touchscreen controller
+	  chip in your system.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ar1021_i2c.
+
 config TOUCHSCREEN_ATMEL_MXT
 	tristate "Atmel mXT I2C Touchscreen"
 	depends on I2C
@@ -305,6 +317,19 @@ config TOUCHSCREEN_ILI210X
 	  To compile this driver as a module, choose M here: the
 	  module will be called ili210x.
 
+config TOUCHSCREEN_ILIAIM
+	tristate "Ilitek I2C based touchscreen"
+	depends on I2C
+	help
+	  Say Y here if you have an Ilitek multitouch touchscreen
+	  controller. This driver supports at least models ILI2115
+	  and ILI8939.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ilitek_aim.
+
 config TOUCHSCREEN_S3C2410
 	tristate "Samsung S3C2410/generic touchscreen input driver"
 	depends on ARCH_S3C24XX || SAMSUNG_DEV_TS
@@ -920,6 +945,18 @@ config TOUCHSCREEN_ST1232
 	  To compile this driver as a module, choose M here: the
 	  module will be called st1232_ts.
 
+config TOUCHSCREEN_SITRONIX_I2C
+	tristate "Sitronix I2C I/F Multi-Touch Controller"
+	depends on I2C
+	help
+	  Say Y here if you want to support Sitronix multitouch
+	  touchscreen controller.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called sitronix_i2c_touch.
+
 config TOUCHSCREEN_STMPE
 	tristate "STMicroelectronics STMPE touchscreens"
 	depends on MFD_STMPE
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 88e481f..d9ce52b 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -12,6 +12,7 @@ obj-$(CONFIG_TOUCHSCREEN_AD7879)	+= ad7879.o
 obj-$(CONFIG_TOUCHSCREEN_AD7879_I2C)	+= ad7879-i2c.o
 obj-$(CONFIG_TOUCHSCREEN_AD7879_SPI)	+= ad7879-spi.o
 obj-$(CONFIG_TOUCHSCREEN_ADS7846)	+= ads7846.o
+obj-$(CONFIG_TOUCHSCREEN_AR1021_I2C)	+= ar1021_i2c.o
 obj-$(CONFIG_TOUCHSCREEN_ATMEL_MXT)	+= atmel_mxt_ts.o
 obj-$(CONFIG_TOUCHSCREEN_ATMEL_TSADCC)	+= atmel_tsadcc.o
 obj-$(CONFIG_TOUCHSCREEN_AUO_PIXCIR)	+= auo-pixcir-ts.o
@@ -35,6 +36,7 @@ obj-$(CONFIG_TOUCHSCREEN_ELAN)      += elan_ts.o
 obj-$(CONFIG_TOUCHSCREEN_EGALAX)	+= egalax_ts.o
 obj-$(CONFIG_TOUCHSCREEN_FUJITSU)	+= fujitsu_ts.o
 obj-$(CONFIG_TOUCHSCREEN_ILI210X)	+= ili210x.o
+obj-$(CONFIG_TOUCHSCREEN_ILIAIM)	+= ilitek_aim.o
 obj-$(CONFIG_TOUCHSCREEN_INEXIO)	+= inexio.o
 obj-$(CONFIG_TOUCHSCREEN_INTEL_MID)	+= intel-mid-touch.o
 obj-$(CONFIG_TOUCHSCREEN_IMX6UL_TSC)	+= imx6ul_tsc.o
@@ -55,6 +57,7 @@ obj-$(CONFIG_TOUCHSCREEN_PENMOUNT)	+= penmount.o
 obj-$(CONFIG_TOUCHSCREEN_PIXCIR)	+= pixcir_i2c_ts.o
 obj-$(CONFIG_TOUCHSCREEN_S3C2410)	+= s3c2410_ts.o
 obj-$(CONFIG_TOUCHSCREEN_ST1232)	+= st1232.o
+obj-$(CONFIG_TOUCHSCREEN_SITRONIX_I2C)	+= sitronix_i2c_touch.o
 obj-$(CONFIG_TOUCHSCREEN_STMPE)		+= stmpe-ts.o
 obj-$(CONFIG_TOUCHSCREEN_SUR40)		+= sur40.o
 obj-$(CONFIG_TOUCHSCREEN_TI_AM335X_TSC)	+= ti_am335x_tsc.o
diff --git a/drivers/input/touchscreen/ar1021_i2c.c b/drivers/input/touchscreen/ar1021_i2c.c
new file mode 100644
index 0000000..712ae2a
--- /dev/null
+++ b/drivers/input/touchscreen/ar1021_i2c.c
@@ -0,0 +1,217 @@
+/*
+ * Microchip AR1021 driver for I2C
+ *
+ * Author: Christian Gmeiner <christian.gmeiner@gmail.com>
+ *
+ * License: GPLv2 as published by the FSF.
+ */
+
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/of.h>
+#include <linux/i2c.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+
+#define AR1021_TOCUH_PKG_SIZE	5
+
+#define AR1021_MAX_X	4095
+#define AR1021_MAX_Y	4095
+
+struct ar1021_i2c {
+	struct i2c_client *client;
+	struct input_dev *input;
+	u8 data[AR1021_TOCUH_PKG_SIZE];
+	bool swap_xy;
+	bool invert_x;
+	bool invert_y;
+};
+
+static irqreturn_t ar1021_i2c_irq(int irq, void *dev_id)
+{
+	struct ar1021_i2c *ar1021 = dev_id;
+	struct input_dev *input = ar1021->input;
+	u8 *data = ar1021->data;
+	unsigned int x, y, button;
+	int retval;
+
+	retval = i2c_master_recv(ar1021->client,
+				ar1021->data, sizeof(ar1021->data));
+	if (retval != sizeof(ar1021->data))
+		goto out;
+
+	/* sync bit set ? */
+	if ((data[0] & 0x80) == 0)
+		goto out;
+
+	button = data[0] & BIT(0);
+	x = ((data[2] & 0x1f) << 7) | (data[1] & 0x7f);
+	y = ((data[4] & 0x1f) << 7) | (data[3] & 0x7f);
+
+	if (ar1021->swap_xy)
+		swap(x, y);
+	if (ar1021->invert_x)
+		x = AR1021_MAX_X - x;
+	if (ar1021->invert_y)
+		y = AR1021_MAX_Y - y;
+
+	input_report_abs(input, ABS_X, x);
+	input_report_abs(input, ABS_Y, y);
+	input_report_key(input, BTN_TOUCH, button);
+	input_sync(input);
+
+out:
+	return IRQ_HANDLED;
+}
+
+static int ar1021_i2c_open(struct input_dev *dev)
+{
+	struct ar1021_i2c *ar1021 = input_get_drvdata(dev);
+	struct i2c_client *client = ar1021->client;
+	
+	/* ENABLE_TOUCH */
+	unsigned char buf[] = { 0x00, 0x55, 0x01, 0x12 };
+	int retval = i2c_master_send(client, buf, sizeof(buf));
+	if (retval != sizeof(buf)) {
+		dev_err(&client->dev, "Failed to send ENABLE_TOUCH command, err=%d\n", retval);
+	}
+
+	enable_irq(client->irq);
+
+	return 0;
+}
+
+static void ar1021_i2c_close(struct input_dev *dev)
+{
+	struct ar1021_i2c *ar1021 = input_get_drvdata(dev);
+	struct i2c_client *client = ar1021->client;
+	unsigned char buf[] = { 0x00, 0x55, 0x01, 0x13 };
+	int retval;
+
+	disable_irq(client->irq);
+
+	/* DISABLE_TOUCH */
+	retval = i2c_master_send(client, buf, sizeof(buf));
+	if (retval != sizeof(buf)) {
+		dev_err(&client->dev, "Failed to send DISABLE_TOUCH command, err=%d\n", retval);
+	}
+}
+
+static int ar1021_i2c_probe(struct i2c_client *client,
+				     const struct i2c_device_id *id)
+{
+	struct ar1021_i2c *ar1021;
+	struct input_dev *input;
+	struct device_node *np = client->dev.of_node;
+	int error;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "i2c_check_functionality error\n");
+		return -ENXIO;
+	}
+
+	ar1021 = devm_kzalloc(&client->dev, sizeof(*ar1021), GFP_KERNEL);
+	if (!ar1021)
+		return -ENOMEM;
+
+	input = devm_input_allocate_device(&client->dev);
+	if (!input)
+		return -ENOMEM;
+
+	if (!np)
+		return -ENODEV;
+
+	ar1021->client = client;
+	ar1021->input = input;
+	ar1021->swap_xy = of_property_read_bool(np, "ar1021,swap_xy");
+	ar1021->invert_x = of_property_read_bool(np, "ar1021,invert_x");
+	ar1021->invert_y = of_property_read_bool(np, "ar1021,invert_y");
+
+	input->name = "ar1021 I2C Touchscreen";
+	input->id.bustype = BUS_I2C;
+	input->dev.parent = &client->dev;
+	input->open = ar1021_i2c_open;
+	input->close = ar1021_i2c_close;
+
+	__set_bit(EV_ABS, input->evbit);
+	__set_bit(EV_KEY, input->evbit);
+	__set_bit(BTN_TOUCH, input->keybit);
+
+	input_set_abs_params(input, ABS_X, 0, AR1021_MAX_X, 0, 0);
+	input_set_abs_params(input, ABS_Y, 0, AR1021_MAX_Y, 0, 0);
+
+	input_set_drvdata(input, ar1021);
+
+	error = devm_request_threaded_irq(&client->dev, client->irq,
+					  NULL, ar1021_i2c_irq,
+					  IRQF_ONESHOT,
+					  "ar1021_i2c", ar1021);
+	if (error) {
+		dev_err(&client->dev,
+			"Failed to enable IRQ, error: %d\n", error);
+		return error;
+	}
+
+	/* Disable the IRQ, we'll enable it in ar1021_i2c_open() */
+	disable_irq(client->irq);
+
+	error = input_register_device(ar1021->input);
+	if (error) {
+		dev_err(&client->dev,
+			"Failed to register input device, error: %d\n", error);
+		return error;
+	}
+
+	i2c_set_clientdata(client, ar1021);
+	return 0;
+}
+
+static int __maybe_unused ar1021_i2c_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+
+	disable_irq(client->irq);
+
+	return 0;
+}
+
+static int __maybe_unused ar1021_i2c_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+
+	enable_irq(client->irq);
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(ar1021_i2c_pm, ar1021_i2c_suspend, ar1021_i2c_resume);
+
+static const struct i2c_device_id ar1021_i2c_id[] = {
+	{ "MICROCHIP_AR1021_I2C", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, ar1021_i2c_id);
+
+static const struct of_device_id ar1021_i2c_of_match[] = {
+	{ .compatible = "microchip,ar1021-i2c", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ar1021_i2c_of_match);
+
+static struct i2c_driver ar1021_i2c_driver = {
+	.driver	= {
+		.name	= "ar1021_i2c",
+		.owner	= THIS_MODULE,
+		.pm	= &ar1021_i2c_pm,
+		.of_match_table = ar1021_i2c_of_match,
+	},
+
+	.probe		= ar1021_i2c_probe,
+	.id_table	= ar1021_i2c_id,
+};
+module_i2c_driver(ar1021_i2c_driver);
+
+MODULE_AUTHOR("Christian Gmeiner <christian.gmeiner@gmail.com>");
+MODULE_DESCRIPTION("Microchip AR1021 I2C Driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/input/touchscreen/edt-ft5x06.c b/drivers/input/touchscreen/edt-ft5x06.c
index 412a85e..4c4de95 100644
--- a/drivers/input/touchscreen/edt-ft5x06.c
+++ b/drivers/input/touchscreen/edt-ft5x06.c
@@ -1,5 +1,7 @@
 /*
  * Copyright (C) 2012 Simon Budig, <simon.budig@kernelconcepts.de>
+ * Daniel Wagener <daniel.wagener@kernelconcepts.de> (M09 firmware support)
+ * Lothar Wamann <LW@KARO-electronics.de> (DT support)
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -22,7 +24,7 @@
  * Development of this driver has been sponsored by Glyn:
  *    http://www.glyn.com/Products/Displays
  */
-
+#define DEBUG
 #include <linux/module.h>
 #include <linux/ratelimit.h>
 #include <linux/interrupt.h>
@@ -33,6 +35,7 @@
 #include <linux/debugfs.h>
 #include <linux/slab.h>
 #include <linux/gpio.h>
+#include <linux/of_gpio.h>
 #include <linux/input/mt.h>
 #include <linux/input/edt-ft5x06.h>
 
@@ -45,6 +48,14 @@
 #define WORK_REGISTER_NUM_X		0x33
 #define WORK_REGISTER_NUM_Y		0x34
 
+#define M09_REGISTER_THRESHOLD		0x80
+#define M09_REGISTER_GAIN		0x92
+#define M09_REGISTER_OFFSET		0x93
+#define M09_REGISTER_NUM_X		0x94
+#define M09_REGISTER_NUM_Y		0x95
+
+#define NO_REGISTER			0xff
+
 #define WORK_REGISTER_OPMODE		0x3c
 #define FACTORY_REGISTER_OPMODE		0x01
 
@@ -59,12 +70,30 @@
 #define EDT_RAW_DATA_RETRIES		100
 #define EDT_RAW_DATA_DELAY		1 /* msec */
 
+enum edt_ver {
+	M06,
+	M09,
+};
+
+struct edt_reg_addr {
+	int reg_threshold;
+	int reg_report_rate;
+	int reg_gain;
+	int reg_offset;
+	int reg_num_x;
+	int reg_num_y;
+};
+
 struct edt_ft5x06_ts_data {
 	struct i2c_client *client;
 	struct input_dev *input;
 	u16 num_x;
 	u16 num_y;
 
+	int reset_pin;
+	int irq_pin;
+	int wake_pin;
+
 #if defined(CONFIG_DEBUG_FS)
 	struct dentry *debug_dir;
 	u8 *raw_buffer;
@@ -79,6 +108,9 @@ struct edt_ft5x06_ts_data {
 	int report_rate;
 
 	char name[EDT_NAME_LEN];
+
+	struct edt_reg_addr reg_addr;
+	enum edt_ver version;
 };
 
 static int edt_ft5x06_ts_readwrite(struct i2c_client *client,
@@ -136,33 +168,58 @@ static irqreturn_t edt_ft5x06_ts_isr(int irq, void *dev_id)
 {
 	struct edt_ft5x06_ts_data *tsdata = dev_id;
 	struct device *dev = &tsdata->client->dev;
-	u8 cmd = 0xf9;
-	u8 rdbuf[26];
+	u8 cmd;
+	u8 rdbuf[29];
 	int i, type, x, y, id;
+	int offset, tplen, datalen;
 	int error;
 
+	switch (tsdata->version) {
+	case M06:
+		cmd = 0xf9; /* tell the controller to send touch data */
+		offset = 5; /* where the actual touch data starts */
+		tplen = 4;  /* data comes in so called frames */
+		datalen = 26; /* how much bytes to listen for */
+		break;
+
+	case M09:
+		cmd = 0x02;
+		offset = 1;
+		tplen = 6;
+		datalen = 29;
+		break;
+
+	default:
+		goto out;
+	}
+
 	memset(rdbuf, 0, sizeof(rdbuf));
 
 	error = edt_ft5x06_ts_readwrite(tsdata->client,
 					sizeof(cmd), &cmd,
-					sizeof(rdbuf), rdbuf);
+					datalen, rdbuf);
 	if (error) {
 		dev_err_ratelimited(dev, "Unable to fetch data, error: %d\n",
 				    error);
 		goto out;
 	}
 
-	if (rdbuf[0] != 0xaa || rdbuf[1] != 0xaa || rdbuf[2] != 26) {
-		dev_err_ratelimited(dev, "Unexpected header: %02x%02x%02x!\n",
-				    rdbuf[0], rdbuf[1], rdbuf[2]);
-		goto out;
-	}
+	/* M09 does not send header or CRC */
+	if (tsdata->version == M06) {
+		if (rdbuf[0] != 0xaa || rdbuf[1] != 0xaa ||
+			rdbuf[2] != datalen) {
+			dev_err_ratelimited(dev,
+					"Unexpected header: %02x%02x%02x!\n",
+					rdbuf[0], rdbuf[1], rdbuf[2]);
+			goto out;
+		}
 
-	if (!edt_ft5x06_ts_check_crc(tsdata, rdbuf, 26))
-		goto out;
+		if (!edt_ft5x06_ts_check_crc(tsdata, rdbuf, datalen))
+			goto out;
+	}
 
 	for (i = 0; i < MAX_SUPPORT_POINTS; i++) {
-		u8 *buf = &rdbuf[i * 4 + 5];
+		u8 *buf = &rdbuf[i * tplen + offset];
 		bool down;
 
 		type = buf[0] >> 6;
@@ -170,10 +227,14 @@ static irqreturn_t edt_ft5x06_ts_isr(int irq, void *dev_id)
 		if (type == TOUCH_EVENT_RESERVED)
 			continue;
 
+		/* M06 sometimes sends bogus coordinates in TOUCH_DOWN */
+		if (tsdata->version == M06 && type == TOUCH_EVENT_DOWN)
+			continue;
+
 		x = ((buf[0] << 8) | buf[1]) & 0x0fff;
 		y = ((buf[2] << 8) | buf[3]) & 0x0fff;
 		id = (buf[2] >> 4) & 0x0f;
-		down = (type != TOUCH_EVENT_UP);
+		down = type != TOUCH_EVENT_UP;
 
 		input_mt_slot(tsdata->input, id);
 		input_mt_report_slot_state(tsdata->input, MT_TOOL_FINGER, down);
@@ -197,12 +258,25 @@ static int edt_ft5x06_register_write(struct edt_ft5x06_ts_data *tsdata,
 {
 	u8 wrbuf[4];
 
-	wrbuf[0] = tsdata->factory_mode ? 0xf3 : 0xfc;
-	wrbuf[1] = tsdata->factory_mode ? addr & 0x7f : addr & 0x3f;
-	wrbuf[2] = value;
-	wrbuf[3] = wrbuf[0] ^ wrbuf[1] ^ wrbuf[2];
-
-	return edt_ft5x06_ts_readwrite(tsdata->client, 4, wrbuf, 0, NULL);
+	switch (tsdata->version) {
+	case M06:
+		wrbuf[0] = tsdata->factory_mode ? 0xf3 : 0xfc;
+		wrbuf[1] = tsdata->factory_mode ? addr & 0x7f : addr & 0x3f;
+		wrbuf[1] = tsdata->factory_mode ? addr & 0x7f : addr & 0x3f;
+		wrbuf[2] = value;
+		wrbuf[3] = wrbuf[0] ^ wrbuf[1] ^ wrbuf[2];
+		return edt_ft5x06_ts_readwrite(tsdata->client, 4,
+					wrbuf, 0, NULL);
+	case M09:
+		wrbuf[0] = addr;
+		wrbuf[1] = value;
+
+		return edt_ft5x06_ts_readwrite(tsdata->client, 3,
+					wrbuf, 0, NULL);
+
+	default:
+		return -EINVAL;
+	}
 }
 
 static int edt_ft5x06_register_read(struct edt_ft5x06_ts_data *tsdata,
@@ -211,19 +285,36 @@ static int edt_ft5x06_register_read(struct edt_ft5x06_ts_data *tsdata,
 	u8 wrbuf[2], rdbuf[2];
 	int error;
 
-	wrbuf[0] = tsdata->factory_mode ? 0xf3 : 0xfc;
-	wrbuf[1] = tsdata->factory_mode ? addr & 0x7f : addr & 0x3f;
-	wrbuf[1] |= tsdata->factory_mode ? 0x80 : 0x40;
+	switch (tsdata->version) {
+	case M06:
+		wrbuf[0] = tsdata->factory_mode ? 0xf3 : 0xfc;
+		wrbuf[1] = tsdata->factory_mode ? addr & 0x7f : addr & 0x3f;
+		wrbuf[1] |= tsdata->factory_mode ? 0x80 : 0x40;
 
-	error = edt_ft5x06_ts_readwrite(tsdata->client, 2, wrbuf, 2, rdbuf);
-	if (error)
-		return error;
+		error = edt_ft5x06_ts_readwrite(tsdata->client, 2, wrbuf, 2,
+						rdbuf);
+		if (error)
+			return error;
 
-	if ((wrbuf[0] ^ wrbuf[1] ^ rdbuf[0]) != rdbuf[1]) {
-		dev_err(&tsdata->client->dev,
-			"crc error: 0x%02x expected, got 0x%02x\n",
-			wrbuf[0] ^ wrbuf[1] ^ rdbuf[0], rdbuf[1]);
-		return -EIO;
+		if ((wrbuf[0] ^ wrbuf[1] ^ rdbuf[0]) != rdbuf[1]) {
+			dev_err(&tsdata->client->dev,
+				"crc error: 0x%02x expected, got 0x%02x\n",
+				wrbuf[0] ^ wrbuf[1] ^ rdbuf[0],
+				rdbuf[1]);
+			return -EIO;
+		}
+		break;
+
+	case M09:
+		wrbuf[0] = addr;
+		error = edt_ft5x06_ts_readwrite(tsdata->client, 1,
+						wrbuf, 1, rdbuf);
+		if (error)
+			return error;
+		break;
+
+	default:
+		return -EINVAL;
 	}
 
 	return rdbuf[0];
@@ -234,19 +325,21 @@ struct edt_ft5x06_attribute {
 	size_t field_offset;
 	u8 limit_low;
 	u8 limit_high;
-	u8 addr;
+	u8 addr_m06;
+	u8 addr_m09;
 };
 
-#define EDT_ATTR(_field, _mode, _addr, _limit_low, _limit_high)		\
+#define EDT_ATTR(_field, _mode, _addr_m06, _addr_m09,			\
+		_limit_low, _limit_high)				\
 	struct edt_ft5x06_attribute edt_ft5x06_attr_##_field = {	\
 		.dattr = __ATTR(_field, _mode,				\
 				edt_ft5x06_setting_show,		\
 				edt_ft5x06_setting_store),		\
-		.field_offset =						\
-			offsetof(struct edt_ft5x06_ts_data, _field),	\
+		.field_offset = offsetof(struct edt_ft5x06_ts_data, _field), \
+		.addr_m06 = _addr_m06,					\
+		.addr_m09 = _addr_m09,					\
 		.limit_low = _limit_low,				\
 		.limit_high = _limit_high,				\
-		.addr = _addr,						\
 	}
 
 static ssize_t edt_ft5x06_setting_show(struct device *dev,
@@ -257,10 +350,11 @@ static ssize_t edt_ft5x06_setting_show(struct device *dev,
 	struct edt_ft5x06_ts_data *tsdata = i2c_get_clientdata(client);
 	struct edt_ft5x06_attribute *attr =
 			container_of(dattr, struct edt_ft5x06_attribute, dattr);
-	u8 *field = (u8 *)((char *)tsdata + attr->field_offset);
+	u8 *field = (u8 *)tsdata + attr->field_offset;
 	int val;
 	size_t count = 0;
 	int error = 0;
+	u8 addr;
 
 	mutex_lock(&tsdata->mutex);
 
@@ -269,15 +363,33 @@ static ssize_t edt_ft5x06_setting_show(struct device *dev,
 		goto out;
 	}
 
-	val = edt_ft5x06_register_read(tsdata, attr->addr);
-	if (val < 0) {
-		error = val;
-		dev_err(&tsdata->client->dev,
-			"Failed to fetch attribute %s, error %d\n",
-			dattr->attr.name, error);
+	switch (tsdata->version) {
+	case M06:
+		addr = attr->addr_m06;
+		break;
+
+	case M09:
+		addr = attr->addr_m09;
+		break;
+
+	default:
+		error = -ENODEV;
 		goto out;
 	}
 
+	if (addr != NO_REGISTER) {
+		val = edt_ft5x06_register_read(tsdata, addr);
+		if (val < 0) {
+			error = val;
+			dev_err(&tsdata->client->dev,
+				"Failed to fetch attribute %s, error %d\n",
+				dattr->attr.name, error);
+			goto out;
+		}
+	} else {
+		val = *field;
+	}
+
 	if (val != *field) {
 		dev_warn(&tsdata->client->dev,
 			 "%s: read (%d) and stored value (%d) differ\n",
@@ -299,9 +411,10 @@ static ssize_t edt_ft5x06_setting_store(struct device *dev,
 	struct edt_ft5x06_ts_data *tsdata = i2c_get_clientdata(client);
 	struct edt_ft5x06_attribute *attr =
 			container_of(dattr, struct edt_ft5x06_attribute, dattr);
-	u8 *field = (u8 *)((char *)tsdata + attr->field_offset);
+	u8 *field = (u8 *)tsdata + attr->field_offset;
 	unsigned int val;
 	int error;
+	u8 addr;
 
 	mutex_lock(&tsdata->mutex);
 
@@ -319,14 +432,29 @@ static ssize_t edt_ft5x06_setting_store(struct device *dev,
 		goto out;
 	}
 
-	error = edt_ft5x06_register_write(tsdata, attr->addr, val);
-	if (error) {
-		dev_err(&tsdata->client->dev,
-			"Failed to update attribute %s, error: %d\n",
-			dattr->attr.name, error);
+	switch (tsdata->version) {
+	case M06:
+		addr = attr->addr_m06;
+		break;
+
+	case M09:
+		addr = attr->addr_m09;
+		break;
+
+	default:
+		error = -ENODEV;
 		goto out;
 	}
 
+	if (addr != NO_REGISTER) {
+		error = edt_ft5x06_register_write(tsdata, addr, val);
+		if (error) {
+			dev_err(&tsdata->client->dev,
+				"Failed to update attribute %s, error: %d\n",
+				dattr->attr.name, error);
+			goto out;
+		}
+	}
 	*field = val;
 
 out:
@@ -334,12 +462,14 @@ out:
 	return error ?: count;
 }
 
-static EDT_ATTR(gain, S_IWUSR | S_IRUGO, WORK_REGISTER_GAIN, 0, 31);
-static EDT_ATTR(offset, S_IWUSR | S_IRUGO, WORK_REGISTER_OFFSET, 0, 31);
-static EDT_ATTR(threshold, S_IWUSR | S_IRUGO,
-		WORK_REGISTER_THRESHOLD, 20, 80);
-static EDT_ATTR(report_rate, S_IWUSR | S_IRUGO,
-		WORK_REGISTER_REPORT_RATE, 3, 14);
+static EDT_ATTR(gain, S_IWUSR | S_IRUGO, WORK_REGISTER_GAIN,
+		M09_REGISTER_GAIN, 0, 31);
+static EDT_ATTR(offset, S_IWUSR | S_IRUGO, WORK_REGISTER_OFFSET,
+		M09_REGISTER_OFFSET, 0, 31);
+static EDT_ATTR(threshold, S_IWUSR | S_IRUGO, WORK_REGISTER_THRESHOLD,
+		M09_REGISTER_THRESHOLD, 20, 80);
+static EDT_ATTR(report_rate, S_IWUSR | S_IRUGO, WORK_REGISTER_REPORT_RATE,
+		NO_REGISTER, 3, 14);
 
 static struct attribute *edt_ft5x06_attrs[] = {
 	&edt_ft5x06_attr_gain.dattr.attr,
@@ -374,6 +504,9 @@ static int edt_ft5x06_factory_mode(struct edt_ft5x06_ts_data *tsdata)
 	}
 
 	/* mode register is 0x3c when in the work mode */
+	if (tsdata->version == M09)
+		goto m09_out;
+
 	error = edt_ft5x06_register_write(tsdata, WORK_REGISTER_OPMODE, 0x03);
 	if (error) {
 		dev_err(&client->dev,
@@ -406,12 +539,18 @@ err_out:
 	enable_irq(client->irq);
 
 	return error;
+
+m09_out:
+	dev_err(&client->dev, "No factory mode support for M09\n");
+	return -EINVAL;
+
 }
 
 static int edt_ft5x06_work_mode(struct edt_ft5x06_ts_data *tsdata)
 {
 	struct i2c_client *client = tsdata->client;
 	int retries = EDT_SWITCH_MODE_RETRIES;
+	struct edt_reg_addr *reg_addr = &tsdata->reg_addr;
 	int ret;
 	int error;
 
@@ -444,13 +583,14 @@ static int edt_ft5x06_work_mode(struct edt_ft5x06_ts_data *tsdata)
 	tsdata->raw_buffer = NULL;
 
 	/* restore parameters */
-	edt_ft5x06_register_write(tsdata, WORK_REGISTER_THRESHOLD,
+	edt_ft5x06_register_write(tsdata, reg_addr->reg_threshold,
 				  tsdata->threshold);
-	edt_ft5x06_register_write(tsdata, WORK_REGISTER_GAIN,
+	edt_ft5x06_register_write(tsdata, reg_addr->reg_gain,
 				  tsdata->gain);
-	edt_ft5x06_register_write(tsdata, WORK_REGISTER_OFFSET,
+	edt_ft5x06_register_write(tsdata, reg_addr->reg_offset,
 				  tsdata->offset);
-	edt_ft5x06_register_write(tsdata, WORK_REGISTER_REPORT_RATE,
+	if (reg_addr->reg_report_rate)
+		edt_ft5x06_register_write(tsdata, reg_addr->reg_report_rate,
 				  tsdata->report_rate);
 
 	enable_irq(client->irq);
@@ -479,7 +619,7 @@ static int edt_ft5x06_debugfs_mode_set(void *data, u64 mode)
 
 	if (mode != tsdata->factory_mode) {
 		retval = mode ? edt_ft5x06_factory_mode(tsdata) :
-			        edt_ft5x06_work_mode(tsdata);
+				edt_ft5x06_work_mode(tsdata);
 	}
 
 	mutex_unlock(&tsdata->mutex);
@@ -568,7 +708,6 @@ out:
 	return error ?: read;
 };
 
-
 static const struct file_operations debugfs_raw_data_fops = {
 	.open = simple_open,
 	.read = edt_ft5x06_debugfs_raw_data_read,
@@ -614,58 +753,100 @@ edt_ft5x06_ts_teardown_debugfs(struct edt_ft5x06_ts_data *tsdata)
 
 #endif /* CONFIG_DEBUGFS */
 
-
-
 static int edt_ft5x06_ts_reset(struct i2c_client *client,
-					 int reset_pin)
+			struct edt_ft5x06_ts_data *tsdata)
 {
 	int error;
 
-	if (gpio_is_valid(reset_pin)) {
+	if (gpio_is_valid(tsdata->wake_pin)) {
+		error = devm_gpio_request_one(&client->dev,
+					tsdata->wake_pin, GPIOF_OUT_INIT_LOW,
+					"edt-ft5x06 wake");
+		if (error) {
+			dev_err(&client->dev,
+				"Failed to request GPIO %d as wake pin, error %d\n",
+				tsdata->wake_pin, error);
+			return error;
+		}
+
+		msleep(5);
+		gpio_set_value(tsdata->wake_pin, 1);
+	}
+	if (gpio_is_valid(tsdata->reset_pin)) {
 		/* this pulls reset down, enabling the low active reset */
-		error = devm_gpio_request_one(&client->dev, reset_pin,
-					      GPIOF_OUT_INIT_LOW,
-					      "edt-ft5x06 reset");
+		error = devm_gpio_request_one(&client->dev,
+					tsdata->reset_pin, GPIOF_OUT_INIT_LOW,
+					"edt-ft5x06 reset");
 		if (error) {
 			dev_err(&client->dev,
 				"Failed to request GPIO %d as reset pin, error %d\n",
-				reset_pin, error);
+				tsdata->reset_pin, error);
 			return error;
 		}
 
-		mdelay(50);
-		gpio_set_value(reset_pin, 1);
-		mdelay(100);
+		msleep(5);
+		gpio_set_value(tsdata->reset_pin, 1);
+		msleep(300);
 	}
 
 	return 0;
 }
 
 static int edt_ft5x06_ts_identify(struct i2c_client *client,
-					    char *model_name,
-					    char *fw_version)
+					struct edt_ft5x06_ts_data *tsdata,
+					char *fw_version)
 {
 	u8 rdbuf[EDT_NAME_LEN];
 	char *p;
 	int error;
+	char *model_name = tsdata->name;
 
+	/* see what we find if we assume it is a M06 *
+	 * if we get less than EDT_NAME_LEN, we don't want
+	 * to have garbage in there
+	 */
+	memset(rdbuf, 0, sizeof(rdbuf));
 	error = edt_ft5x06_ts_readwrite(client, 1, "\xbb",
 					EDT_NAME_LEN - 1, rdbuf);
 	if (error)
 		return error;
 
-	/* remove last '$' end marker */
-	rdbuf[EDT_NAME_LEN - 1] = '\0';
-	if (rdbuf[EDT_NAME_LEN - 2] == '$')
-		rdbuf[EDT_NAME_LEN - 2] = '\0';
+	/* if we find something consistent, stay with that assumption
+	 * at least M09 won't send 3 bytes here
+	 */
+	if (!(strnicmp(rdbuf + 1, "EP0", 3))) {
+		tsdata->version = M06;
+
+		/* remove last '$' end marker */
+		rdbuf[EDT_NAME_LEN - 1] = '\0';
+		if (rdbuf[EDT_NAME_LEN - 2] == '$')
+			rdbuf[EDT_NAME_LEN - 2] = '\0';
+
+		/* look for Model/Version separator */
+		p = strchr(rdbuf, '*');
+		if (p)
+			*p++ = '\0';
+		strlcpy(model_name, rdbuf + 1, EDT_NAME_LEN);
+		strlcpy(fw_version, p ? p : "", EDT_NAME_LEN);
+	} else {
+		/* since there are only two versions around (M06, M09) */
+		tsdata->version = M09;
+
+		error = edt_ft5x06_ts_readwrite(client, 1, "\xA6",
+						2, rdbuf);
+		if (error)
+			return error;
 
-	/* look for Model/Version separator */
-	p = strchr(rdbuf, '*');
-	if (p)
-		*p++ = '\0';
+		strlcpy(fw_version, rdbuf, 2);
+
+		error = edt_ft5x06_ts_readwrite(client, 1, "\xA8",
+						1, rdbuf);
+		if (error)
+			return error;
 
-	strlcpy(model_name, rdbuf + 1, EDT_NAME_LEN);
-	strlcpy(fw_version, p ? p : "", EDT_NAME_LEN);
+		snprintf(model_name, EDT_NAME_LEN, "EP0%i%i0M09",
+			rdbuf[0] >> 4, rdbuf[0] & 0x0F);
+	}
 
 	return 0;
 }
@@ -675,32 +856,103 @@ static int edt_ft5x06_ts_identify(struct i2c_client *client,
 	    pdata->name <= edt_ft5x06_attr_##name.limit_high)		\
 		edt_ft5x06_register_write(tsdata, reg, pdata->name)
 
+#define EDT_GET_PROP(name, reg) {				\
+	u32 val;						\
+	if (of_property_read_u32(np, #name, &val) == 0)		\
+		edt_ft5x06_register_write(tsdata, reg, val);	\
+}
+
+static void edt_ft5x06_ts_get_dt_defaults(struct device_node *np,
+					struct edt_ft5x06_ts_data *tsdata)
+{
+	struct edt_reg_addr *reg_addr = &tsdata->reg_addr;
+
+	EDT_GET_PROP(threshold, reg_addr->reg_threshold);
+	EDT_GET_PROP(gain, reg_addr->reg_gain);
+	EDT_GET_PROP(offset, reg_addr->reg_offset);
+}
+
 static void
 edt_ft5x06_ts_get_defaults(struct edt_ft5x06_ts_data *tsdata,
 			   const struct edt_ft5x06_platform_data *pdata)
 {
+	struct edt_reg_addr *reg_addr = &tsdata->reg_addr;
+
 	if (!pdata->use_parameters)
 		return;
 
 	/* pick up defaults from the platform data */
-	EDT_ATTR_CHECKSET(threshold, WORK_REGISTER_THRESHOLD);
-	EDT_ATTR_CHECKSET(gain, WORK_REGISTER_GAIN);
-	EDT_ATTR_CHECKSET(offset, WORK_REGISTER_OFFSET);
-	EDT_ATTR_CHECKSET(report_rate, WORK_REGISTER_REPORT_RATE);
+	EDT_ATTR_CHECKSET(threshold, reg_addr->reg_threshold);
+	EDT_ATTR_CHECKSET(gain, reg_addr->reg_gain);
+	EDT_ATTR_CHECKSET(offset, reg_addr->reg_offset);
+	if (reg_addr->reg_report_rate != NO_REGISTER)
+		EDT_ATTR_CHECKSET(report_rate, reg_addr->reg_report_rate);
 }
 
 static void
 edt_ft5x06_ts_get_parameters(struct edt_ft5x06_ts_data *tsdata)
 {
+	struct edt_reg_addr *reg_addr = &tsdata->reg_addr;
+
 	tsdata->threshold = edt_ft5x06_register_read(tsdata,
-						     WORK_REGISTER_THRESHOLD);
-	tsdata->gain = edt_ft5x06_register_read(tsdata, WORK_REGISTER_GAIN);
-	tsdata->offset = edt_ft5x06_register_read(tsdata, WORK_REGISTER_OFFSET);
-	tsdata->report_rate = edt_ft5x06_register_read(tsdata,
-						WORK_REGISTER_REPORT_RATE);
-	tsdata->num_x = edt_ft5x06_register_read(tsdata, WORK_REGISTER_NUM_X);
-	tsdata->num_y = edt_ft5x06_register_read(tsdata, WORK_REGISTER_NUM_Y);
+						     reg_addr->reg_threshold);
+	tsdata->gain = edt_ft5x06_register_read(tsdata, reg_addr->reg_gain);
+	tsdata->offset = edt_ft5x06_register_read(tsdata, reg_addr->reg_offset);
+	if (reg_addr->reg_report_rate != NO_REGISTER)
+		tsdata->report_rate = edt_ft5x06_register_read(tsdata,
+						reg_addr->reg_report_rate);
+	tsdata->num_x = edt_ft5x06_register_read(tsdata, reg_addr->reg_num_x);
+	tsdata->num_y = edt_ft5x06_register_read(tsdata, reg_addr->reg_num_y);
+}
+
+static void
+edt_ft5x06_ts_set_regs(struct edt_ft5x06_ts_data *tsdata)
+{
+	struct edt_reg_addr *reg_addr = &tsdata->reg_addr;
+
+	switch (tsdata->version) {
+	case M06:
+		reg_addr->reg_threshold = WORK_REGISTER_THRESHOLD;
+		reg_addr->reg_report_rate = WORK_REGISTER_REPORT_RATE;
+		reg_addr->reg_gain = WORK_REGISTER_GAIN;
+		reg_addr->reg_offset = WORK_REGISTER_OFFSET;
+		reg_addr->reg_num_x = WORK_REGISTER_NUM_X;
+		reg_addr->reg_num_y = WORK_REGISTER_NUM_Y;
+		break;
+
+	case M09:
+		reg_addr->reg_threshold = M09_REGISTER_THRESHOLD;
+		reg_addr->reg_gain = M09_REGISTER_GAIN;
+		reg_addr->reg_offset = M09_REGISTER_OFFSET;
+		reg_addr->reg_num_x = M09_REGISTER_NUM_X;
+		reg_addr->reg_num_y = M09_REGISTER_NUM_Y;
+		break;
+	}
+}
+
+#ifdef CONFIG_OF
+static int edt_ft5x06_i2c_ts_probe_dt(struct device *dev,
+				struct edt_ft5x06_ts_data *tsdata)
+{
+	struct device_node *np = dev->of_node;
+
+	/*
+	 * irq_pin is not needed for DT setup.
+	 * irq is associated via 'interrupts' property in DT
+	 */
+	tsdata->irq_pin = -EINVAL;
+	tsdata->reset_pin = of_get_named_gpio(np, "reset-gpios", 0);
+	tsdata->wake_pin = of_get_named_gpio(np, "wake-gpios", 0);
+
+	return 0;
+}
+#else
+static inline int edt_ft5x06_i2c_ts_probe_dt(struct device *dev,
+					struct edt_ft5x06_ts_data *tsdata)
+{
+	return -ENODEV;
 }
+#endif
 
 static int edt_ft5x06_ts_probe(struct i2c_client *client,
 					 const struct i2c_device_id *id)
@@ -714,32 +966,40 @@ static int edt_ft5x06_ts_probe(struct i2c_client *client,
 
 	dev_dbg(&client->dev, "probing for EDT FT5x06 I2C\n");
 
+	tsdata = devm_kzalloc(&client->dev, sizeof(*tsdata), GFP_KERNEL);
+	if (!tsdata) {
+		dev_err(&client->dev, "failed to allocate driver data.\n");
+		return -ENOMEM;
+	}
+
 	if (!pdata) {
-		dev_err(&client->dev, "no platform data?\n");
-		return -EINVAL;
+		error = edt_ft5x06_i2c_ts_probe_dt(&client->dev, tsdata);
+		if (error) {
+			dev_err(&client->dev,
+				"DT probe failed and no platform data present\n");
+			return error;
+		}
+	} else {
+		tsdata->reset_pin = pdata->reset_pin;
+		tsdata->irq_pin = pdata->irq_pin;
+		tsdata->wake_pin = -EINVAL;
 	}
 
-	error = edt_ft5x06_ts_reset(client, pdata->reset_pin);
+	error = edt_ft5x06_ts_reset(client, tsdata);
 	if (error)
 		return error;
 
-	if (gpio_is_valid(pdata->irq_pin)) {
-		error = devm_gpio_request_one(&client->dev, pdata->irq_pin,
-					      GPIOF_IN, "edt-ft5x06 irq");
+	if (gpio_is_valid(tsdata->irq_pin)) {
+		error = devm_gpio_request_one(&client->dev, tsdata->irq_pin,
+					GPIOF_IN, "edt-ft5x06 irq");
 		if (error) {
 			dev_err(&client->dev,
 				"Failed to request GPIO %d, error %d\n",
-				pdata->irq_pin, error);
+				tsdata->irq_pin, error);
 			return error;
 		}
 	}
 
-	tsdata = devm_kzalloc(&client->dev, sizeof(*tsdata), GFP_KERNEL);
-	if (!tsdata) {
-		dev_err(&client->dev, "failed to allocate driver data.\n");
-		return -ENOMEM;
-	}
-
 	input = devm_input_allocate_device(&client->dev);
 	if (!input) {
 		dev_err(&client->dev, "failed to allocate input device.\n");
@@ -751,13 +1011,19 @@ static int edt_ft5x06_ts_probe(struct i2c_client *client,
 	tsdata->input = input;
 	tsdata->factory_mode = false;
 
-	error = edt_ft5x06_ts_identify(client, tsdata->name, fw_version);
+	error = edt_ft5x06_ts_identify(client, tsdata, fw_version);
 	if (error) {
 		dev_err(&client->dev, "touchscreen probe failed\n");
 		return error;
 	}
 
-	edt_ft5x06_ts_get_defaults(tsdata, pdata);
+	edt_ft5x06_ts_set_regs(tsdata);
+
+	if (!pdata)
+		edt_ft5x06_ts_get_dt_defaults(client->dev.of_node, tsdata);
+	else
+		edt_ft5x06_ts_get_defaults(tsdata, pdata);
+
 	edt_ft5x06_ts_get_parameters(tsdata);
 
 	dev_dbg(&client->dev,
@@ -787,10 +1053,10 @@ static int edt_ft5x06_ts_probe(struct i2c_client *client,
 	input_set_drvdata(input, tsdata);
 	i2c_set_clientdata(client, tsdata);
 
-	error = devm_request_threaded_irq(&client->dev, client->irq,
-					  NULL, edt_ft5x06_ts_isr,
-					  IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
-					  client->name, tsdata);
+	error = devm_request_threaded_irq(&client->dev, client->irq, NULL,
+					edt_ft5x06_ts_isr,
+					IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+					client->name, tsdata);
 	if (error) {
 		dev_err(&client->dev, "Unable to request touchscreen IRQ.\n");
 		return error;
@@ -801,19 +1067,21 @@ static int edt_ft5x06_ts_probe(struct i2c_client *client,
 		return error;
 
 	error = input_register_device(input);
-	if (error) {
-		sysfs_remove_group(&client->dev.kobj, &edt_ft5x06_attr_group);
-		return error;
-	}
+	if (error)
+		goto err_remove_attrs;
 
 	edt_ft5x06_ts_prepare_debugfs(tsdata, dev_driver_string(&client->dev));
 	device_init_wakeup(&client->dev, 1);
 
 	dev_dbg(&client->dev,
-		"EDT FT5x06 initialized: IRQ pin %d, Reset pin %d.\n",
-		pdata->irq_pin, pdata->reset_pin);
+		"EDT FT5x06 initialized: IRQ %d, WAKE pin %d, Reset pin %d.\n",
+		client->irq, tsdata->wake_pin, tsdata->reset_pin);
 
 	return 0;
+
+err_remove_attrs:
+	sysfs_remove_group(&client->dev.kobj, &edt_ft5x06_attr_group);
+	return error;
 }
 
 static int edt_ft5x06_ts_remove(struct i2c_client *client)
@@ -852,15 +1120,26 @@ static SIMPLE_DEV_PM_OPS(edt_ft5x06_ts_pm_ops,
 			 edt_ft5x06_ts_suspend, edt_ft5x06_ts_resume);
 
 static const struct i2c_device_id edt_ft5x06_ts_id[] = {
-	{ "edt-ft5x06", 0 },
-	{ }
+	{ "edt-ft5x06", 0, },
+	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(i2c, edt_ft5x06_ts_id);
 
+#ifdef CONFIG_OF
+static const struct of_device_id edt_ft5x06_of_match[] = {
+	{ .compatible = "edt,edt-ft5206", },
+	{ .compatible = "edt,edt-ft5306", },
+	{ .compatible = "edt,edt-ft5406", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, edt_ft5x06_of_match);
+#endif
+
 static struct i2c_driver edt_ft5x06_ts_driver = {
 	.driver = {
 		.owner = THIS_MODULE,
 		.name = "edt_ft5x06",
+		.of_match_table = of_match_ptr(edt_ft5x06_of_match),
 		.pm = &edt_ft5x06_ts_pm_ops,
 	},
 	.id_table = edt_ft5x06_ts_id,
diff --git a/drivers/input/touchscreen/ilitek_aim.c b/drivers/input/touchscreen/ilitek_aim.c
new file mode 100644
index 0000000..36d2fb1
--- /dev/null
+++ b/drivers/input/touchscreen/ilitek_aim.c
@@ -0,0 +1,2196 @@
+/*
+
+	Copyright (C) 2006-2014 ILITEK TECHNOLOGY CORP.
+
+	Description:	ILITEK based touchscreen  driver .
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, see the file COPYING, or write
+	to the Free Software Foundation, Inc.,
+	51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+	ilitek I2C touch screen driver for Android platform
+
+	Author:	 Steward Fu
+	Maintain:Luca Hsu
+	Version: 1
+	History:
+		2010/10/26 Firstly released
+		2010/10/28 Combine both i2c and hid function together
+		2010/11/02 Support interrupt trigger for I2C interface
+		2010/11/10 Rearrange code and add new IOCTL command
+		2010/11/23 Support dynamic to change I2C address
+		2010/12/21 Support resume and suspend functions
+		2010/12/23 Fix synchronous problem when application and driver work at the same time
+		2010/12/28 Add erasing background before calibrating touch panel
+		2011/01/13 Rearrange code and add interrupt with polling method
+		2011/01/14 Add retry mechanism
+		2011/01/17 Support multi-point touch
+		2011/01/21 Support early suspend function
+		2011/02/14 Support key button function
+		2011/02/18 Rearrange code
+		2011/03/21 Fix counld not report first point
+		2011/03/25 Support linux 2.36.x
+		2011/05/31 Added "echo dbg > /dev/ilitek_ctrl" to enable debug message
+				   Added "echo info > /dev/ilitek_ctrl" to show tp informaiton
+				   Added VIRTUAL_KEY_PAD to enable virtual key pad
+				   Added CLOCK_INTERRUPT to change interrupt from Level to Edge
+				   Changed report behavior from Interrupt to Interrupt with Polling
+				   Added disable irq when doing firmware upgrade via APK, it needs to use APK_1.4.9
+		2011/06/21 Avoid button is pressed when press AA
+		2011/08/03 Added ilitek_i2c_calibration function
+		2011/08/18 Fixed multi-point tracking id
+				   Added ROTATE_FLAG to change x-->y, y-->x
+				   Fixed when draw line from non-AA to AA, the line will not be appeared on screen.
+		2011/09/29 Added Stop Polling in Interrupt mode
+				   Fixed Multi-Touch return value
+				   Added release last point
+		2011/10/26 Fixed ROTATE bug
+				   Added release key button when finger up.
+				   Added ilitek_i2c_calibration_status for read calibration status
+		2011/11/09 Fixed release last point issue
+				   enable irq when i2c error.
+		2011/11/28 implement protocol 2.1.
+		2012/02/10 Added muti_touch key.
+				   Added interrupt flag
+		2012/04/02 Added input_report_key , Support Android 4.0
+		2013/01/04 remove release event ABS_MT_TOUCH_MAJOR.
+		2013/01/17 Added protocol 1.6 upgrade flow.(for APK 1.4.16.1)
+				   Added to stop the reported point function.
+		2013/04/11 added report point protocol 3.0
+				   Fixed protocol 1.6 upgrade flow support 4,8,16,32 byte update(for APK 1.4.17.0)
+		2013/04/23 added report key protocol 3.0
+		2013/05/28 added ilitek_i2c_reset function
+				   Fixed versions show the way
+		2013/08/29 Fixed protocol 2.0 report ,  remove release event ABS_MT_TOUCH_MAJOR.
+				   Added set input device
+
+*/
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/kthread.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/cdev.h>
+#include <linux/of_gpio.h>
+#include <asm/uaccess.h>
+#include <linux/version.h>
+#include <linux/regulator/consumer.h>
+#include <linux/wait.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#include <linux/wakelock.h>
+#include <mach/regs-gpio.h>
+#include <mach/gpio.h>
+#include <plat/gpio-cfg.h>
+#endif
+
+//driver information
+#define DERVER_VERSION_MAJOR 		2
+#define DERVER_VERSION_MINOR 		3
+#define RELEASE_VERSION				0
+#define CUSTOMER_ID 				0
+#define MODULE_ID					0
+#define PLATFORM_ID					0
+#define PLATFORM_MODULE				0
+#define ENGINEER_ID					511
+
+int touch_key_hold_press = 0;
+int touch_key_code[] = {KEY_MENU,KEY_HOME,KEY_BACK,KEY_VOLUMEDOWN,KEY_VOLUMEUP};
+int touch_key_press[] = {0, 0, 0, 0, 0};
+unsigned long touch_time=0;
+#define NUM_TOUCH_KEY_CODES  (sizeof(touch_key_code)/sizeof(touch_key_code[0]))
+
+int driver_information[] = {DERVER_VERSION_MAJOR,DERVER_VERSION_MINOR,RELEASE_VERSION,CUSTOMER_ID,MODULE_ID,PLATFORM_ID,PLATFORM_MODULE,ENGINEER_ID};
+
+//#define VIRTUAL_KEY_PAD
+#define VIRTUAL_FUN_1	1	//0X81 with key_id
+#define VIRTUAL_FUN_2	2	//0x81 with x position
+#define VIRTUAL_FUN_3	3	//Judge x & y position
+//#define VIRTUAL_FUN		VIRTUAL_FUN_2
+#define BTN_DELAY_TIME	500 //ms
+
+#define TOUCH_POINT    0x80
+#define TOUCH_KEY      0xC0
+#define RELEASE_KEY    0x40
+#define RELEASE_POINT    0x00
+#define ROTATE_FLAG
+//#define TRANSFER_LIMIT
+#define CLOCK_INTERRUPT
+//#define SET_RESET
+
+//define key pad range
+#define KEYPAD01_X1	0
+#define KEYPAD01_X2	1000
+#define KEYPAD02_X1	1000
+#define KEYPAD02_X2	2000
+#define KEYPAD03_X1	2000
+#define KEYPAD03_X2	3000
+#define KEYPAD04_X1	3000
+#define KEYPAD04_X2	3968
+#define KEYPAD_Y	2100
+// definitions
+#define ILITEK_I2C_RETRY_COUNT			3
+#define ILITEK_I2C_DRIVER_NAME			"ilitek_i2c"
+#define ILITEK_FILE_DRIVER_NAME			"ilitek_file"
+#define ILITEK_DEBUG_LEVEL			KERN_INFO
+#define ILITEK_ERROR_LEVEL			KERN_ALERT
+
+// i2c command for ilitek touch screen
+#define ILITEK_TP_CMD_READ_DATA			0x10
+#define ILITEK_TP_CMD_READ_SUB_DATA		0x11
+#define ILITEK_TP_CMD_GET_RESOLUTION		0x20
+#define ILITEK_TP_CMD_GET_KEY_INFORMATION	0x22
+#define ILITEK_TP_CMD_GET_FIRMWARE_VERSION	0x40
+#define ILITEK_TP_CMD_GET_PROTOCOL_VERSION	0x42
+#define	ILITEK_TP_CMD_CALIBRATION			0xCC
+#define	ILITEK_TP_CMD_CALIBRATION_STATUS	0xCD
+#define ILITEK_TP_CMD_ERASE_BACKGROUND		0xCE
+
+// i2c command for Protocol 3.1
+#define ILITEK_TP_CMD_TOUCH_STATUS			0x0F
+
+// define the application command
+#define ILITEK_IOCTL_BASE                       100
+#define ILITEK_IOCTL_I2C_WRITE_DATA             _IOWR(ILITEK_IOCTL_BASE, 0, unsigned char*)
+#define ILITEK_IOCTL_I2C_WRITE_LENGTH           _IOWR(ILITEK_IOCTL_BASE, 1, int)
+#define ILITEK_IOCTL_I2C_READ_DATA              _IOWR(ILITEK_IOCTL_BASE, 2, unsigned char*)
+#define ILITEK_IOCTL_I2C_READ_LENGTH            _IOWR(ILITEK_IOCTL_BASE, 3, int)
+#define ILITEK_IOCTL_USB_WRITE_DATA             _IOWR(ILITEK_IOCTL_BASE, 4, unsigned char*)
+#define ILITEK_IOCTL_USB_WRITE_LENGTH           _IOWR(ILITEK_IOCTL_BASE, 5, int)
+#define ILITEK_IOCTL_USB_READ_DATA              _IOWR(ILITEK_IOCTL_BASE, 6, unsigned char*)
+#define ILITEK_IOCTL_USB_READ_LENGTH            _IOWR(ILITEK_IOCTL_BASE, 7, int)
+#define ILITEK_IOCTL_DRIVER_INFORMATION		    _IOWR(ILITEK_IOCTL_BASE, 8, int)
+#define ILITEK_IOCTL_USB_UPDATE_RESOLUTION      _IOWR(ILITEK_IOCTL_BASE, 9, int)
+#define ILITEK_IOCTL_I2C_INT_FLAG	            _IOWR(ILITEK_IOCTL_BASE, 10, int)
+#define ILITEK_IOCTL_I2C_UPDATE                 _IOWR(ILITEK_IOCTL_BASE, 11, int)
+#define ILITEK_IOCTL_STOP_READ_DATA             _IOWR(ILITEK_IOCTL_BASE, 12, int)
+#define ILITEK_IOCTL_START_READ_DATA            _IOWR(ILITEK_IOCTL_BASE, 13, int)
+#define ILITEK_IOCTL_GET_INTERFANCE				_IOWR(ILITEK_IOCTL_BASE, 14, int)//default setting is i2c interface
+#define ILITEK_IOCTL_I2C_SWITCH_IRQ				_IOWR(ILITEK_IOCTL_BASE, 15, int)
+#define ILITEK_IOCTL_UPDATE_FLAG				_IOWR(ILITEK_IOCTL_BASE, 16, int)
+#define ILITEK_IOCTL_I2C_UPDATE_FW				_IOWR(ILITEK_IOCTL_BASE, 18, int)
+#define DBG(fmt, args...)   if (DBG_FLAG)printk("%s(%d): " fmt, __func__,__LINE__,  ## args)
+
+// module information
+MODULE_AUTHOR("Steward_Fu");
+MODULE_DESCRIPTION("ILITEK I2C touch driver for Android platform");
+MODULE_LICENSE("GPL");
+
+// all implemented global functions must be defined in here
+// in order to know how many function we had implemented
+static int ilitek_i2c_register_device(void);
+static void ilitek_set_input_param(struct input_dev*, int, int, int);
+static int ilitek_i2c_read_tp_info(void);
+static int ilitek_init(void);
+static void ilitek_exit(void);
+
+// i2c functions
+static int ilitek_i2c_transfer(struct i2c_client*, struct i2c_msg*, int);
+static int ilitek_i2c_read(struct i2c_client*, uint8_t, uint8_t*, int);
+static int ilitek_i2c_process_and_report(void);
+static int ilitek_i2c_suspend(struct device *dev);
+static int ilitek_i2c_resume(struct device *dev);
+static void ilitek_i2c_shutdown(struct i2c_client*);
+static int ilitek_i2c_probe(struct i2c_client*, const struct i2c_device_id*);
+static int ilitek_i2c_remove(struct i2c_client*);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	static void ilitek_i2c_early_suspend(struct early_suspend *h);
+	static void ilitek_i2c_late_resume(struct early_suspend *h);
+#endif
+static int ilitek_i2c_polling_thread(void*);
+static irqreturn_t ilitek_i2c_isr(int, void*);
+static void ilitek_i2c_irq_work_queue_func(struct work_struct*);
+
+// file operation functions
+static int ilitek_file_open(struct inode*, struct file*);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+	static long ilitek_file_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
+#else
+	static int  ilitek_file_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg);
+#endif
+static int ilitek_file_open(struct inode*, struct file*);
+static ssize_t ilitek_file_write(struct file*, const char*, size_t, loff_t*);
+static ssize_t ilitek_file_read(struct file*, char*, size_t, loff_t*);
+static int ilitek_file_close(struct inode*, struct file*);
+
+static void ilitek_i2c_irq_enable(void);
+static void ilitek_i2c_irq_disable(void);
+
+static int ilitek_i2c_reset(void);
+
+//key
+struct key_info {
+	int id;
+	int x;
+	int y;
+	int status;
+	int flag;
+};
+
+// declare i2c data member
+struct i2c_data {
+	// input device
+	struct input_dev *input_dev;
+	// i2c client
+	struct i2c_client *client;
+	// polling thread
+	struct task_struct *thread;
+	// maximum x
+	int max_x;
+	// maximum y
+	int max_y;
+	// maximum touch point
+	int max_tp;
+	// maximum key button
+	int max_btn;
+	// the total number of x channel
+	int x_ch;
+	// the total number of y channel
+	int y_ch;
+	// check whether i2c driver is registered success
+	int valid_i2c_register;
+	// check whether input driver is registered success
+	int valid_input_register;
+	// check whether the i2c enter suspend or not
+	int stop_polling;
+	// read semaphore
+	struct semaphore wr_sem;
+	// protocol version
+	int protocol_ver;
+	// valid irq request
+	int valid_irq_request;
+	// work queue for interrupt use only
+	struct workqueue_struct *irq_work_queue;
+	// work struct for work queue
+	struct work_struct irq_work;
+
+    struct timer_list timer;
+
+	int report_status;
+
+	int irq_status;
+	//irq_status enable:1 disable:0
+	struct completion complete;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend early_suspend;
+#endif
+
+	int keyflag;
+	int keycount;
+	int key_xlen;
+	int key_ylen;
+	struct key_info keyinfo[10];
+};
+// device data
+struct dev_data {
+	// device number
+	dev_t devno;
+	// character device
+	struct cdev cdev;
+	// class device
+	struct class *class;
+};
+
+// global variables
+static struct i2c_data i2c;
+static struct dev_data dev;
+static char DBG_FLAG = 0;
+static char Report_Flag;
+volatile static char int_Flag;
+volatile static char update_Flag;
+static int update_timeout;
+
+
+static SIMPLE_DEV_PM_OPS(ilitek_i2c_pm, ilitek_i2c_suspend, ilitek_i2c_resume);
+
+static const struct i2c_device_id ilitek_i2c_id[] ={
+	{ILITEK_I2C_DRIVER_NAME, 0}, {}
+};
+MODULE_DEVICE_TABLE(i2c, ilitek_i2c_id);
+
+static const struct of_device_id ilitek_i2c_of_match[] = {
+	{ .compatible = "ilitek,ilitek_aim", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ilitek_i2c_of_match);
+
+// declare i2c function table
+static struct i2c_driver ilitek_i2c_driver = {
+	.driver = {
+		.name	= ILITEK_I2C_DRIVER_NAME,
+		.owner	= THIS_MODULE,
+		.pm		= &ilitek_i2c_pm,
+		.of_match_table = ilitek_i2c_of_match,
+	},
+	.shutdown = ilitek_i2c_shutdown,
+	.probe		= ilitek_i2c_probe,
+	.remove 	= ilitek_i2c_remove,
+	.id_table	= ilitek_i2c_id,
+};
+
+// declare file operations
+struct file_operations ilitek_fops = {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+	.unlocked_ioctl = ilitek_file_ioctl,
+#else
+	.ioctl = ilitek_file_ioctl,
+#endif
+	.read = ilitek_file_read,
+	.write = ilitek_file_write,
+	.open = ilitek_file_open,
+	.release = ilitek_file_close,
+};
+
+/*
+description
+	open function for character device driver
+prarmeters
+	inode
+	    inode
+	filp
+	    file pointer
+return
+	status
+*/
+static int
+ilitek_file_open(struct inode *inode, struct file *filp)
+{
+	DBG("%s\n",__func__);
+	return 0;
+}
+/*
+description
+	calibration function
+prarmeters
+	count
+	    buffer length
+return
+	status
+*/
+static int ilitek_i2c_calibration(size_t count)
+{
+
+	int ret;
+	unsigned char buffer[128]={0};
+	struct i2c_msg msgs[] = {
+		{.addr = i2c.client->addr, .flags = 0, .len = count, .buf = buffer,}
+	};
+
+	buffer[0] = ILITEK_TP_CMD_ERASE_BACKGROUND;
+	msgs[0].len = 1;
+	ret = ilitek_i2c_transfer(i2c.client, msgs, 1);
+	if(ret < 0){
+		printk(ILITEK_DEBUG_LEVEL "%s, i2c erase background, failed\n", __func__);
+	}
+	else{
+		printk(ILITEK_DEBUG_LEVEL "%s, i2c erase background, success\n", __func__);
+	}
+
+	buffer[0] = ILITEK_TP_CMD_CALIBRATION;
+	msgs[0].len = 1;
+	msleep(2000);
+	ret = ilitek_i2c_transfer(i2c.client, msgs, 1);
+	msleep(1000);
+	return ret;
+}
+/*
+description
+	read calibration status
+prarmeters
+	count
+	    buffer length
+return
+	status
+*/
+static int ilitek_i2c_calibration_status(size_t count)
+{
+	int ret;
+	unsigned char buffer[128]={0};
+	struct i2c_msg msgs[] = {
+		{.addr = i2c.client->addr, .flags = 0, .len = count, .buf = buffer,}
+	};
+	buffer[0] = ILITEK_TP_CMD_CALIBRATION_STATUS;
+	ilitek_i2c_transfer(i2c.client, msgs, 1);
+	msleep(500);
+	ilitek_i2c_read(i2c.client, ILITEK_TP_CMD_CALIBRATION_STATUS, buffer, 1);
+	printk("%s, i2c calibration status:0x%X\n",__func__,buffer[0]);
+	ret=buffer[0];
+	return ret;
+}
+/*
+description
+	write function for character device driver
+prarmeters
+	filp
+	    file pointer
+	buf
+	    buffer
+	count
+	    buffer length
+	f_pos
+	    offset
+return
+	status
+*/
+static ssize_t
+ilitek_file_write(
+	struct file *filp, const char *buf, size_t count, loff_t *f_pos)
+{
+	int ret;
+	unsigned char buffer[128]={0};
+
+	// before sending data to touch device, we need to check whether the device is working or not
+	if(i2c.valid_i2c_register == 0){
+		printk(ILITEK_ERROR_LEVEL "%s, i2c device driver doesn't be registered\n", __func__);
+		return -1;
+	}
+
+	// check the buffer size whether it exceeds the local buffer size or not
+	if(count > 128){
+		printk(ILITEK_ERROR_LEVEL "%s, buffer exceed 128 bytes\n", __func__);
+		return -1;
+	}
+
+	// copy data from user space
+	ret = copy_from_user(buffer, buf, count-1);
+	if(ret < 0){
+		printk(ILITEK_ERROR_LEVEL "%s, copy data from user space, failed", __func__);
+		return -1;
+	}
+
+	// parsing command
+	if(strcmp(buffer, "calibrate") == 0){
+		ret=ilitek_i2c_calibration(count);
+		if(ret < 0){
+			printk(ILITEK_DEBUG_LEVEL "%s, i2c send calibration command, failed\n", __func__);
+		}
+		else{
+			printk(ILITEK_DEBUG_LEVEL "%s, i2c send calibration command, success\n", __func__);
+		}
+		ret=ilitek_i2c_calibration_status(count);
+		if(ret == 0x5A){
+			printk(ILITEK_DEBUG_LEVEL "%s, i2c calibration, success\n", __func__);
+		}
+		else if (ret == 0xA5){
+			printk(ILITEK_DEBUG_LEVEL "%s, i2c calibration, failed\n", __func__);
+		}
+		else{
+			printk(ILITEK_DEBUG_LEVEL "%s, i2c calibration, i2c protocol failed\n", __func__);
+		}
+		return count;
+	}else if(strcmp(buffer, "dbg") == 0){
+		DBG_FLAG=!DBG_FLAG;
+		printk("%s, %s message(%X).\n",__func__,DBG_FLAG?"Enabled":"Disabled",DBG_FLAG);
+	}else if(strcmp(buffer, "info") == 0){
+		ilitek_i2c_read_tp_info();
+	}else if(strcmp(buffer, "report") == 0){
+		Report_Flag=!Report_Flag;
+	}else if(strcmp(buffer, "stop_report") == 0){
+		i2c.report_status = 0;
+		printk("The report point function is disable.\n");
+	}else if(strcmp(buffer, "start_report") == 0){
+		i2c.report_status = 1;
+		printk("The report point function is enable.\n");
+	}else if(strcmp(buffer, "update_flag") == 0){
+		printk("update_Flag=%d\n",update_Flag);
+	}else if(strcmp(buffer, "irq_status") == 0){
+		printk("i2c.irq_status=%d\n",i2c.irq_status);
+	}else if(strcmp(buffer, "disable_irq") == 0){
+		ilitek_i2c_irq_disable();
+		printk("i2c.irq_status=%d\n",i2c.irq_status);
+	}else if(strcmp(buffer, "enable_irq") == 0){
+		ilitek_i2c_irq_enable();
+		printk("i2c.irq_status=%d\n",i2c.irq_status);
+	}else if(strcmp(buffer, "reset") == 0){
+		printk("start reset\n");
+		ilitek_i2c_reset();
+		printk("end reset\n");
+	}
+	return -1;
+}
+
+/*
+description
+        ioctl function for character device driver
+prarmeters
+	inode
+		file node
+        filp
+            file pointer
+        cmd
+            command
+        arg
+            arguments
+return
+        status
+*/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+static long ilitek_file_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+#else
+static int  ilitek_file_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
+#endif
+{
+	static unsigned char buffer[64]={0};
+	static int len = 0, i;
+	int ret;
+	struct i2c_msg msgs[] = {
+		{.addr = i2c.client->addr, .flags = 0, .len = len, .buf = buffer,}
+        };
+
+	// parsing ioctl command
+	switch(cmd){
+		case ILITEK_IOCTL_I2C_WRITE_DATA:
+			ret = copy_from_user(buffer, (unsigned char*)arg, len);
+			if(ret < 0){
+				printk(ILITEK_ERROR_LEVEL "%s, copy data from user space, failed\n", __func__);
+				return -1;
+			}
+#ifdef	SET_RESET
+			if(buffer[0] == 0x60){
+				ilitek_i2c_reset();
+			}
+#endif
+			ret = ilitek_i2c_transfer(i2c.client, msgs, 1);
+			if(ret < 0){
+				printk(ILITEK_ERROR_LEVEL "%s, i2c write, failed\n", __func__);
+				return -1;
+			}
+			break;
+		case ILITEK_IOCTL_I2C_READ_DATA:
+			msgs[0].flags = I2C_M_RD;
+
+			ret = ilitek_i2c_transfer(i2c.client, msgs, 1);
+			if(ret < 0){
+				printk(ILITEK_ERROR_LEVEL "%s, i2c read, failed\n", __func__);
+				return -1;
+			}
+			ret = copy_to_user((unsigned char*)arg, buffer, len);
+
+			if(ret < 0){
+				printk(ILITEK_ERROR_LEVEL "%s, copy data to user space, failed\n", __func__);
+				return -1;
+			}
+			break;
+		case ILITEK_IOCTL_I2C_WRITE_LENGTH:
+		case ILITEK_IOCTL_I2C_READ_LENGTH:
+			len = arg;
+			break;
+		case ILITEK_IOCTL_DRIVER_INFORMATION:
+			for(i = 0; i < 8; i++){
+				buffer[i] = driver_information[i];
+			}
+			ret = copy_to_user((unsigned char*)arg, buffer, 7);
+			break;
+		case ILITEK_IOCTL_I2C_UPDATE:
+			break;
+		case ILITEK_IOCTL_I2C_INT_FLAG:
+			if(update_timeout == 1){
+				buffer[0] = int_Flag;
+				ret = copy_to_user((unsigned char*)arg, buffer, 1);
+				if(ret < 0){
+					printk(ILITEK_ERROR_LEVEL "%s, copy data to user space, failed\n", __func__);
+					return -1;
+				}
+			}
+			else
+				update_timeout = 1;
+
+			break;
+		case ILITEK_IOCTL_START_READ_DATA:
+			i2c.stop_polling = 0;
+			if(i2c.client->irq != 0 )
+				ilitek_i2c_irq_enable();
+			i2c.report_status = 1;
+			printk("The report point function is enable.\n");
+			break;
+		case ILITEK_IOCTL_STOP_READ_DATA:
+			i2c.stop_polling = 1;
+			if(i2c.client->irq != 0 )
+				ilitek_i2c_irq_disable();
+			i2c.report_status = 0;
+			printk("The report point function is disable.\n");
+			break;
+		case ILITEK_IOCTL_I2C_SWITCH_IRQ:
+			ret = copy_from_user(buffer, (unsigned char*)arg, 1);
+			if (buffer[0] == 0)
+			{
+				if(i2c.client->irq != 0 ){
+					ilitek_i2c_irq_disable();
+				}
+			}
+			else
+			{
+				if(i2c.client->irq != 0 ){
+					ilitek_i2c_irq_enable();
+				}
+			}
+			break;
+		case ILITEK_IOCTL_UPDATE_FLAG:
+			update_timeout = 1;
+			update_Flag = arg;
+			DBG("%s,update_Flag=%d\n",__func__,update_Flag);
+			break;
+		case ILITEK_IOCTL_I2C_UPDATE_FW:
+			ret = copy_from_user(buffer, (unsigned char*)arg, 35);
+			if(ret < 0){
+				printk(ILITEK_ERROR_LEVEL "%s, copy data from user space, failed\n", __func__);
+				return -1;
+			}
+			int_Flag = 0;
+			update_timeout = 0;
+			msgs[0].len = buffer[34];
+			ret = ilitek_i2c_transfer(i2c.client, msgs, 1);
+			#ifndef CLOCK_INTERRUPT
+			ilitek_i2c_irq_enable();
+			#endif
+			if(ret < 0){
+				printk(ILITEK_ERROR_LEVEL "%s, i2c write, failed\n", __func__);
+				return -1;
+			}
+			break;
+		default:
+			return -1;
+	}
+    	return 0;
+}
+
+/*
+description
+	read function for character device driver
+prarmeters
+	filp
+	    file pointer
+	buf
+	    buffer
+	count
+	    buffer length
+	f_pos
+	    offset
+return
+	status
+*/
+static ssize_t
+ilitek_file_read(
+        struct file *filp, char *buf, size_t count, loff_t *f_pos)
+{
+	return 0;
+}
+
+/*
+description
+	close function
+prarmeters
+	inode
+	    inode
+	filp
+	    file pointer
+return
+	status
+*/
+static int
+ilitek_file_close(
+	struct inode *inode, struct file *filp)
+{
+	DBG("%s\n",__func__);
+        return 0;
+}
+
+/*
+description
+	set input device's parameter
+prarmeters
+	input
+		input device data
+	max_tp
+		single touch or multi touch
+	max_x
+		maximum	x value
+	max_y
+		maximum y value
+return
+	nothing
+*/
+static void
+ilitek_set_input_param(
+	struct input_dev *input,
+	int max_tp,
+	int max_x,
+	int max_y)
+{
+	int key;
+	__set_bit(EV_ABS, input->evbit);
+	__set_bit(EV_KEY, input->evbit);
+	__set_bit(BTN_TOUCH, input->keybit);
+	#ifndef ROTATE_FLAG
+	input_set_abs_params(input, ABS_MT_POSITION_X, 0, max_x+2, 0, 0);
+	input_set_abs_params(input, ABS_MT_POSITION_Y, 0, max_y+2, 0, 0);
+	input_set_abs_params(input, ABS_X, 0, max_x+2, 0, 0);
+	input_set_abs_params(input, ABS_Y, 0, max_y+2, 0, 0);
+	#else
+	input_set_abs_params(input, ABS_MT_POSITION_X, 0, max_y+2, 0, 0);
+	input_set_abs_params(input, ABS_MT_POSITION_Y, 0, max_x+2, 0, 0);
+	input_set_abs_params(input, ABS_X, 0, max_y+2, 0, 0);
+	input_set_abs_params(input, ABS_Y, 0, max_x+2, 0, 0);
+	#endif
+	input_set_abs_params(input, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(input, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(input, ABS_MT_TRACKING_ID, 0, max_tp, 0, 0);
+	set_bit(INPUT_PROP_DIRECT, input->propbit);
+	for(key=0; key<NUM_TOUCH_KEY_CODES; key++){
+		if(touch_key_code[key] <= 0){
+			continue;
+		}
+		set_bit(touch_key_code[key] & KEY_MAX, input->keybit);
+	}
+	input->name = ILITEK_I2C_DRIVER_NAME;
+	input->id.bustype = BUS_I2C;
+	input->dev.parent = &(i2c.client)->dev;
+}
+
+/*
+description
+	send message to i2c adaptor
+parameter
+	client
+		i2c client
+	msgs
+		i2c message
+	cnt
+		i2c message count
+return
+	>= 0 if success
+	others if error
+*/
+static int ilitek_i2c_transfer(struct i2c_client *client, struct i2c_msg *msgs, int cnt)
+{
+	int ret, count=ILITEK_I2C_RETRY_COUNT;
+	while(count >= 0){
+		count-= 1;
+		ret = down_interruptible(&i2c.wr_sem);
+		ret = i2c_transfer(client->adapter, msgs, cnt);
+		up(&i2c.wr_sem);
+		if(ret < 0){
+			msleep(500);
+			continue;
+		}
+		break;
+	}
+	return ret;
+}
+
+/*
+description
+	read data from i2c device
+parameter
+	client
+		i2c client data
+	addr
+		i2c address
+	data
+		data for transmission
+	length
+		data length
+return
+	status
+*/
+static int
+ilitek_i2c_read(
+	struct i2c_client *client,
+	uint8_t cmd,
+	uint8_t *data,
+	int length)
+{
+	int ret;
+    struct i2c_msg msgs[] = {
+		{.addr = client->addr, .flags = 0, .len = 1, .buf = &cmd,},
+		{.addr = client->addr, .flags = I2C_M_RD, .len = length, .buf = data,}
+    };
+
+    ret = ilitek_i2c_transfer(client, msgs, 2);
+	if(ret < 0){
+		printk(ILITEK_ERROR_LEVEL "%s, i2c read error, ret %d\n", __func__, ret);
+	}
+	return ret;
+}
+
+/*
+description
+	read data from i2c device
+parameter
+	client
+		i2c client data
+	addr
+		i2c address
+	data
+		data for transmission
+	length
+		data length
+return
+	status
+*/
+static int
+ilitek_i2c_write(
+	struct i2c_client *client,
+	uint8_t cmd,
+	uint8_t *data,
+	int length)
+{
+	int ret;
+    struct i2c_msg msgs[] = {
+		{.addr = client->addr, .flags = 0, .len = 1, .buf = &cmd,},
+    };
+
+    ret = ilitek_i2c_transfer(client, msgs, 1);
+	if(ret < 0){
+		printk(ILITEK_ERROR_LEVEL "%s, i2c write error, ret %d\n", __func__, ret);
+	}
+	return ret;
+}
+/*
+description
+	read data from i2c device
+parameter
+	client
+		i2c client data
+	addr
+		i2c address
+	data
+		data for transmission
+	length
+		data length
+return
+	status
+*/
+static int
+ilitek_i2c_only_read(
+	struct i2c_client *client,
+	uint8_t *data,
+	int length)
+{
+	int ret;
+    struct i2c_msg msgs[] = {
+		{.addr = client->addr, .flags = I2C_M_RD, .len = length, .buf = data,}
+    };
+
+    ret = ilitek_i2c_transfer(client, msgs, 1);
+	if(ret < 0){
+		printk(ILITEK_ERROR_LEVEL "%s, i2c read error, ret %d\n", __func__, ret);
+	}
+	return ret;
+}
+
+/*
+description
+	process i2c data and then report to kernel
+parameters
+	none
+return
+	status
+*/
+static int ilitek_i2c_process_and_report(void)
+{
+#ifdef ROTATE_FLAG
+	int org_x = 0, org_y = 0;
+#endif
+	int i, len = 0, ret, x = 0, y = 0,key,mult_tp_id,packet = 0,tp_status = 0, j, release_flag[10]={0};
+#ifdef VIRTUAL_KEY_PAD
+	unsigned char key_id = 0,key_flag= 1;
+#endif
+	static unsigned char last_id = 0;
+	struct input_dev *input = i2c.input_dev;
+    unsigned char buf[64]={0};
+	unsigned char tp_id,max_point=6;
+	unsigned char release_counter = 0;
+	if(i2c.report_status == 0){
+		return 1;
+	}
+
+	//mutli-touch for protocol 3.1
+	if((i2c.protocol_ver & 0x300) == 0x300){
+		#ifdef TRANSFER_LIMIT
+		int buffer_flag[10] = {0}, cmd_flag=0;
+		ret = ilitek_i2c_read(i2c.client, ILITEK_TP_CMD_TOUCH_STATUS, buf, 2);
+		cmd_flag = 1;
+		//read touch information
+		for(i = 0; i < 8; i++){
+			release_flag[i] = (buf[0] & (0x1 << i))>>i;
+			}
+		release_flag[8] = buf[1] & 0x1;
+		release_flag[9] = (buf[1] & 0x2) >> 1;
+		for(i = 0; i < 10; i++)
+			DBG("release_flag[%d]=%d,buffer[%d]=%d",i,release_flag[i],i,buffer_flag[i]);
+		DBG("\n");
+
+		for(i = 0; i < 10; i++){
+			if(release_flag[i] == 1 ){
+				if(i<6)
+					j = (1+i*5)/8;
+				else
+					j = ((1+i*5)+1)/8;
+				DBG("i=%d,j=%d,cmd_flag=%d,command[%d]=%d\n",i,j,cmd_flag,i,buffer_flag[j]);
+				if((((j+1)*8 > 2+i*5)||i==6) && buffer_flag[j] == 0){
+
+					if(buffer_flag[j-1] == 1 || j==0){//
+						cmd_flag = 1;
+					}
+					if(cmd_flag == 1){
+						ret = ilitek_i2c_only_read(i2c.client, buf+(j*8), 8);
+						buffer_flag[j] = 1;
+					}
+					else{
+						ret = ilitek_i2c_write(i2c.client, ILITEK_TP_CMD_READ_DATA+j, buf+(j*8), 8);
+						udelay(10);
+						ret = ilitek_i2c_only_read(i2c.client, buf+(j*8), 8);
+						buffer_flag[j] = 1;
+						cmd_flag = 1;
+					}
+				}
+				if(buffer_flag[j] == 0)
+					cmd_flag = 0;
+				j++;
+				//msleep(1);
+				if( (j*8 < 6+i*5) && buffer_flag[j] == 0){
+					ret = ilitek_i2c_only_read(i2c.client, buf+(j*8), 8);
+					buffer_flag[j] = 1;
+					cmd_flag = 1;
+				}
+				max_point = i+1;
+			}else
+				 cmd_flag = 0;
+		}
+		//buf[31] is reserved so the data is moved forward.
+		for(i = 31; i < 53; i++){
+			buf[i] = buf[i+1];
+			//printk("buf[%d]=0x%x\n",i,buf[i]);
+		}
+		packet = buf[0]+buf[1];
+		#else
+		ret = ilitek_i2c_read(i2c.client, ILITEK_TP_CMD_READ_DATA, buf, 31);
+		if(ret < 0){
+			return ret;
+		}
+		packet = buf[0];
+		ret = 1;
+		if (packet == 2){
+			ret = ilitek_i2c_only_read(i2c.client, buf+31, 20);
+			if(ret < 0){
+				return ret;
+			}
+			max_point = 10;
+		}
+		#endif
+		DBG("max_point=%d\n",max_point);
+		// read touch point
+		for(i = 0; i < max_point; i++){
+			tp_status = buf[i*5+1] >> 7;
+			#ifndef ROTATE_FLAG
+			x = (((buf[i*5+1] & 0x3F) << 8) + buf[i*5+2]);
+			y = (buf[i*5+3] << 8) + buf[i*5+4];
+			#else
+			org_x = (((buf[i*5+1] & 0x3F) << 8) + buf[i*5+2]);
+			org_y = (buf[i*5+3] << 8) + buf[i*5+4];
+			//x = i2c.max_y - org_y + 1;
+			//y = org_x + 1;
+			x = org_y + 1;
+			y = i2c.max_x - org_x + 1;
+			#endif
+			if(tp_status){
+				if(i2c.keyflag == 0){
+					for(j = 0; j <= i2c.keycount; j++){
+						if((x >= i2c.keyinfo[j].x && x <= i2c.keyinfo[j].x + i2c.key_xlen) && (y >= i2c.keyinfo[j].y && y <= i2c.keyinfo[j].y + i2c.key_ylen)){
+							input_report_key(input,  i2c.keyinfo[j].id, 1);
+							i2c.keyinfo[j].status = 1;
+							touch_key_hold_press = 1;
+							release_flag[0] = 1;
+							DBG("Key, Keydown ID=%d, X=%d, Y=%d, key_status=%d,keyflag=%d\n", i2c.keyinfo[j].id ,x ,y , i2c.keyinfo[j].status,i2c.keyflag);
+							break;
+						}
+					}
+				}
+				if(touch_key_hold_press == 0){
+					input_report_key(i2c.input_dev, BTN_TOUCH,  1);
+					input_event(i2c.input_dev, EV_ABS, ABS_MT_TRACKING_ID, i);
+					input_event(i2c.input_dev, EV_ABS, ABS_MT_POSITION_X, x);
+					input_event(i2c.input_dev, EV_ABS, ABS_MT_POSITION_Y, y);
+					input_event(i2c.input_dev, EV_ABS, ABS_MT_TOUCH_MAJOR, 1);
+					input_mt_sync(i2c.input_dev);
+					release_flag[i] = 1;
+					i2c.keyflag = 1;
+					DBG("Point, ID=%02X, X=%04d, Y=%04d,release_flag[%d]=%d,tp_status=%d,keyflag=%d\n",i, x,y,i,release_flag[i],tp_status,i2c.keyflag);
+				}
+				if(touch_key_hold_press == 1){
+					for(j = 0; j <= i2c.keycount; j++){
+						if((i2c.keyinfo[j].status == 1) && (x < i2c.keyinfo[j].x || x > i2c.keyinfo[j].x + i2c.key_xlen || y < i2c.keyinfo[j].y || y > i2c.keyinfo[j].y + i2c.key_ylen)){
+							input_report_key(input,  i2c.keyinfo[j].id, 0);
+							i2c.keyinfo[j].status = 0;
+							touch_key_hold_press = 0;
+							DBG("Key, Keyout ID=%d, X=%d, Y=%d, key_status=%d\n", i2c.keyinfo[j].id ,x ,y , i2c.keyinfo[j].status);
+							break;
+						}
+					}
+				}
+
+				ret = 0;
+			}
+			else{
+				release_flag[i] = 0;
+				DBG("Point, ID=%02X, X=%04d, Y=%04d,release_flag[%d]=%d,tp_status=%d\n",i, x,y,i,release_flag[i],tp_status);
+				input_mt_sync(i2c.input_dev);
+			}
+
+		}
+		if(packet == 0 ){
+			i2c.keyflag = 0;
+			input_report_key(i2c.input_dev, BTN_TOUCH,  0);
+			input_mt_sync(i2c.input_dev);
+		}
+		else{
+			for(i = 0; i < max_point; i++){
+				if(release_flag[i] == 0)
+					release_counter++;
+			}
+			if(release_counter == max_point ){
+				input_report_key(i2c.input_dev, BTN_TOUCH,  0);
+				input_mt_sync(i2c.input_dev);
+				i2c.keyflag = 0;
+				if (touch_key_hold_press == 1){
+					for(i = 0; i < i2c.keycount; i++){
+						if(i2c.keyinfo[i].status){
+							input_report_key(input, i2c.keyinfo[i].id, 0);
+							i2c.keyinfo[i].status = 0;
+							touch_key_hold_press = 0;
+							DBG("Key, Keyup ID=%d, X=%d, Y=%d, key_status=%d, touch_key_hold_press=%d\n", i2c.keyinfo[i].id ,x ,y , i2c.keyinfo[i].status, touch_key_hold_press);
+						}
+					}
+				}
+			}
+			DBG("release_counter=%d,packet=%d\n",release_counter,packet);
+		}
+	}
+	// multipoint process
+	else if((i2c.protocol_ver & 0x200) == 0x200){
+	    // read i2c data from device
+		ret = ilitek_i2c_read(i2c.client, ILITEK_TP_CMD_READ_DATA, buf, 1);
+		if(ret < 0){
+			return ret;
+		}
+		len = buf[0];
+		ret = 1;
+		if(len>20)
+			return ret;
+		// read touch point
+		for(i=0; i<len; i++){
+			// parse point
+			if(ilitek_i2c_write(i2c.client, ILITEK_TP_CMD_READ_SUB_DATA, buf, 5)){
+				udelay(100);
+				ilitek_i2c_only_read(i2c.client,buf,5);
+			#ifndef ROTATE_FLAG
+				x = (((int)buf[1]) << 8) + buf[2];
+				y = (((int)buf[3]) << 8) + buf[4];
+			#else
+				org_x = (((int)buf[1]) << 8) + buf[2];
+				org_y = (((int)buf[3]) << 8) + buf[4];
+				//x = i2c.max_y - org_y + 1;
+				//y = org_x + 1;
+				x = org_y + 1;
+				y = i2c.max_x - org_x + 1;
+			#endif
+				mult_tp_id = buf[0];
+				switch ((mult_tp_id & 0xC0)){
+#ifdef VIRTUAL_KEY_PAD
+					case RELEASE_KEY:
+						//release key
+						DBG("Key: Release\n");
+						for(key=0; key<NUM_TOUCH_KEY_CODES; key++){
+							if(touch_key_press[key]){
+								input_report_key(input, touch_key_code[key], 0);
+								touch_key_press[key] = 0;
+								DBG("Key:%d ID:%d release\n", touch_key_code[key], key);
+								DBG(ILITEK_DEBUG_LEVEL "%s key release, %X, %d, %d\n", __func__, buf[0], x, y);
+							}
+							touch_key_hold_press=0;
+							//ret = 1;// stop timer interrupt
+						}
+
+						break;
+
+					case TOUCH_KEY:
+						//touch key
+						#if VIRTUAL_FUN==VIRTUAL_FUN_1
+						key_id = buf[1] - 1;
+						#endif
+						#if VIRTUAL_FUN==VIRTUAL_FUN_2
+						if (abs(jiffies-touch_time) < msecs_to_jiffies(BTN_DELAY_TIME))
+							break;
+						//DBG("Key: Enter\n");
+						x = (((int)buf[4]) << 8) + buf[3];
+
+						//printk("%s,x=%d\n",__func__,x);
+						if (x > KEYPAD01_X1 && x<KEYPAD01_X2)		// btn 1
+							key_id=0;
+						else if (x > KEYPAD02_X1 && x<KEYPAD02_X2)	// btn 2
+							key_id=1;
+						else if (x > KEYPAD03_X1 && x<KEYPAD03_X2)	// btn 3
+							key_id=2;
+						else if (x > KEYPAD04_X1 && x<KEYPAD04_X2)	// btn 4
+							key_id=3;
+						else
+							key_flag=0;
+						#endif
+						if((touch_key_press[key_id] == 0) && (touch_key_hold_press == 0 && key_flag)){
+							input_report_key(input, touch_key_code[key_id], 1);
+							touch_key_press[key_id] = 1;
+							touch_key_hold_press = 1;
+							DBG("Key:%d ID:%d press x=%d,touch_key_hold_press=%d,key_flag=%d\n", touch_key_code[key_id], key_id,x,touch_key_hold_press,key_flag);
+						}
+						break;
+#endif
+					case TOUCH_POINT:
+
+#ifdef VIRTUAL_KEY_PAD
+						#if VIRTUAL_FUN==VIRTUAL_FUN_3
+						if((buf[0] & 0x80) != 0 && ( y > KEYPAD_Y) && i==0){
+							DBG("%s,touch key\n",__func__);
+							if((x > KEYPAD01_X1) && (x < KEYPAD01_X2)){
+								input_report_key(input,  touch_key_code[0], 1);
+								touch_key_press[0] = 1;
+								touch_key_hold_press = 1;
+								DBG("%s,touch key=0 ,touch_key_hold_press=%d\n",__func__,touch_key_hold_press);
+							}
+							else if((x > KEYPAD02_X1) && (x < KEYPAD02_X2)){
+								input_report_key(input, touch_key_code[1], 1);
+								touch_key_press[1] = 1;
+								touch_key_hold_press = 1;
+								DBG("%s,touch key=1 ,touch_key_hold_press=%d\n",__func__,touch_key_hold_press);
+							}
+							else if((x > KEYPAD03_X1) && (x < KEYPAD03_X2)){
+								input_report_key(input, touch_key_code[2], 1);
+								touch_key_press[2] = 1;
+								touch_key_hold_press = 1;
+								DBG("%s,touch key=2 ,touch_key_hold_press=%d\n",__func__,touch_key_hold_press);
+							}
+							else {
+								input_report_key(input, touch_key_code[3], 1);
+								touch_key_press[3] = 1;
+								touch_key_hold_press = 1;
+								DBG("%s,touch key=3 ,touch_key_hold_press=%d\n",__func__,touch_key_hold_press);
+							}
+
+						}
+						if((buf[0] & 0x80) != 0 && y <= KEYPAD_Y)
+							touch_key_hold_press=0;
+						if((buf[0] & 0x80) != 0 && y <= KEYPAD_Y)
+						#endif
+#endif
+						{
+						// report to android system
+						DBG("Point, ID=%02X, X=%04d, Y=%04d,touch_key_hold_press=%d\n",buf[0]  & 0x3F, x,y,touch_key_hold_press);
+						input_report_key(input, BTN_TOUCH,  1);
+						input_event(input, EV_ABS, ABS_MT_TRACKING_ID, (buf[0] & 0x3F)-1);
+						input_event(input, EV_ABS, ABS_MT_POSITION_X, x+1);
+						input_event(input, EV_ABS, ABS_MT_POSITION_Y, y+1);
+						input_event(input, EV_ABS, ABS_MT_TOUCH_MAJOR, 1);
+						input_mt_sync(input);
+						ret=0;
+						}
+						break;
+
+					case RELEASE_POINT:
+						if (touch_key_hold_press !=0 && i==0){
+							for(key=0; key<NUM_TOUCH_KEY_CODES; key++){
+								if(touch_key_press[key]){
+									input_report_key(input, touch_key_code[key], 0);
+									touch_key_press[key] = 0;
+									DBG("Key:%d ID:%d release\n", touch_key_code[key], key);
+									DBG(ILITEK_DEBUG_LEVEL "%s key release, %X, %d, %d,touch_key_hold_press=%d\n", __func__, buf[0], x, y,touch_key_hold_press);
+								}
+								touch_key_hold_press=0;
+								//ret = 1;// stop timer interrupt
+							}
+						}
+						// release point
+						#ifdef CLOCK_INTERRUPT
+						release_counter++;
+						if (release_counter == len){
+							input_report_key(input, BTN_TOUCH,  0);
+							input_mt_sync(input);
+						}
+						#endif
+						//ret=1;
+						break;
+
+					default:
+						break;
+				}
+			}
+		}
+		// release point
+		if(len == 0){
+			DBG("Release3, ID=%02X, X=%04d, Y=%04d\n",buf[0]  & 0x3F, x,y);
+			input_report_key(input, BTN_TOUCH,  0);
+			//input_event(input, EV_ABS, ABS_MT_TOUCH_MAJOR, 0);
+			input_mt_sync(input);
+			//ret = 1;
+			if (touch_key_hold_press !=0){
+				for(key=0; key<NUM_TOUCH_KEY_CODES; key++){
+					if(touch_key_press[key]){
+						input_report_key(input, touch_key_code[key], 0);
+						touch_key_press[key] = 0;
+						DBG("Key:%d ID:%d release\n", touch_key_code[key], key);
+						DBG(ILITEK_DEBUG_LEVEL "%s key release, %X, %d, %d\n", __func__, buf[0], x, y);
+					}
+					touch_key_hold_press=0;
+					//ret = 1;// stop timer interrupt
+				}
+			}
+		}
+		DBG("%s,ret=%d\n",__func__,ret);
+	}
+
+	else{
+	    // read i2c data from device
+		ret = ilitek_i2c_read(i2c.client, ILITEK_TP_CMD_READ_DATA, buf, 9);
+		if(ret < 0){
+			return ret;
+		}
+		if(buf[0] > 20){
+			ret = 1;
+			return ret ;
+		}
+		// parse point
+		ret = 0;
+
+
+		tp_id = buf[0];
+		if (Report_Flag!=0){
+			printk("%s(%d):",__func__,__LINE__);
+			for (i=0;i<9;i++)
+				DBG("%02X,",buf[i]);
+			DBG("\n");
+		}
+		switch (tp_id)
+		{
+			case 0://release point
+#ifdef VIRTUAL_KEY_PAD
+				if (touch_key_hold_press !=0)
+				{
+					for(key=0; key<NUM_TOUCH_KEY_CODES; key++){
+						if(touch_key_press[key]){
+							//input_report_key(input, touch_key_code[key], 0);
+							touch_key_press[key] = 0;
+							DBG("Key:%d ID:%d release\n", touch_key_code[key], key);
+						}
+					}
+					touch_key_hold_press = 0;
+				}
+				else
+#endif
+				{
+					for(i=0; i<i2c.max_tp; i++){
+						// check
+						if (!(last_id & (1<<i)))
+							continue;
+
+						#ifndef ROTATE_FLAG
+						x = (int)buf[1 + (i * 4)] + ((int)buf[2 + (i * 4)] * 256);
+						y = (int)buf[3 + (i * 4)] + ((int)buf[4 + (i * 4)] * 256);
+						#else
+						org_x = (int)buf[1 + (i * 4)] + ((int)buf[2 + (i * 4)] * 256);
+						org_y = (int)buf[3 + (i * 4)] + ((int)buf[4 + (i * 4)] * 256);
+						//x = i2c.max_y - org_y + 1;
+						//y = org_x + 1;
+						x = org_y + 1;
+						y = i2c.max_x - org_x + 1;
+						#endif
+						touch_key_hold_press=2; //2: into available area
+						input_report_key(input, BTN_TOUCH,  1);
+						input_event(i2c.input_dev, EV_ABS, ABS_MT_TRACKING_ID, i);
+						input_event(i2c.input_dev, EV_ABS, ABS_MT_POSITION_X, x+1);
+						input_event(i2c.input_dev, EV_ABS, ABS_MT_POSITION_Y, y+1);
+						input_event(i2c.input_dev, EV_ABS, ABS_MT_TOUCH_MAJOR, 1);
+						input_mt_sync(i2c.input_dev);
+						DBG("Last Point[%d]= %d, %d\n", buf[0]&0x3F, x, y);
+						last_id=0;
+					}
+					input_sync(i2c.input_dev);
+					input_report_key(input, BTN_TOUCH,  0);
+					input_event(i2c.input_dev, EV_ABS, ABS_MT_TOUCH_MAJOR, 0);
+					input_mt_sync(i2c.input_dev);
+					ret = 1; // stop timer interrupt
+				}
+				break;
+#ifdef VIRTUAL_KEY_PAD
+			case 0x81:
+				if (abs(jiffies-touch_time) < msecs_to_jiffies(BTN_DELAY_TIME))
+					break;
+				DBG("Key: Enter\n");
+
+				#if VIRTUAL_FUN==VIRTUAL_FUN_1
+				key_id = buf[1] - 1;
+				#endif
+
+				#if VIRTUAL_FUN==VIRTUAL_FUN_2
+				x = (int)buf[1] + ((int)buf[2] * 256);
+				if (x > KEYPAD01_X1 && x<KEYPAD01_X2)		// btn 1
+					key_id=0;
+				else if (x > KEYPAD02_X1 && x<KEYPAD02_X2)	// btn 2
+					key_id=1;
+				else if (x > KEYPAD03_X1 && x<KEYPAD03_X2)	// btn 3
+					key_id=2;
+				else if (x > KEYPAD04_X1 && x<KEYPAD04_X2)	// btn 4
+					key_id=3;
+				else
+					key_flag=0;
+				#endif
+				input_report_abs(input, ABS_MT_TOUCH_MAJOR, 0);
+    				input_mt_sync(input);
+				if((touch_key_press[key_id] == 0) && (touch_key_hold_press == 0 && key_flag)){
+					input_report_key(input, touch_key_code[key_id], 1);
+					touch_key_press[key_id] = 1;
+					touch_key_hold_press = 1;
+					DBG("Key:%d ID:%d press\n", touch_key_code[key_id], key_id);
+				}
+				break;
+			case 0x80:
+				DBG("Key: Release\n");
+				for(key=0; key<NUM_TOUCH_KEY_CODES; key++){
+					if(touch_key_press[key]){
+						input_report_key(input, touch_key_code[key], 0);
+						touch_key_press[key] = 0;
+						DBG("Key:%d ID:%d release\n", touch_key_code[key], key);
+                   	}
+				}
+				touch_key_hold_press=0;
+				ret = 1;// stop timer interrupt
+				break;
+#endif
+			default:
+				last_id=buf[0];
+				for(i=0; i<i2c.max_tp; i++){
+					// check
+					if (!(buf[0] & (1<<i)))
+						continue;
+
+					#ifndef ROTATE_FLAG
+					x = (int)buf[1 + (i * 4)] + ((int)buf[2 + (i * 4)] * 256);
+					y = (int)buf[3 + (i * 4)] + ((int)buf[4 + (i * 4)] * 256);
+					#else
+					org_x = (int)buf[1 + (i * 4)] + ((int)buf[2 + (i * 4)] * 256);
+					org_y = (int)buf[3 + (i * 4)] + ((int)buf[4 + (i * 4)] * 256);
+					//x = i2c.max_y - org_y + 1;
+					//y = org_x + 1;
+					x = org_y + 1;
+					y = i2c.max_x - org_x + 1;
+					#endif
+#ifdef VIRTUAL_KEY_PAD
+					#if VIRTUAL_FUN==VIRTUAL_FUN_3
+					if (y > KEYPAD_Y){
+						if (abs(jiffies-touch_time) < msecs_to_jiffies(BTN_DELAY_TIME))
+							break;
+						x = (int)buf[1] + ((int)buf[2] * 256);
+						if (x > KEYPAD01_X1 && x<KEYPAD01_X2)		// btn 1
+							key_id=0;
+						else if (x > KEYPAD02_X1 && x<KEYPAD02_X2)	// btn 2
+							key_id=1;
+						else if (x > KEYPAD03_X1 && x<KEYPAD03_X2)	// btn 3
+							key_id=2;
+						else if (x > KEYPAD04_X1 && x < KEYPAD04_X2)	// btn 4
+							key_id=3;
+						else
+							key_flag=0;
+						if (touch_key_hold_press==2){
+							input_report_key(input, BTN_TOUCH,  0);
+							input_event(i2c.input_dev, EV_ABS, ABS_MT_TOUCH_MAJOR, 0);
+							input_mt_sync(i2c.input_dev);
+							touch_key_hold_press=0;
+						}
+						if((touch_key_press[key_id] == 0) && (touch_key_hold_press == 0 && key_flag)){
+							//input_report_key(input, touch_key_code[key_id], 1);
+							touch_key_press[key_id] = 1;
+							touch_key_hold_press = 1;
+							DBG("Key:%d ID:%d press\n", touch_key_code[key_id], key_id);
+						}
+					}
+					else if (touch_key_hold_press){
+						for(key=0; key<NUM_TOUCH_KEY_CODES; key++){
+							if(touch_key_press[key]){
+								//input_report_key(input, touch_key_code[key], 0);
+								touch_key_press[key] = 0;
+								DBG("Key:%d ID:%d release\n", touch_key_code[key], key);
+							}
+						}
+						touch_key_hold_press = 0;
+					}
+					else
+					#endif
+					touch_time=jiffies + msecs_to_jiffies(BTN_DELAY_TIME);
+#endif
+					{
+						touch_key_hold_press=2; //2: into available area
+						input_report_key(input, BTN_TOUCH,  1);
+						input_event(i2c.input_dev, EV_ABS, ABS_MT_TRACKING_ID, i);
+						input_event(i2c.input_dev, EV_ABS, ABS_MT_POSITION_X, x+1);
+						input_event(i2c.input_dev, EV_ABS, ABS_MT_POSITION_Y, y+1);
+						input_event(i2c.input_dev, EV_ABS, ABS_MT_TOUCH_MAJOR, 1);
+						input_mt_sync(i2c.input_dev);
+						DBG("Point[%d]= %d, %d\n", buf[0]&0x3F, x, y);
+					}
+
+				}
+				break;
+		}
+	}
+	input_sync(i2c.input_dev);
+    return ret;
+}
+
+static void ilitek_i2c_timer(unsigned long handle)
+{
+    struct i2c_data *priv = (void *)handle;
+
+    schedule_work(&priv->irq_work);
+}
+/*
+description
+	work queue function for irq use
+parameter
+	work
+		work queue
+return
+	nothing
+*/
+static void
+ilitek_i2c_irq_work_queue_func(
+	struct work_struct *work)
+{
+	int ret;
+#ifndef CLOCK_INTERRUPT
+	struct i2c_data *priv =
+		container_of(work, struct i2c_data, irq_work);
+#endif
+	ret = ilitek_i2c_process_and_report();
+	DBG("%s,enter\n",__func__);
+#ifdef CLOCK_INTERRUPT
+	ilitek_i2c_irq_enable();
+#else
+    if (ret == 0){
+		if (!i2c.stop_polling)
+			mod_timer(&priv->timer, jiffies + msecs_to_jiffies(0));
+	}
+    else if (ret == 1){
+		if (!i2c.stop_polling){
+			ilitek_i2c_irq_enable();
+		}
+		DBG("stop_polling\n");
+	}
+	else if(ret < 0){
+		msleep(100);
+		DBG(ILITEK_ERROR_LEVEL "%s, process error\n", __func__);
+		ilitek_i2c_irq_enable();
+    }
+#endif
+}
+
+/*
+description
+	i2c interrupt service routine
+parameters
+	irq
+		interrupt number
+	dev_id
+		device parameter
+return
+	return status
+*/
+static irqreturn_t
+ilitek_i2c_isr(
+	int irq, void *dev_id)
+{
+	#ifndef CLOCK_INTERRUPT
+		if(i2c.irq_status == 1 ){
+			disable_irq_nosync(i2c.client->irq);
+			DBG("disable nosync\n");
+			i2c.irq_status = 0;
+		}
+	#endif
+	if(update_Flag == 1){
+		int_Flag = 1;
+	}
+	else{
+		queue_work(i2c.irq_work_queue, &i2c.irq_work);
+	}
+	return IRQ_HANDLED;
+}
+
+/*
+description
+        i2c polling thread
+parameters
+        arg
+			arguments
+return
+        return status
+*/
+static int
+ilitek_i2c_polling_thread(
+	void *arg)
+{
+
+	int ret=0;
+	// check input parameter
+	DBG(ILITEK_DEBUG_LEVEL "%s, enter\n", __func__);
+
+	// mainloop
+	while(1){
+		// check whether we should exit or not
+		if(kthread_should_stop()){
+			printk(ILITEK_DEBUG_LEVEL "%s, stop\n", __func__);
+			break;
+		}
+
+		// this delay will influence the CPU usage and response latency
+		msleep(10);
+
+		// when i2c is in suspend or shutdown mode, we do nothing
+		if(i2c.stop_polling){
+			msleep(1000);
+			continue;
+		}
+
+		// read i2c data
+		if(ilitek_i2c_process_and_report() < 0){
+			msleep(3000);
+			printk(ILITEK_ERROR_LEVEL "%s, process error\n", __func__);
+		}
+	}
+	return ret;
+}
+
+/*
+description
+	i2c early suspend function
+parameters
+	h
+	early suspend pointer
+return
+	nothing
+*/
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void ilitek_i2c_early_suspend(struct early_suspend *h)
+{
+	ilitek_i2c_suspend(i2c.client, PMSG_SUSPEND);
+	printk("%s\n", __func__);
+}
+#endif
+
+/*
+description
+	i2c later resume function
+parameters
+	h
+	early suspend pointer
+return
+	nothing
+*/
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void ilitek_i2c_late_resume(struct early_suspend *h)
+{
+	ilitek_i2c_resume(i2c.client);
+	printk("%s\n", __func__);
+}
+#endif
+/*
+description
+        i2c irq enable function
+*/
+static void ilitek_i2c_irq_enable(void)
+{
+	if (i2c.irq_status == 0){
+		i2c.irq_status = 1;
+		enable_irq(i2c.client->irq);
+		DBG("enable\n");
+
+	}
+	else
+		DBG("no enable\n");
+}
+/*
+description
+        i2c irq disable function
+*/
+static void ilitek_i2c_irq_disable(void)
+{
+	if (i2c.irq_status == 1){
+		i2c.irq_status = 0;
+		disable_irq(i2c.client->irq);
+		DBG("disable\n");
+	}
+	else
+		DBG("no disable\n");
+}
+
+/*
+description
+        i2c suspend function
+parameters
+        device
+return
+        return status
+*/
+
+static int ilitek_i2c_suspend(struct device *dev)
+{
+	if(i2c.valid_irq_request != 0){
+		ilitek_i2c_irq_disable();
+	}
+	else{
+		i2c.stop_polling = 1;
+		printk(ILITEK_DEBUG_LEVEL "%s, stop i2c thread polling\n", __func__);
+  	}
+	return 0;
+}
+
+/*
+description
+        i2c resume function
+parameters
+        device
+return
+        return status
+*/
+static int ilitek_i2c_resume(struct device *dev)
+{
+        if(i2c.valid_irq_request != 0){
+			ilitek_i2c_irq_enable();
+        }
+	else{
+		i2c.stop_polling = 0;
+        	printk(ILITEK_DEBUG_LEVEL "%s, start i2c thread polling\n", __func__);
+	}
+	return 0;
+}
+
+/*
+description
+	reset touch ic
+prarmeters
+	reset_pin
+	    reset pin
+return
+	status
+*/
+static int ilitek_i2c_reset(void)
+{
+	int ret = 0;
+	#ifndef SET_RESET
+	static unsigned char buffer[64]={0};
+	struct i2c_msg msgs[] = {
+		{.addr = i2c.client->addr, .flags = 0, .len = 1, .buf = buffer,}
+    };
+	buffer[0] = 0x60;
+	ret = ilitek_i2c_transfer(i2c.client, msgs, 1);
+	#else
+	/*
+
+	____         ___________
+		|_______|
+		   1ms      100ms
+	*/
+	#endif
+	msleep(100);
+	return ret;
+}
+
+/*
+description
+        i2c shutdown function
+parameters
+        client
+                i2c client data
+return
+        nothing
+*/
+static void
+ilitek_i2c_shutdown(
+        struct i2c_client *client)
+{
+	printk(ILITEK_DEBUG_LEVEL "%s\n", __func__);
+	i2c.stop_polling = 1;
+}
+
+/*
+description
+	when adapter detects the i2c device, this function will be invoked.
+parameters
+	client
+		i2c client data
+	id
+		i2c data
+return
+	status
+*/
+static int
+ilitek_i2c_probe(
+	struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	struct device_node *np = client->dev.of_node;
+	int gpio_rst;
+
+	// register i2c device
+	int ret = 0;
+
+	if (!np)
+		return -ENODEV;
+
+	gpio_rst = of_get_named_gpio(np, "reset-gpios", 0);
+	if (gpio_is_valid(gpio_rst)) {
+		ret = devm_gpio_request_one(&client->dev, gpio_rst, GPIOF_OUT_INIT_HIGH, "gpio_rst");
+		if (ret < 0) {
+			printk(ILITEK_ERROR_LEVEL "%s, request reset gpio failed; %d\n", __func__, ret);
+			return ret;
+		}
+		gpio_set_value(gpio_rst, 0);
+		msleep(1); // at least 50us
+		gpio_set_value(gpio_rst, 1);
+		msleep(100);
+		printk(ILITEK_DEBUG_LEVEL "%s, controller reset completed\n", __func__);
+
+	} else {
+		printk(ILITEK_DEBUG_LEVEL "%s, skipping reset due to missing pin\n", __func__);
+	}
+
+	// allocate character device driver buffer
+	ret = alloc_chrdev_region(&dev.devno, 0, 1, ILITEK_FILE_DRIVER_NAME);
+	if(ret){
+		printk(ILITEK_ERROR_LEVEL "%s, can't allocate chrdev\n", __func__);
+	return ret;
+	}
+	printk(ILITEK_DEBUG_LEVEL "%s, register chrdev(%d, %d)\n", __func__, MAJOR(dev.devno), MINOR(dev.devno));
+
+	// initialize character device driver
+	cdev_init(&dev.cdev, &ilitek_fops);
+	dev.cdev.owner = THIS_MODULE;
+	ret = cdev_add(&dev.cdev, dev.devno, 1);
+	if(ret < 0){
+		printk(ILITEK_ERROR_LEVEL "%s, add character device error, ret %d\n", __func__, ret);
+	return ret;
+	}
+	dev.class = class_create(THIS_MODULE, ILITEK_FILE_DRIVER_NAME);
+	if(IS_ERR(dev.class)){
+		printk(ILITEK_ERROR_LEVEL "%s, create class, error\n", __func__);
+	return ret;
+	}
+	device_create(dev.class, NULL, dev.devno, NULL, "ilitek_ctrl");
+	Report_Flag = 0;
+	if(!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)){
+		printk(ILITEK_ERROR_LEVEL "%s, I2C_FUNC_I2C not supported\n", __func__);
+		return -1;
+	}
+	i2c.client = client;
+	printk(ILITEK_DEBUG_LEVEL "%s, i2c new style format\n", __func__);
+	printk("%s, IRQ: 0x%X\n", __func__, client->irq);
+
+	ret = ilitek_i2c_register_device();
+	if(ret < 0){
+		printk(ILITEK_ERROR_LEVEL "%s, register i2c device, error\n", __func__);
+		return ret;
+	}
+	return 0;
+}
+
+/*
+description
+	when the i2c device want to detach from adapter, this function will be invoked.
+parameters
+	client
+		i2c client data
+return
+	status
+*/
+static int
+ilitek_i2c_remove(
+	struct i2c_client *client)
+{
+	printk( "%s\n", __func__);
+	i2c.stop_polling = 1;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&i2c.early_suspend);
+#endif
+	// delete i2c driver
+	if(i2c.client->irq != 0){
+		if(i2c.valid_irq_request != 0){
+			free_irq(i2c.client->irq, &i2c);
+			printk(ILITEK_DEBUG_LEVEL "%s, free irq\n", __func__);
+			if(i2c.irq_work_queue){
+				destroy_workqueue(i2c.irq_work_queue);
+				printk(ILITEK_DEBUG_LEVEL "%s, destory work queue\n", __func__);
+			}
+		}
+	}
+	else{
+		if(i2c.thread != NULL){
+			kthread_stop(i2c.thread);
+			printk(ILITEK_DEBUG_LEVEL "%s, stop i2c thread\n", __func__);
+		}
+	}
+	if(i2c.valid_input_register != 0){
+		input_unregister_device(i2c.input_dev);
+		printk(ILITEK_DEBUG_LEVEL "%s, unregister i2c input device\n", __func__);
+	}
+
+	// delete character device driver
+	cdev_del(&dev.cdev);
+	unregister_chrdev_region(dev.devno, 1);
+	device_destroy(dev.class, dev.devno);
+	class_destroy(dev.class);
+	printk(ILITEK_DEBUG_LEVEL "%s\n", __func__);
+	return 0;
+}
+
+/*
+description
+	read data from i2c device with delay between cmd & return data
+parameter
+	client
+		i2c client data
+	addr
+		i2c address
+	data
+		data for transmission
+	length
+		data length
+return
+	status
+*/
+static int
+ilitek_i2c_read_info(
+	struct i2c_client *client,
+	uint8_t cmd,
+	uint8_t *data,
+	int length)
+{
+	int ret;
+	struct i2c_msg msgs_cmd[] = {
+	{.addr = client->addr, .flags = 0, .len = 1, .buf = &cmd,},
+	};
+
+	struct i2c_msg msgs_ret[] = {
+	{.addr = client->addr, .flags = I2C_M_RD, .len = length, .buf = data,}
+	};
+
+	ret = ilitek_i2c_transfer(client, msgs_cmd, 1);
+	if(ret < 0){
+		printk(ILITEK_ERROR_LEVEL "%s, i2c read error, ret %d\n", __func__, ret);
+	}
+
+	msleep(10);
+	ret = ilitek_i2c_transfer(client, msgs_ret, 1);
+	if(ret < 0){
+		printk(ILITEK_ERROR_LEVEL "%s, i2c read error, ret %d\n", __func__, ret);
+	}
+	return ret;
+}
+
+/*
+description
+	read touch information
+parameters
+	none
+return
+	status
+*/
+static int
+ilitek_i2c_read_tp_info(
+	void)
+{
+	int res_len, i;//,j;
+	unsigned char buf[64]={0};
+
+	// read driver version
+	printk(ILITEK_DEBUG_LEVEL "%s, Driver Version:%d.%d.%d\n",__func__,driver_information[0],driver_information[1],driver_information[2]);
+	printk(ILITEK_DEBUG_LEVEL "%s, customer information:%d.%d.%d.%d\n",__func__,driver_information[3],driver_information[4],driver_information[5],driver_information[6]);
+	printk(ILITEK_DEBUG_LEVEL "%s, Engineer id:%d\n",__func__,driver_information[6]);
+	// read firmware version
+	if(ilitek_i2c_read_info(i2c.client, ILITEK_TP_CMD_GET_FIRMWARE_VERSION, buf, 4) < 0){
+		return -1;
+	}
+	printk(ILITEK_DEBUG_LEVEL "%s, firmware version %d.%d.%d.%d\n", __func__, buf[0], buf[1], buf[2], buf[3]);
+
+	// read protocol version
+	res_len = 6;
+	if(ilitek_i2c_read_info(i2c.client, ILITEK_TP_CMD_GET_PROTOCOL_VERSION, buf, 2) < 0){
+		return -1;
+	}
+	i2c.protocol_ver = (((int)buf[0]) << 8) + buf[1];
+	printk(ILITEK_DEBUG_LEVEL "%s, protocol version: %d.%d\n", __func__, buf[0], buf[1]);
+	//if(i2c.protocol_ver == 0x200){
+	//	res_len = 8;
+	//}
+	//else if(i2c.protocol_ver == 0x300){
+		res_len = 10;
+	//}
+
+    // read touch resolution
+	i2c.max_tp = 2;
+	#ifdef TRANSFER_LIMIT
+ 	if(ilitek_i2c_read_info(i2c.client, ILITEK_TP_CMD_GET_RESOLUTION, buf, 8) < 0){
+		return -1;
+	}
+	if(ilitek_i2c_only_read(i2c.client, buf+8, 2) < 0){
+		return -1;
+	}
+	#else
+	if(ilitek_i2c_read_info(i2c.client, ILITEK_TP_CMD_GET_RESOLUTION, buf, res_len) < 0){
+		return -1;
+	}
+	#endif
+
+	//if(i2c.protocol_ver == 0x200){
+	//	// maximum touch point
+	//	i2c.max_tp = buf[6];
+	//	// maximum button number
+	//	i2c.max_btn = buf[7];
+	//}
+	//else if(i2c.protocol_ver & 0x300) == 0x300){
+		// maximum touch point
+		i2c.max_tp = buf[6];
+		// maximum button number
+		i2c.max_btn = buf[7];
+		// key count
+		i2c.keycount = buf[8];
+	//}
+
+	// calculate the resolution for x and y direction
+	i2c.max_x = buf[0];
+	i2c.max_x+= ((int)buf[1]) * 256;
+	i2c.max_y = buf[2];
+	i2c.max_y+= ((int)buf[3]) * 256;
+	i2c.x_ch = buf[4];
+	i2c.y_ch = buf[5];
+	printk(ILITEK_DEBUG_LEVEL "%s, max_x: %d, max_y: %d, ch_x: %d, ch_y: %d\n",
+	__func__, i2c.max_x, i2c.max_y, i2c.x_ch, i2c.y_ch);
+
+	if(i2c.protocol_ver == 0x200){
+		printk(ILITEK_DEBUG_LEVEL "%s, max_tp: %d, max_btn: %d\n", __func__, i2c.max_tp, i2c.max_btn);
+	}
+	else if((i2c.protocol_ver & 0x300) == 0x300){
+		printk(ILITEK_DEBUG_LEVEL "%s, max_tp: %d, max_btn: %d, key_count: %d\n", __func__, i2c.max_tp, i2c.max_btn, i2c.keycount);
+		//get key infotmation
+		#ifdef TRANSFER_LIMIT
+		if(ilitek_i2c_read(i2c.client, ILITEK_TP_CMD_GET_KEY_INFORMATION, buf, 8) < 0){
+			return -1;
+		}
+		for(i = 1, j = 1; j < i2c.keycount ; i++){
+			if (i2c.keycount > j){
+				if(ilitek_i2c_only_read(i2c.client, buf+i*8, 8) < 0){
+					return -1;
+				}
+				j = (4+8*i)/5;
+			}
+		}
+		for(j = 29; j < (i+1)*8; j++)
+			buf[j] = buf[j+3];
+		#else
+		if(i2c.keycount){
+			if(ilitek_i2c_read(i2c.client, ILITEK_TP_CMD_GET_KEY_INFORMATION, buf, 29) < 0){
+				return -1;
+			}
+			if (i2c.keycount > 5){
+				if(ilitek_i2c_only_read(i2c.client, buf+29, 25) < 0){
+					return -1;
+				}
+			}
+		}
+		#endif
+			i2c.key_xlen = (buf[0] << 8) + buf[1];
+			i2c.key_ylen = (buf[2] << 8) + buf[3];
+			printk(ILITEK_DEBUG_LEVEL "%s, key_xlen: %d, key_ylen: %d\n", __func__, i2c.key_xlen, i2c.key_ylen);
+
+			//print key information
+			for(i = 0; i < i2c.keycount; i++){
+				i2c.keyinfo[i].id = buf[i*5+4];
+				i2c.keyinfo[i].x = (buf[i*5+5] << 8) + buf[i*5+6];
+				i2c.keyinfo[i].y = (buf[i*5+7] << 8) + buf[i*5+8];
+				i2c.keyinfo[i].status = 0;
+				printk(ILITEK_DEBUG_LEVEL "%s, key_id: %d, key_x: %d, key_y: %d, key_status: %d\n", __func__, i2c.keyinfo[i].id, i2c.keyinfo[i].x, i2c.keyinfo[i].y, i2c.keyinfo[i].status);
+			}
+
+	}
+
+	return 0;
+}
+
+/*
+description
+	register i2c device and its input device
+parameters
+	none
+return
+	status
+*/
+static int
+ilitek_i2c_register_device(
+	void)
+{
+	int ret = 0;
+	printk(ILITEK_DEBUG_LEVEL "%s, client.addr: 0x%X\n", __func__, (unsigned int)i2c.client->addr);
+	printk(ILITEK_DEBUG_LEVEL "%s, client.adapter: 0x%X\n", __func__, (unsigned int)i2c.client->adapter);
+	if((i2c.client->addr == 0) || (i2c.client->adapter == 0)){
+		printk(ILITEK_ERROR_LEVEL "%s, invalid register\n", __func__);
+		return ret;
+	}
+	// read touch parameter
+	ret = ilitek_i2c_read_tp_info();
+	if (ret < 0) {
+		printk(ILITEK_ERROR_LEVEL "%s, failed to read tp info, error = %d\n", __func__, ret);
+		return ret;
+	}
+	// register input device
+	i2c.input_dev = input_allocate_device();
+	if(i2c.input_dev == NULL){
+		printk(ILITEK_ERROR_LEVEL "%s, allocate input device, error\n", __func__);
+		return -1;
+	}
+	ilitek_set_input_param(i2c.input_dev, i2c.max_tp, i2c.max_x, i2c.max_y);
+	ret = input_register_device(i2c.input_dev);
+	if(ret){
+		printk(ILITEK_ERROR_LEVEL "%s, register input device, error\n", __func__);
+		return ret;
+	}
+	printk(ILITEK_ERROR_LEVEL "%s, register input device, success\n", __func__);
+	i2c.valid_input_register = 1;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	i2c.early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	i2c.early_suspend.suspend = ilitek_i2c_early_suspend;
+	i2c.early_suspend.resume = ilitek_i2c_late_resume;
+	register_early_suspend(&i2c.early_suspend);
+#endif
+
+	if(i2c.client->irq != 0 ){
+		i2c.irq_work_queue = create_singlethread_workqueue("ilitek_i2c_irq_queue");
+		if(i2c.irq_work_queue){
+			INIT_WORK(&i2c.irq_work, ilitek_i2c_irq_work_queue_func);
+			#ifdef CLOCK_INTERRUPT
+			if(request_irq(i2c.client->irq, ilitek_i2c_isr, IRQF_TRIGGER_FALLING , "ilitek_i2c_irq", &i2c)){
+				printk(ILITEK_ERROR_LEVEL "%s, request irq, error\n", __func__);
+				return -1;
+			}
+			else{
+				i2c.valid_irq_request = 1;
+				i2c.irq_status = 1;
+				printk(ILITEK_ERROR_LEVEL "%s, request irq(Trigger Falling), success\n", __func__);
+			}
+			#else
+			init_timer(&i2c.timer);
+			i2c.timer.data = (unsigned long)&i2c;
+			i2c.timer.function = ilitek_i2c_timer;
+			if(request_irq(i2c.client->irq, ilitek_i2c_isr, IRQF_TRIGGER_LOW, "ilitek_i2c_irq", &i2c)){
+				printk(ILITEK_ERROR_LEVEL "%s, request irq, error\n", __func__);
+			}
+			else{
+				i2c.valid_irq_request = 1;
+				i2c.irq_status = 1;
+				printk(ILITEK_ERROR_LEVEL "%s, request irq(Trigger Low), success\n", __func__);
+			}
+			#endif
+		}
+	}
+	else{
+		i2c.stop_polling = 0;
+		i2c.thread = kthread_create(ilitek_i2c_polling_thread, NULL, "ilitek_i2c_thread");
+		printk(ILITEK_ERROR_LEVEL "%s, polling mode \n", __func__);
+		if(i2c.thread == (struct task_struct*)ERR_PTR){
+			i2c.thread = NULL;
+			printk(ILITEK_ERROR_LEVEL "%s, kthread create, error\n", __func__);
+		}
+		else{
+			wake_up_process(i2c.thread);
+		}
+	}
+
+	return 0;
+}
+
+/*
+description
+	initiali function for driver to invoke.
+parameters
+
+	nothing
+return
+	status
+*/
+static int __init
+ilitek_init(
+	void)
+{
+	int ret = 0;
+	// initialize global variable
+	memset(&dev, 0, sizeof(struct dev_data));
+	memset(&i2c, 0, sizeof(struct i2c_data));
+
+	// initialize mutex object
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37)
+	init_MUTEX(&i2c.wr_sem);
+#else
+	sema_init(&i2c.wr_sem,1);
+#endif
+	i2c.wr_sem.count = 1;
+	i2c.report_status = 1;
+	ret = i2c_add_driver(&ilitek_i2c_driver);
+	if(ret == 0){
+		i2c.valid_i2c_register = 1;
+		printk(ILITEK_DEBUG_LEVEL "%s, add i2c device, success\n", __func__);
+		if(i2c.client == NULL){
+			printk(ILITEK_ERROR_LEVEL "%s, no i2c board information\n", __func__);
+		}
+	}
+	else{
+		printk(ILITEK_ERROR_LEVEL "%s, add i2c device, error\n", __func__);
+	}
+	return ret;
+}
+
+/*
+description
+	driver exit function
+parameters
+	none
+return
+	nothing
+*/
+static void __exit
+ilitek_exit(
+	void)
+{
+	printk("%s,enter\n",__func__);
+	if(i2c.valid_i2c_register != 0){
+		printk(ILITEK_DEBUG_LEVEL "%s, delete i2c driver\n", __func__);
+		i2c_del_driver(&ilitek_i2c_driver);
+		printk(ILITEK_DEBUG_LEVEL "%s, delete i2c driver\n", __func__);
+    }
+	else
+		printk(ILITEK_DEBUG_LEVEL "%s, delete i2c driver Fail\n", __func__);
+}
+
+/* set init and exit function for this module */
+module_init(ilitek_init);
+module_exit(ilitek_exit);
+
diff --git a/drivers/input/touchscreen/sitronix_i2c_touch.c b/drivers/input/touchscreen/sitronix_i2c_touch.c
new file mode 100644
index 0000000..d7f75cd
--- /dev/null
+++ b/drivers/input/touchscreen/sitronix_i2c_touch.c
@@ -0,0 +1,1810 @@
+/*
+ * drivers/input/touchscreen/sitronix_i2c_touch.c
+ *
+ * Touchscreen driver for Sitronix (I2C bus)
+ *
+ * Copyright (C) 2011 Sitronix Technology Co., Ltd.
+ *	Rudy Huang <rudy_huang@sitronix.com.tw>
+ */
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+#ifdef CONFIG_ARCH_SC8810
+#include <linux/init.h>
+#include <mach/ldo.h>
+#include <mach/eic.h>
+#endif // CONFIG_ARCH_SC8810
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/of_gpio.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif // CONFIG_HAS_EARLYSUSPEND
+#include "sitronix_i2c_touch.h"
+#ifdef SITRONIX_FW_UPGRADE_FEATURE
+#include <linux/cdev.h>
+#include <asm/uaccess.h>
+#ifdef SITRONIX_PERMISSION_THREAD
+#include <linux/fs.h>
+#include <linux/fcntl.h>
+#include <linux/syscalls.h>
+#endif // SITRONIX_PERMISSION_THREAD
+#endif // SITRONIX_FW_UPGRADE_FEATURE
+#include <linux/i2c.h>
+#include <linux/input.h>
+#ifdef SITRONIX_SUPPORT_MT_SLOT
+#include <linux/input/mt.h>
+#endif // SITRONIX_SUPPORT_MT_SLOT
+#include <linux/interrupt.h>
+#include <linux/slab.h> // to be compatible with linux kernel 3.2.15
+#include <linux/gpio.h>
+#ifdef SITRONIX_MONITOR_THREAD
+#include <linux/kthread.h>
+#endif // SITRONIX_MONITOR_THREAD
+
+#ifdef SITRONIX_MULTI_SLAVE_ADDR
+#if defined(CONFIG_MACH_OMAP4_PANDA)
+#include <plat/gpio.h>
+#endif //defined(CONFIG_MACH_OMAP4_PANDA)
+#endif // SITRONIX_MULTI_SLAVE_ADDR
+
+#define DRIVER_AUTHOR           "Sitronix, Inc."
+#define DRIVER_NAME             "sitronix"
+#define DRIVER_DESC             "Sitronix I2C touch"
+#define DRIVER_DATE             "20140916"
+#define DRIVER_MAJOR            2
+#define DRIVER_MINOR         	9
+#define DRIVER_PATCHLEVEL       15
+
+MODULE_AUTHOR("Rudy Huang <rudy_huang@sitronix.com.tw> , Petitk Kao<petitk_kao@sitronix.com.tw>");
+MODULE_DESCRIPTION("Sitronix I2C multitouch panels");
+MODULE_LICENSE("GPL");
+
+char sitronix_sensor_key_status = 0;
+struct sitronix_sensor_key_t sitronix_sensor_key_array[] = {
+	{KEY_BACK}, // bit 0
+	{KEY_HOME}, // bit 1
+	{KEY_MENU}, // bit 2
+};
+#ifdef SITRONIX_AA_KEY
+char sitronix_aa_key_status = 0;
+
+#ifdef SITRONIX_KEY_BOUNDARY_MANUAL_SPECIFY
+#define SITRONIX_TOUCH_RESOLUTION_X 480 /* max of X value in display area */
+#define SITRONIX_TOUCH_RESOLUTION_Y 854 /* max of Y value in display area */
+#define SITRONIX_TOUCH_GAP_Y	10  /* Gap between bottom of display and top of touch key */
+#define SITRONIX_TOUCH_MAX_Y 915  /* resolution of y axis of touch ic */
+struct sitronix_AA_key sitronix_aa_key_array[] = {
+	{15, 105, SITRONIX_TOUCH_RESOLUTION_Y + SITRONIX_TOUCH_GAP_Y, SITRONIX_TOUCH_MAX_Y, KEY_MENU}, /* MENU */
+	{135, 225, SITRONIX_TOUCH_RESOLUTION_Y + SITRONIX_TOUCH_GAP_Y, SITRONIX_TOUCH_MAX_Y, KEY_HOME},
+	{255, 345, SITRONIX_TOUCH_RESOLUTION_Y + SITRONIX_TOUCH_GAP_Y, SITRONIX_TOUCH_MAX_Y, KEY_BACK}, /* KEY_EXIT */
+	{375, 465, SITRONIX_TOUCH_RESOLUTION_Y + SITRONIX_TOUCH_GAP_Y, SITRONIX_TOUCH_MAX_Y, KEY_SEARCH},
+};
+#else
+#define SCALE_KEY_HIGH_Y 15
+struct sitronix_AA_key sitronix_aa_key_array[] = {
+	{0, 0, 0, 0, KEY_MENU}, /* MENU */
+	{0, 0, 0, 0, KEY_HOME},
+	{0, 0, 0, 0, KEY_BACK}, /* KEY_EXIT */
+	{0, 0, 0, 0, KEY_SEARCH},
+};
+#endif // SITRONIX_KEY_BOUNDARY_MANUAL_SPECIFY
+#endif // SITRONIX_AA_KEY
+struct sitronix_ts_data {
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	struct input_dev *keyevent_input;
+	int use_irq;
+#ifndef SITRONIX_INT_POLLING_MODE
+	struct work_struct  work;
+#else
+	struct delayed_work work;
+#endif // SITRONIX_INT_POLLING_MODE
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend early_suspend;
+#endif // CONFIG_HAS_EARLYSUSPEND
+	uint8_t fw_revision[4];
+	int resolution_x;
+	int resolution_y;
+	uint8_t max_touches;
+	uint8_t touch_protocol_type;
+	uint8_t pixel_length;
+	uint8_t chip_id;
+#ifdef SITRONIX_MONITOR_THREAD
+	uint8_t enable_monitor_thread;
+	uint8_t RawCRC_enabled;
+	int (*sitronix_mt_fp)(void *);
+#endif // SITRONIX_MONITOR_THREAD
+	uint8_t Num_X;
+	uint8_t Num_Y;
+	uint8_t sensing_mode;
+	int suspend_state;
+};
+
+static int i2cErrorCount = 0;
+
+#ifdef SITRONIX_MONITOR_THREAD
+static struct task_struct * SitronixMonitorThread = NULL;
+static int gMonitorThreadSleepInterval = 300; // 0.3 sec
+static atomic_t iMonitorThreadPostpone = ATOMIC_INIT(0);
+
+static uint8_t PreCheckData[4] ;
+static int StatusCheckCount = 0;
+static int sitronix_ts_delay_monitor_thread_start = DELAY_MONITOR_THREAD_START_PROBE; 
+#endif // SITRONIX_MONITOR_THREAD
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void sitronix_ts_early_suspend(struct early_suspend *h);
+static void sitronix_ts_late_resume(struct early_suspend *h);
+#endif // CONFIG_HAS_EARLYSUSPEND
+
+static struct sitronix_ts_data sitronix_ts_gpts = {0};
+static atomic_t sitronix_ts_irq_on = ATOMIC_INIT(0);
+static atomic_t sitronix_ts_in_int = ATOMIC_INIT(0);
+#ifdef SITRONIX_SYSFS
+static bool sitronix_ts_sysfs_created = false;
+static bool sitronix_ts_sysfs_using = false;
+#endif // SITRONIX_SYSFS
+
+static void sitronix_ts_reset_ic(void);
+static int sitronix_ts_disable_int(struct sitronix_ts_data *ts, uint8_t value);
+
+static int gpio_rst = -1;
+
+#ifdef CONFIG_ARCH_SC8810
+extern int sprd_3rdparty_gpio_tp_rst ;
+extern int sprd_3rdparty_gpio_tp_irq ;
+extern int sprd_3rdparty_tp_ldo_id ;
+extern int sprd_3rdparty_tp_ldo_level;
+
+static void sitronix_ts_pwron(void)
+{
+	LDO_SetVoltLevel(LDO_LDO_SIM2, LDO_VOLT_LEVEL0);
+	LDO_TurnOnLDO(LDO_LDO_SIM2);
+	msleep(20);
+}
+
+static int  sitronix_ts_config_pins(void)
+{
+	int irq;
+	sitronix_ts_pwron();
+	gpio_direction_input(sprd_3rdparty_gpio_tp_irq);
+	irq = sprd_alloc_eic_irq(EIC_ID_2);
+
+	sitronix_ts_reset_ic();
+
+	return irq;
+}
+
+static int  sitronix_ts_hw_init(void)
+{
+	int irq;
+	irq = sitronix_ts_config_pins();
+	return irq;
+}
+#endif // CONFIG_ARCH_SC8810
+
+#ifdef SITRONIX_FW_UPGRADE_FEATURE
+#ifdef SITRONIX_PERMISSION_THREAD
+SYSCALL_DEFINE3(fchmodat, int, dfd, const char __user *, filename, mode_t, mode);
+static struct task_struct * SitronixPermissionThread = NULL;
+static int sitronix_ts_delay_permission_thread_start = 1000;
+
+static int sitronix_ts_permission_thread(void *data)
+{
+	int ret = 0;
+	int retry = 0;
+	mm_segment_t fs = get_fs();
+	set_fs(KERNEL_DS);
+
+	DbgMsg("%s start\n", __FUNCTION__);
+	do{
+		DbgMsg("delay %d ms\n", sitronix_ts_delay_permission_thread_start);
+		msleep(sitronix_ts_delay_permission_thread_start);
+		ret = sys_fchmodat(AT_FDCWD, "/dev/"SITRONIX_I2C_TOUCH_DEV_NAME , 0666);
+		if(ret < 0)
+			printk("fail to execute sys_fchmodat, ret = %d\n", ret);
+		if(retry++ > 10)
+			break;
+	}while(ret == -ENOENT);
+	set_fs(fs);
+	DbgMsg("%s exit\n", __FUNCTION__);
+	return 0;
+}
+#endif // SITRONIX_PERMISSION_THREAD
+
+int      sitronix_release(struct inode *, struct file *);
+int      sitronix_open(struct inode *, struct file *);
+ssize_t  sitronix_write(struct file *file, const char *buf, size_t count, loff_t *ppos);
+ssize_t  sitronix_read(struct file *file, char *buf, size_t count, loff_t *ppos);
+long	 sitronix_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
+static struct cdev sitronix_cdev;
+static struct class *sitronix_class;
+static int sitronix_major = 0;
+
+int  sitronix_open(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+EXPORT_SYMBOL(sitronix_open);
+
+int  sitronix_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+EXPORT_SYMBOL(sitronix_release);
+
+ssize_t  sitronix_write(struct file *file, const char *buf, size_t count, loff_t *ppos)
+{
+	int ret;
+	char *tmp;
+
+	if(!(sitronix_ts_gpts.client))
+		return -EIO;
+
+	if (count > 8192)
+		count = 8192;
+
+	tmp = (char *)kmalloc(count,GFP_KERNEL);
+	if (tmp==NULL)
+		return -ENOMEM;
+	if (copy_from_user(tmp,buf,count)) {
+		kfree(tmp);
+		return -EFAULT;
+	}
+	UpgradeMsg("writing %zu bytes.\n", count);
+
+	ret = i2c_master_send(sitronix_ts_gpts.client, tmp, count);
+	kfree(tmp);
+	return ret;
+}
+EXPORT_SYMBOL(sitronix_write);
+
+ssize_t  sitronix_read(struct file *file, char *buf, size_t count, loff_t *ppos)
+{
+	char *tmp;
+	int ret;
+
+	if(!(sitronix_ts_gpts.client))
+		return -EIO;
+
+	if (count > 8192)
+		count = 8192;
+
+	tmp = (char *)kmalloc(count,GFP_KERNEL);
+	if (tmp==NULL)
+		return -ENOMEM;
+
+	UpgradeMsg("reading %zu bytes.\n", count);
+
+	ret = i2c_master_recv(sitronix_ts_gpts.client, tmp, count);
+	if (ret >= 0)
+		ret = copy_to_user(buf,tmp,count)?-EFAULT:ret;
+	kfree(tmp);
+	return ret;
+}
+EXPORT_SYMBOL(sitronix_read);
+
+static int sitronix_ts_resume(struct i2c_client *client);
+static int sitronix_ts_suspend(struct i2c_client *client, pm_message_t mesg);
+void sitronix_ts_reprobe(void);
+long	 sitronix_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int err = 0;
+	int retval = 0;
+	uint8_t temp[4];
+
+	if (!(sitronix_ts_gpts.client))
+		return -EIO;
+
+	if (_IOC_TYPE(cmd) != SMT_IOC_MAGIC) return -ENOTTY;
+	if (_IOC_NR(cmd) > SMT_IOC_MAXNR) return -ENOTTY;
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		err = !access_ok(VERIFY_WRITE,(void __user *)arg,\
+				 _IOC_SIZE(cmd));
+	else if (_IOC_DIR(cmd) & _IOC_WRITE)
+		err =  !access_ok(VERIFY_READ,(void __user *)arg,\
+				  _IOC_SIZE(cmd));
+	if (err) return -EFAULT;
+
+	switch(cmd) {
+		case IOCTL_SMT_GET_DRIVER_REVISION:
+			UpgradeMsg("IOCTL_SMT_GET_DRIVER_REVISION\n");
+			temp[0] = SITRONIX_TOUCH_DRIVER_VERSION;
+			if(copy_to_user((uint8_t __user *)arg, &temp[0], 1)){
+				UpgradeMsg("fail to get driver version\n");
+				retval = -EFAULT;
+			}
+			break;
+		case IOCTL_SMT_GET_FW_REVISION:
+			UpgradeMsg("IOCTL_SMT_GET_FW_REVISION\n");
+			if(copy_to_user((uint8_t __user *)arg, &(sitronix_ts_gpts.fw_revision[0]), 4))
+					retval = -EFAULT;
+			break;
+		case IOCTL_SMT_ENABLE_IRQ:
+			UpgradeMsg("IOCTL_SMT_ENABLE_IRQ\n");
+			//sitronix_ts_disable_int(&sitronix_ts_gpts, 0);
+			if(!atomic_read(&sitronix_ts_in_int)){
+				if(!atomic_read(&sitronix_ts_irq_on)){
+					atomic_set(&sitronix_ts_irq_on, 1);
+					enable_irq(sitronix_ts_gpts.client->irq);
+#ifdef SITRONIX_MONITOR_THREAD
+					if(sitronix_ts_gpts.enable_monitor_thread == 1){
+						if(!SitronixMonitorThread){
+							atomic_set(&iMonitorThreadPostpone,1);
+							SitronixMonitorThread = kthread_run(sitronix_ts_gpts.sitronix_mt_fp,"Sitronix","Monitorthread");
+							if(IS_ERR(SitronixMonitorThread))
+								SitronixMonitorThread = NULL;
+						}
+					}
+#endif // SITRONIX_MONITOR_THREAD
+				}
+			}
+			break;
+		case IOCTL_SMT_DISABLE_IRQ:
+			UpgradeMsg("IOCTL_SMT_DISABLE_IRQ\n");
+			//sitronix_ts_disable_int(&sitronix_ts_gpts, 1);
+#ifndef SITRONIX_INT_POLLING_MODE
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)
+			flush_work_sync(&sitronix_ts_gpts.work);
+#endif // LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)
+#else
+			cancel_delayed_work_sync(&sitronix_ts_gpts.work);
+#endif
+			if(atomic_read(&sitronix_ts_irq_on)){
+				atomic_set(&sitronix_ts_irq_on, 0);
+				disable_irq_nosync(sitronix_ts_gpts.client->irq);
+#ifdef SITRONIX_MONITOR_THREAD
+				if(sitronix_ts_gpts.enable_monitor_thread == 1){
+					if(SitronixMonitorThread){
+						kthread_stop(SitronixMonitorThread);
+						SitronixMonitorThread = NULL;
+					}
+				}
+#endif // SITRONIX_MONITOR_THREAD
+			}
+			break;
+		case IOCTL_SMT_RESUME:
+			UpgradeMsg("IOCTL_SMT_RESUME\n");
+			sitronix_ts_resume(sitronix_ts_gpts.client);
+			break;
+		case IOCTL_SMT_SUSPEND:
+			UpgradeMsg("IOCTL_SMT_SUSPEND\n");
+			sitronix_ts_suspend(sitronix_ts_gpts.client, PMSG_SUSPEND);
+			break;
+		case IOCTL_SMT_HW_RESET:
+			UpgradeMsg("IOCTL_SMT_HW_RESET\n");
+			sitronix_ts_reset_ic();
+			break;
+		case IOCTL_SMT_REPROBE:
+			UpgradeMsg("IOCTL_SMT_REPROBE\n");
+			sitronix_ts_reprobe();
+			break;
+		default:
+			retval = -ENOTTY;
+	}
+
+	return retval;
+}
+EXPORT_SYMBOL(sitronix_ioctl);
+#endif // SITRONIX_FW_UPGRADE_FEATURE
+
+static void sitronix_ts_reset_ic(void)
+{
+	printk("%s\n", __FUNCTION__);
+
+#ifdef CONFIG_ARCH_MSM
+	gpio_set_value(SITRONIX_RESET_GPIO, 0);
+	msleep(1);
+	gpio_set_value(SITRONIX_RESET_GPIO, 1);
+#elif defined(CONFIG_ARCH_SC8810)
+	gpio_direction_output(sprd_3rdparty_gpio_tp_rst, 1);
+	msleep(3);
+	gpio_set_value(sprd_3rdparty_gpio_tp_rst, 0);
+	msleep(10);
+	gpio_set_value(sprd_3rdparty_gpio_tp_rst,1);
+#else
+#ifndef CONFIG_MACH_CARDHU
+//	gpio_request(SITRONIX_RESET_GPIO, "Multitouch Reset");
+//	gpio_direction_output(SITRONIX_RESET_GPIO, 1);
+//	gpio_set_value(SITRONIX_RESET_GPIO, 0);
+//	msleep(1);
+//	gpio_set_value(SITRONIX_RESET_GPIO, 1);
+//	//gpio_free(SITRONIX_RESET_GPIO);
+	if (gpio_rst != -1) {
+		gpio_set_value(gpio_rst, 0);
+		msleep(1);
+		gpio_set_value(gpio_rst, 1);
+	}
+#endif // CONFIG_MACH_CARDHU
+#endif // CONFIG_ARCH_MSM
+
+	msleep(SITRONIX_TS_CHANGE_MODE_DELAY);
+}
+
+static int sitronix_i2c_read_bytes(struct i2c_client *client, u8 addr, u8 *rxbuf, int len)
+{
+	int ret = 0;
+	u8 txbuf = addr;
+#if defined(SITRONIX_I2C_COMBINED_MESSAGE)
+	struct i2c_msg msg[2] = {
+		{
+			.addr = client->addr,
+			.flags = 0,
+			.len = 1,
+			.buf = &txbuf,
+		},
+		{
+			.addr = client->addr,
+			.flags = I2C_M_RD,
+			.len = len,
+			.buf = rxbuf,
+		},
+	};
+#endif // defined(SITRONIX_I2C_COMBINED_MESSAGE)
+
+	if(rxbuf == NULL)
+		return -1;
+#if defined(SITRONIX_I2C_COMBINED_MESSAGE)
+	ret = i2c_transfer(client->adapter, &msg[0], 2);
+#elif defined(SITRONIX_I2C_SINGLE_MESSAGE)
+	ret = i2c_master_send(client, &txbuf, 1);
+	if (ret < 0){
+		printk("write 0x%x error (%d)\n", addr, ret);
+		return ret;
+	}
+	ret = i2c_master_recv(client, rxbuf, len);
+#endif // defined(SITRONIX_I2C_COMBINED_MESSAGE)
+	if (ret < 0){
+		DbgMsg("read 0x%x error (%d)\n", addr, ret);
+		return ret;
+	}
+	return 0;
+}
+
+static int sitronix_i2c_write_bytes(struct i2c_client *client, u8 *txbuf, int len)
+{
+	int ret = 0;
+#if defined(SITRONIX_I2C_COMBINED_MESSAGE)
+	struct i2c_msg msg[1] = {
+		{
+			.addr = client->addr,
+			.flags = 0,
+			.len = len,
+			.buf = txbuf,
+		},
+	};
+#endif // defined(SITRONIX_I2C_COMBINED_MESSAGE)
+
+	if(txbuf == NULL)
+		return -1;
+#if defined(SITRONIX_I2C_COMBINED_MESSAGE)
+	ret = i2c_transfer(client->adapter, &msg[0], 1);
+#elif defined(SITRONIX_I2C_SINGLE_MESSAGE)
+	ret = i2c_master_send(client, txbuf, len);
+#endif // defined(SITRONIX_I2C_COMBINED_MESSAGE)
+	if (ret < 0){
+		printk("write 0x%x error (%d)\n", *txbuf, ret);
+		return ret;
+	}
+	return 0;
+}
+
+static int sitronix_get_fw_revision(struct sitronix_ts_data *ts)
+{
+	int ret = 0;
+	uint8_t buffer[4];
+
+	ret = sitronix_i2c_read_bytes(ts->client, FIRMWARE_REVISION_3, buffer, 4);
+	if (ret < 0){
+		printk("read fw revision error (%d)\n", ret);
+		return ret;
+	}else{
+		memcpy(ts->fw_revision, buffer, 4);
+		printk("fw revision (hex) = %x %x %x %x\n", buffer[0], buffer[1], buffer[2], buffer[3]);
+	}
+	return 0;
+}
+static int sitronix_get_max_touches(struct sitronix_ts_data *ts)
+{
+	int ret = 0;
+	uint8_t buffer[1];
+
+	ret = sitronix_i2c_read_bytes(ts->client, MAX_NUM_TOUCHES, buffer, 1);
+	if (ret < 0){
+		printk("read max touches error (%d)\n", ret);
+		return ret;
+	}else{
+		ts->max_touches = buffer[0];
+		if (ts->max_touches > SITRONIX_MAX_SUPPORTED_POINT)
+			ts->max_touches = SITRONIX_MAX_SUPPORTED_POINT;
+		printk("max touches = %d \n",ts->max_touches);
+	}
+	return 0;
+}
+
+static int sitronix_get_protocol_type(struct sitronix_ts_data *ts)
+{
+	int ret = 0;
+	uint8_t buffer[1];
+
+	if(ts->chip_id <= 3){
+		ret = sitronix_i2c_read_bytes(ts->client, I2C_PROTOCOL, buffer, 1);
+		if (ret < 0){
+			printk("read i2c protocol error (%d)\n", ret);
+			return ret;
+		}else{
+			ts->touch_protocol_type = buffer[0] & I2C_PROTOCOL_BMSK;
+			printk("i2c protocol = %d \n", ts->touch_protocol_type);
+			ts->sensing_mode = (buffer[0] & (ONE_D_SENSING_CONTROL_BMSK << ONE_D_SENSING_CONTROL_SHFT)) >> ONE_D_SENSING_CONTROL_SHFT;
+			printk("sensing mode = %d \n", ts->sensing_mode);
+		}
+	}else{
+		ts->touch_protocol_type = SITRONIX_A_TYPE;
+		printk("i2c protocol = %d \n", ts->touch_protocol_type);
+		ret = sitronix_i2c_read_bytes(ts->client, 0xf0, buffer, 1);
+		if (ret < 0){
+			printk("read sensing mode error (%d)\n", ret);
+			return ret;
+		}else{
+			ts->sensing_mode = (buffer[0] & ONE_D_SENSING_CONTROL_BMSK);
+			printk("sensing mode = %d \n", ts->sensing_mode);
+		}
+	}
+	return 0;
+}
+
+static int sitronix_get_resolution(struct sitronix_ts_data *ts)
+{
+	int ret = 0;
+	uint8_t buffer[3];
+
+	ret = sitronix_i2c_read_bytes(ts->client, XY_RESOLUTION_HIGH, buffer, 3);
+	if (ret < 0){
+		printk("read resolution error (%d)\n", ret);
+		return ret;
+	}else{
+		ts->resolution_x = ((buffer[0] & (X_RES_H_BMSK << X_RES_H_SHFT)) << 4) | buffer[1];
+		ts->resolution_y = ((buffer[0] & Y_RES_H_BMSK) << 8) | buffer[2];
+		printk("resolution = %d x %d\n", ts->resolution_x, ts->resolution_y);
+	}
+	return 0;
+}
+
+static int sitronix_ts_get_CHIP_ID(struct sitronix_ts_data *ts)
+{
+	int ret = 0;
+	uint8_t buffer[3];
+
+	DbgMsg("%s\n", __FUNCTION__);
+
+	ret = sitronix_i2c_read_bytes(ts->client, CHIP_ID, buffer, 3);
+	if (ret < 0){
+		printk("read Chip ID error (%d)\n", ret);
+		return ret;
+	}else{
+		if(buffer[0] == 0){
+			if(buffer[1] + buffer[2] > 32)
+				ts->chip_id = 2;
+			else
+				ts->chip_id = 0;
+		}else
+			ts->chip_id = buffer[0];
+		ts->Num_X = buffer[1];
+		ts->Num_Y = buffer[2];
+		printk("Chip ID = %d\n", ts->chip_id);
+		printk("Num_X = %d\n", ts->Num_X);
+		printk("Num_Y = %d\n", ts->Num_Y);
+	}
+
+	return 0;
+}
+
+static int sitronix_ts_set_powerdown_bit(struct sitronix_ts_data *ts, int value)
+{
+	int ret = 0;
+	uint8_t buffer[2];
+
+	DbgMsg("%s, value = %d\n", __FUNCTION__, value);
+	ret = sitronix_i2c_read_bytes(ts->client, DEVICE_CONTROL_REG, buffer, 1);
+	if (ret < 0){
+		printk("read device control status error (%d)\n", ret);
+		return ret;
+	}else{
+		DbgMsg("dev status = %d \n", buffer[0]);
+	}
+
+	if(value == 0)
+		buffer[1] = buffer[0] & 0xfd;
+	else
+		buffer[1] = buffer[0] | 0x2;
+
+	buffer[0] = DEVICE_CONTROL_REG;
+	ret = sitronix_i2c_write_bytes(ts->client, buffer, 2);
+	if (ret < 0){
+		printk("write power down error (%d)\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int sitronix_ts_disable_int(struct sitronix_ts_data *ts, uint8_t value)
+{
+	int ret = 0;
+	uint8_t buffer[2];
+	sitronix_i2c_protocol_map *i2c_ptcl;
+
+	DbgMsg("%s, value = %d\n", __FUNCTION__, value);
+	i2c_ptcl = (ts->chip_id > 3)? &sitronix_i2c_ptcl_v2 : &sitronix_i2c_ptcl_v1;
+
+	ret = sitronix_i2c_read_bytes(ts->client, i2c_ptcl->dis_coord_flag.offset, buffer, 1);
+	if (ret < 0){
+		printk("read disable coord. flag error (%d)\n", ret);
+		return ret;
+	}
+
+	buffer[1] = buffer[0] & ~(i2c_ptcl->dis_coord_flag.bmsk << i2c_ptcl->dis_coord_flag.shft);
+	buffer[1] |= value;
+
+	buffer[0] = i2c_ptcl->dis_coord_flag.offset;
+	ret = sitronix_i2c_write_bytes(ts->client, buffer, 2);
+	if (ret < 0){
+		printk("write disable coord. flag error (%d)\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
+static int sitronix_ts_get_touch_info(struct sitronix_ts_data *ts)
+{
+	int ret = 0;
+	ret = sitronix_get_resolution(ts);
+	if(ret < 0)
+		return ret;
+	ret = sitronix_ts_get_CHIP_ID(ts);
+	if(ret < 0)
+		return ret;
+	ret = sitronix_get_fw_revision(ts);
+	if(ret < 0)
+		return ret;
+	ret = sitronix_get_protocol_type(ts);
+	if(ret < 0)
+		return ret;
+	ret = sitronix_get_max_touches(ts);
+	if(ret < 0)
+		return ret;
+
+	if((ts->fw_revision[0] == 0) && (ts->fw_revision[1] == 0)){
+		if(ts->touch_protocol_type == SITRONIX_RESERVED_TYPE_0){
+			ts->touch_protocol_type = SITRONIX_B_TYPE;
+			printk("i2c protocol (revised) = %d \n", ts->touch_protocol_type);
+		}
+	}
+	if(ts->touch_protocol_type == SITRONIX_A_TYPE)
+		ts->pixel_length = PIXEL_DATA_LENGTH_A;
+	else if(ts->touch_protocol_type == SITRONIX_B_TYPE){
+		ts->pixel_length = PIXEL_DATA_LENGTH_B;
+		ts->max_touches = 2;
+		printk("max touches (revised) = %d \n", ts->max_touches);
+	}
+
+#ifdef SITRONIX_MONITOR_THREAD
+	ts->RawCRC_enabled = 0;
+	if(ts->chip_id > 3){
+		ts->enable_monitor_thread = 1;
+		ts->RawCRC_enabled = 1;
+	}else if(ts->chip_id == 3){
+		ts->enable_monitor_thread = 1;		
+		if(((ts->fw_revision[2] << 8) | ts->fw_revision[3]) >= (6 << 8 | 3))
+			ts->RawCRC_enabled = 1;
+	}else
+		ts->enable_monitor_thread = 0;
+#endif // SITRONIX_MONITOR_THREAD
+
+	return 0;
+}
+
+static int sitronix_ts_get_device_status(struct i2c_client *client, uint8_t *err_code, uint8_t *dev_status)
+{
+	int ret = 0;
+	uint8_t buffer[8];
+
+	DbgMsg("%s\n", __FUNCTION__);
+	ret = sitronix_i2c_read_bytes(client, STATUS_REG, buffer, 8);
+	if (ret < 0){
+		printk("read status reg error (%d)\n", ret);
+		return ret;
+	}else{
+		printk("status reg = %d \n", buffer[0]);
+	}
+
+	*err_code = (buffer[0] & 0xf0) >> 4;
+	*dev_status = buffer[0] & 0xf;
+
+	return 0;
+}
+
+#ifdef SITRONIX_IDENTIFY_ID
+static int sitronix_ts_Enhance_Function_control(struct sitronix_ts_data *ts, uint8_t *value)
+{
+	int ret = 0;
+	uint8_t buffer[1];
+
+	DbgMsg("%s\n", __FUNCTION__);
+	ret = sitronix_i2c_read_bytes(ts->client, 0xF0, buffer, 1);
+	if (ret < 0){
+		printk("read Enhance Functions status error (%d)\n", ret);
+		return ret;
+	}else{
+		DbgMsg("Enhance Functions status = %d \n", buffer[0]);
+	}
+
+	*value = buffer[0] & 0x4;
+
+	return 0;
+}
+
+static int sitronix_ts_FW_Bank_Select(struct sitronix_ts_data *ts, uint8_t value)
+{
+	int ret = 0;
+	uint8_t buffer[2];
+
+	DbgMsg("%s\n", __FUNCTION__);
+	ret = sitronix_i2c_read_bytes(ts->client, 0xF1, buffer, 1);
+	if (ret < 0){
+		printk("read FW Bank Select status error (%d)\n", ret);
+		return ret;
+	}else{
+		DbgMsg("FW Bank Select status = %d \n", buffer[0]);
+	}
+
+	buffer[1] = ((buffer[0] & 0xfc) | value);
+	buffer[0] = 0xF1;
+	ret = sitronix_i2c_write_bytes(ts->client, buffer, 2);
+	if (ret < 0){
+		printk("send FW Bank Select command error (%d)\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int sitronix_get_id_info(struct sitronix_ts_data *ts, uint8_t *id_info)
+{
+	int ret = 0;
+	uint8_t buffer[4];
+
+	ret = sitronix_i2c_read_bytes(ts->client, 0x0C, buffer, 4);
+	if (ret < 0){
+		printk("read id info error (%d)\n", ret);
+		return ret;
+	}else{
+		memcpy(id_info, buffer, 4);
+	}
+	return 0;
+}
+
+static int sitronix_ts_identify(struct sitronix_ts_data *ts)
+{
+	int ret = 0;
+	uint8_t id[4];
+	uint8_t Enhance_Function = 0;
+
+	ret = sitronix_ts_FW_Bank_Select(ts, 1);
+	if(ret < 0)
+		return ret;
+	ret = sitronix_ts_Enhance_Function_control(ts, &Enhance_Function);
+	if(ret < 0)
+		return ret;
+	if(Enhance_Function == 0x4){
+		ret = sitronix_get_id_info(ts, &id[0]);
+		if(ret < 0)
+			return ret;
+		printk("id (hex) = %x %x %x %x\n", id[0], id[1], id[2], id[3]);
+		if((id[0] == 1)&&(id[1] == 2)&&(id[2] == 0xb)&&(id[3] == 1)){
+			return 0;
+		}else{
+			printk("Error: It is not Sitronix IC\n");
+			return -1;
+		}
+	}else{
+		printk("Error: Can not get ID of Sitronix IC\n");
+		return -1;
+	}
+}
+#endif // SITRONIX_IDENTIFY_ID
+
+#ifdef SITRONIX_MONITOR_THREAD
+static int sitronix_set_raw_data_type(struct sitronix_ts_data *ts)
+{
+	int ret = 0;
+	uint8_t buffer[2] = {0};
+
+	ret = sitronix_i2c_read_bytes(ts->client, DEVICE_CONTROL_REG, buffer, 1);
+	if (ret < 0){
+		DbgMsg("read DEVICE_CONTROL_REG error (%d)\n", ret);
+		return ret;
+	}else{
+		DbgMsg("read DEVICE_CONTROL_REG status = %d \n", buffer[0]);
+	}
+	if(ts->sensing_mode == SENSING_BOTH_NOT){
+		buffer[1] = ((buffer[0] & 0xf3) | (0x01 << 2));
+	}else{
+		buffer[1] = (buffer[0] & 0xf3);
+	}
+	buffer[0] = DEVICE_CONTROL_REG;
+	ret = sitronix_i2c_write_bytes(ts->client, buffer, 2);
+	if (ret < 0){
+		DbgMsg("write DEVICE_CONTROL_REG error (%d)\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
+static int sitronix_ts_monitor_thread(void *data)
+{
+	int ret = 0;
+	uint8_t buffer[4] = { 0, 0, 0, 0 };
+	int result = 0;
+	int once = 1;
+	uint8_t raw_data_ofs = 0;
+
+	DbgMsg("%s:\n", __FUNCTION__);
+
+	printk("delay %d ms\n", sitronix_ts_delay_monitor_thread_start);
+	msleep(sitronix_ts_delay_monitor_thread_start);
+	while(!kthread_should_stop()){
+		DbgMsg("%s:\n", "Sitronix_ts_monitoring");
+		if(atomic_read(&iMonitorThreadPostpone)){
+		 		atomic_set(&iMonitorThreadPostpone,0);
+		}else{
+			if(once == 1){
+				ret = sitronix_set_raw_data_type(&sitronix_ts_gpts);
+				if (ret < 0)
+					goto exit_i2c_invalid;
+
+				if((sitronix_ts_gpts.sensing_mode == SENSING_BOTH) || (sitronix_ts_gpts.sensing_mode == SENSING_X_ONLY)){
+					raw_data_ofs = 0x40;
+				}else if(sitronix_ts_gpts.sensing_mode == SENSING_Y_ONLY){
+					raw_data_ofs = 0x40 + sitronix_ts_gpts.Num_X * 2; 
+				}else{
+					raw_data_ofs = 0x40;
+				}
+
+				once = 0;
+			}
+			if(raw_data_ofs != 0x40){
+				ret = sitronix_i2c_read_bytes(sitronix_ts_gpts.client, 0x40, buffer, 1);
+				if (ret < 0){
+					DbgMsg("read raw data error (%d)\n", ret);
+					result = 0;
+					goto exit_i2c_invalid;
+				}
+			}
+			ret = sitronix_i2c_read_bytes(sitronix_ts_gpts.client, raw_data_ofs, buffer, 4);
+			if (ret < 0){
+				DbgMsg("read raw data error (%d)\n", ret);
+				result = 0;
+				goto exit_i2c_invalid;
+			}else{
+				DbgMsg("%dD data h%x-%x = 0x%02x, 0x%02x, 0x%02x, 0x%02x\n", (sitronix_ts_gpts.sensing_mode == SENSING_BOTH_NOT ? 2:1), raw_data_ofs, raw_data_ofs + 3, buffer[0], buffer[1], buffer[2], buffer[3]);
+				//printk("%dD data h%x-%x = 0x%02x, 0x%02x, 0x%02x, 0x%02x\n", (sitronix_ts_gpts.sensing_mode == SENSING_BOTH_NOT ? 2:1), raw_data_ofs, raw_data_ofs + 3, buffer[0], buffer[1], buffer[2], buffer[3]);
+				result = 1;
+				if ((PreCheckData[0] == buffer[0]) && (PreCheckData[1] == buffer[1]) && 
+				(PreCheckData[2] == buffer[2]) && (PreCheckData[3] == buffer[3]))
+					StatusCheckCount ++;
+				else
+					StatusCheckCount =0;
+				PreCheckData[0] = buffer[0];
+				PreCheckData[1] = buffer[1];
+				PreCheckData[2] = buffer[2];
+				PreCheckData[3] = buffer[3];
+				if (3 <= StatusCheckCount){
+					DbgMsg("IC Status doesn't update! \n");
+					result = -1;
+					StatusCheckCount = 0;
+				}
+			}
+			if (-1 == result){
+				printk("Chip abnormal, reset it!\n");
+				sitronix_ts_reset_ic();
+		   		i2cErrorCount = 0;
+		   		StatusCheckCount = 0;
+				if(sitronix_ts_gpts.RawCRC_enabled == 0){
+					ret = sitronix_set_raw_data_type(&sitronix_ts_gpts);
+					if (ret < 0)
+						goto exit_i2c_invalid;
+				}
+			}
+exit_i2c_invalid:
+			if(0 == result){
+				i2cErrorCount ++;
+				if ((2 <= i2cErrorCount)){
+					printk("I2C abnormal, reset it!\n");
+					sitronix_ts_reset_ic();
+					if(sitronix_ts_gpts.RawCRC_enabled == 0)
+						sitronix_set_raw_data_type(&sitronix_ts_gpts);
+		    			i2cErrorCount = 0;
+		    			StatusCheckCount = 0;
+		    		}
+		    	}else
+		    		i2cErrorCount = 0;
+		}
+		msleep(gMonitorThreadSleepInterval);
+	}
+	DbgMsg("%s exit\n", __FUNCTION__);
+	return 0;
+}
+
+static int sitronix_ts_monitor_thread_v2(void *data)
+{
+	int ret = 0;
+	uint8_t buffer[1] = {0};
+	int result = 0;
+
+	DbgMsg("%s:\n", __FUNCTION__);
+
+	printk("delay %d ms\n", sitronix_ts_delay_monitor_thread_start);	
+	msleep(sitronix_ts_delay_monitor_thread_start);
+	while(!kthread_should_stop()){
+		DbgMsg("%s:\n", "Sitronix_ts_monitoring");
+		if(atomic_read(&iMonitorThreadPostpone)){
+		 		atomic_set(&iMonitorThreadPostpone,0);
+		}else{
+			ret = sitronix_i2c_read_bytes(sitronix_ts_gpts.client, 0xA, buffer, 1);
+			if (ret < 0){
+				DbgMsg("read Raw CRC error (%d)\n", ret);
+				result = 0;
+				goto exit_i2c_invalid;
+			}else{
+				DbgMsg("Raw CRC = 0x%02x\n", buffer[0]);
+				//printk("Raw CRC = 0x%02x\n", buffer[0]);
+				result = 1;
+				if (PreCheckData[0] == buffer[0])
+					StatusCheckCount ++;
+				else
+					StatusCheckCount =0;
+				PreCheckData[0] = buffer[0];
+				if (3 <= StatusCheckCount){
+					DbgMsg("IC Status doesn't update! \n");
+					result = -1;
+					StatusCheckCount = 0;
+				}
+			}
+			if (-1 == result){
+				printk("Chip abnormal, reset it!\n");
+				sitronix_ts_reset_ic();
+		   		i2cErrorCount = 0;
+		   		StatusCheckCount = 0;
+			}
+exit_i2c_invalid:
+			if(0 == result){
+				i2cErrorCount ++;
+				if ((2 <= i2cErrorCount)){
+					printk("I2C abnormal, reset it!\n");
+					sitronix_ts_reset_ic();
+		    			i2cErrorCount = 0;
+		    			StatusCheckCount = 0;
+		    		}
+		    	}else
+		    		i2cErrorCount = 0;
+		}
+		msleep(gMonitorThreadSleepInterval);
+	}
+	DbgMsg("%s exit\n", __FUNCTION__);
+	return 0;
+}
+#endif // SITRONIX_MONITOR_THREAD
+
+static inline void sitronix_ts_pen_down(struct input_dev *input_dev, int id, u16 x, u16 y)
+{
+#ifdef SITRONIX_SUPPORT_MT_SLOT
+	input_mt_slot(input_dev, id);
+	input_mt_report_slot_state(input_dev, MT_TOOL_FINGER, true);
+#ifndef SITRONIX_SWAP_XY
+	input_report_abs(input_dev,  ABS_MT_POSITION_X, x);
+	input_report_abs(input_dev,  ABS_MT_POSITION_Y, y);
+#else
+	input_report_abs(input_dev,  ABS_MT_POSITION_X, y);
+	input_report_abs(input_dev,  ABS_MT_POSITION_Y, x);
+#endif // SITRONIX_SWAP_XY
+#else
+	input_report_abs(input_dev,  ABS_MT_TRACKING_ID, id);
+#ifndef SITRONIX_SWAP_XY
+	input_report_abs(input_dev,  ABS_MT_POSITION_X, x);
+	input_report_abs(input_dev,  ABS_MT_POSITION_Y, y);
+#else
+	input_report_abs(input_dev,  ABS_MT_POSITION_X, y);
+	input_report_abs(input_dev,  ABS_MT_POSITION_Y, x);
+#endif // SITRONIX_SWAP_XY
+	input_report_abs(input_dev,  ABS_MT_TOUCH_MAJOR, 10);
+	input_report_abs(input_dev,  ABS_MT_WIDTH_MAJOR, 10);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+	input_report_abs(input_dev, ABS_MT_PRESSURE, 10);
+#endif // LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+	input_mt_sync(input_dev);
+#endif // SITRONIX_SUPPORT_MT_SLOT
+	DbgMsg("[%d](%d, %d)+\n", id, x, y);
+}
+
+static inline void sitronix_ts_pen_up(struct input_dev *input_dev, int id)
+{
+#ifdef SITRONIX_SUPPORT_MT_SLOT
+	input_mt_slot(input_dev, id);
+	input_mt_report_slot_state(input_dev, MT_TOOL_FINGER, false);
+#else // for android 2.1
+	input_report_abs(input_dev,  ABS_MT_TRACKING_ID, id);
+	input_report_abs(input_dev,  ABS_MT_TOUCH_MAJOR, 0);
+	input_report_abs(input_dev,  ABS_MT_WIDTH_MAJOR, 0);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+	input_report_abs(input_dev, ABS_MT_PRESSURE, 0);
+#endif // LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+#endif // SITRONIX_SUPPORT_MT_SLOT
+	DbgMsg("[%d]-\n", id);
+}
+
+static inline void sitronix_ts_handle_sensor_key(struct input_dev *input_dev, struct sitronix_sensor_key_t *key_array, char *pre_key_status, char cur_key_status, int key_count)
+{
+	
+	int i = 0;
+	for(i = 0; i < key_count; i++){
+		if(cur_key_status & (1 << i)){
+			DbgMsg("sensor key[%d] down\n", i);
+			input_report_key(input_dev, key_array[i].code, 1);
+			input_sync(input_dev);
+		}else{
+			if(*pre_key_status & (1 << i)){
+				DbgMsg("sensor key[%d] up\n", i);
+				input_report_key(input_dev, key_array[i].code, 0);				
+				input_sync(input_dev);
+			}
+		}
+	}
+	*pre_key_status = cur_key_status;
+}
+
+#ifdef SITRONIX_AA_KEY
+static inline void sitronix_ts_handle_aa_key(struct input_dev *input_dev, struct sitronix_AA_key *key_array, char *pre_key_status, char cur_key_status, int key_count)
+{
+	int i = 0;
+	for(i = 0; i < key_count; i++){
+		if(cur_key_status & (1 << i)){
+			DbgMsg("aa key[%d] down\n", i);
+			input_report_key(input_dev, key_array[i].code, 1);
+			input_sync(input_dev);
+		}else{
+			if(*pre_key_status & (1 << i)){
+				DbgMsg("aa key[%d] up\n", i);
+				input_report_key(input_dev, key_array[i].code, 0);
+				input_sync(input_dev);
+			}
+		}
+	}
+	*pre_key_status = cur_key_status;
+}
+#endif // SITRONIX_AA_KEY
+
+#ifdef SITRONIX_SMART_WAKE_UP
+static void sitronix_swk_set_swk_enable(struct sitronix_ts_data *ts)
+{
+	
+	int ret = 0;
+	unsigned char buffer[2] = {0};
+	ret = sitronix_i2c_read_bytes(ts->client, MISC_CONTROL, buffer, 1);
+	if(ret == 0)
+	{
+		buffer[1] = buffer[0] | 0x80;
+		buffer[0] = MISC_CONTROL;
+		sitronix_i2c_write_bytes(ts->client, buffer, 2);
+				
+		msleep(500);
+	}
+	
+	
+}
+static void sitronix_swk_func(struct input_dev *input_dev, int id)
+{
+	if(id == DOUBLE_CLICK)
+	{
+		//do wake up here
+		printk("Smark Wake Up by Double click \n");
+		input_report_key(input_dev, KEY_POWER, 1);
+		input_sync(input_dev);
+		input_report_key(input_dev, KEY_POWER, 0);
+		input_sync(input_dev);
+	}
+}
+#endif	//SITRONIX_SMART_WAKE_UP
+
+static void sitronix_ts_work_func(struct work_struct *work)
+{
+	int i;
+#ifdef SITRONIX_AA_KEY
+	int j;
+	char aa_key_status = 0;
+#endif // SITRONIX_AA_KEY
+	int ret;
+#ifndef SITRONIX_INT_POLLING_MODE
+	struct sitronix_ts_data *ts = container_of(work, struct sitronix_ts_data, work);
+#else
+	struct sitronix_ts_data *ts = container_of(to_delayed_work(work), struct sitronix_ts_data, work);
+#endif // SITRONIX_INT_POLLING_MODE
+	u16 x, y;
+	uint8_t buffer[1+ SITRONIX_MAX_SUPPORTED_POINT * PIXEL_DATA_LENGTH_A] = {0};
+	uint8_t PixelCount = 0;
+
+	DbgMsg("%s\n",  __FUNCTION__);
+	atomic_set(&sitronix_ts_in_int, 1);
+	
+	if(ts->suspend_state){
+//2.9.15 petitk add 
+#ifdef 	SITRONIX_SMART_WAKE_UP
+		ret = sitronix_i2c_read_bytes(ts->client, SMART_WAKE_UP_REG, buffer, 1);
+		if(ret ==0 && buffer[0] == DOUBLE_CLICK)
+		{			
+			sitronix_swk_func(ts->keyevent_input, DOUBLE_CLICK);
+		}		
+#endif	//SITRONIX_SMART_WAKE_UP
+		goto exit_invalid_data;
+	}
+
+	ret = sitronix_i2c_read_bytes(ts->client, KEYS_REG, buffer, 1 + ts->max_touches * ts->pixel_length);
+	if (ret < 0) {
+		printk("read finger error (%d)\n", ret);
+   		i2cErrorCount++;
+		goto exit_invalid_data;
+	}
+
+	for(i = 0; i < ts->max_touches; i++){
+		if(buffer[1 + i * ts->pixel_length + XY_COORD_H] & 0x80){
+			x = (u16)(buffer[1 + i * ts->pixel_length + XY_COORD_H] & 0x70) << 4 | buffer[1 + i * ts->pixel_length + X_COORD_L];
+			y = (u16)(buffer[1 + i * ts->pixel_length + XY_COORD_H] & 0x07) << 8 | buffer[1 + i * ts->pixel_length + Y_COORD_L];
+#ifndef SITRONIX_AA_KEY
+			PixelCount++;
+			sitronix_ts_pen_down(ts->input_dev, i, x, y);
+#else
+#ifdef SITRONIX_KEY_BOUNDARY_MANUAL_SPECIFY
+			if(y < SITRONIX_TOUCH_RESOLUTION_Y){
+#else
+			if(y < (ts->resolution_y - ts->resolution_y / SCALE_KEY_HIGH_Y)){
+#endif // SITRONIX_KEY_BOUNDARY_MANUAL_SPECIFY
+				PixelCount++;
+				sitronix_ts_pen_down(ts->input_dev, i, x, y);
+				//DbgMsg("AREA_DISPLAY\n");
+			}else{
+				for(j = 0; j < (sizeof(sitronix_aa_key_array)/sizeof(struct sitronix_AA_key)); j++){
+					if((x >= sitronix_aa_key_array[j].x_low) &&
+					(x <= sitronix_aa_key_array[j].x_high) &&
+					(y >= sitronix_aa_key_array[j].y_low) &&
+					(y <= sitronix_aa_key_array[j].y_high)){
+						aa_key_status |= (1 << j);
+						//DbgMsg("AREA_KEY [%d]\n", j);
+						break;
+					}
+				}
+			}
+#endif // SITRONIX_AA_KEY
+		}else{
+			sitronix_ts_pen_up(ts->input_dev, i);
+		}
+	}
+	input_report_key(ts->input_dev, BTN_TOUCH, PixelCount > 0);
+	input_sync(ts->input_dev);
+
+	sitronix_ts_handle_sensor_key(ts->keyevent_input, sitronix_sensor_key_array, &sitronix_sensor_key_status, buffer[0], (sizeof(sitronix_sensor_key_array)/sizeof(struct sitronix_sensor_key_t)));
+#ifdef SITRONIX_AA_KEY
+	sitronix_ts_handle_aa_key(ts->keyevent_input, sitronix_aa_key_array, &sitronix_aa_key_status, aa_key_status, (sizeof(sitronix_aa_key_array)/sizeof(struct sitronix_AA_key)));
+#endif // SITRONIX_AA_KEY
+
+exit_invalid_data:
+#ifdef SITRONIX_INT_POLLING_MODE
+	if(PixelCount > 0){
+#ifdef SITRONIX_MONITOR_THREAD
+		if(ts->enable_monitor_thread == 1){
+			atomic_set(&iMonitorThreadPostpone,1);
+		}
+#endif // SITRONIX_MONITOR_THREAD
+		schedule_delayed_work(&ts->work, msecs_to_jiffies(INT_POLLING_MODE_INTERVAL));
+	}else{
+#ifdef CONFIG_HARDIRQS_SW_RESEND
+		printk("Please not set HARDIRQS_SW_RESEND to prevent kernel from sending SW IRQ\n");
+#endif // CONFIG_HARDIRQS_SW_RESEND
+		if (ts->use_irq){
+			atomic_set(&sitronix_ts_irq_on, 1);
+			enable_irq(ts->client->irq);
+		}
+	}
+#endif // SITRONIX_INT_POLLING_MODE
+#if defined(SITRONIX_LEVEL_TRIGGERED)
+	if (ts->use_irq){
+		atomic_set(&sitronix_ts_irq_on, 1);
+		enable_irq(ts->client->irq);
+	}
+#endif // defined(SITRONIX_LEVEL_TRIGGERED)
+	if ((2 <= i2cErrorCount)){
+		printk("I2C abnormal in work_func(), reset it!\n");
+		sitronix_ts_reset_ic();
+   		i2cErrorCount = 0;
+#ifdef SITRONIX_MONITOR_THREAD
+		if(ts->enable_monitor_thread == 1){
+			StatusCheckCount = 0;
+			if(ts->RawCRC_enabled == 0)
+				sitronix_set_raw_data_type(&sitronix_ts_gpts);
+		}
+#endif // SITRONIX_MONITOR_THREAD
+	}
+	atomic_set(&sitronix_ts_in_int, 0);
+	
+}
+
+static irqreturn_t sitronix_ts_irq_handler(int irq, void *dev_id)
+{
+	struct sitronix_ts_data *ts = dev_id;
+
+	DbgMsg("%s\n", __FUNCTION__);
+	atomic_set(&sitronix_ts_in_int, 1);
+#if defined(SITRONIX_LEVEL_TRIGGERED) || defined(SITRONIX_INT_POLLING_MODE)
+	atomic_set(&sitronix_ts_irq_on, 0);
+	disable_irq_nosync(ts->client->irq);
+#endif // defined(SITRONIX_LEVEL_TRIGGERED) || defined(SITRONIX_INT_POLLING_MODE)
+#ifdef SITRONIX_MONITOR_THREAD
+	if(ts->enable_monitor_thread == 1){
+		atomic_set(&iMonitorThreadPostpone,1);
+	}
+#endif // SITRONIX_MONITOR_THREAD
+#ifndef SITRONIX_INT_POLLING_MODE
+	schedule_work(&ts->work);
+#else
+	schedule_delayed_work(&ts->work, msecs_to_jiffies(0));
+#endif // SITRONIX_INT_POLLING_MODE
+	return IRQ_HANDLED;
+}
+
+#ifdef SITRONIX_SYSFS
+static ssize_t sitronix_ts_reprobe_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	sitronix_ts_sysfs_using = true;
+	sitronix_ts_reprobe();
+	sitronix_ts_sysfs_using = false;
+	return count;
+}
+
+static DEVICE_ATTR(reprobe, 0222, NULL, sitronix_ts_reprobe_store);
+
+static struct attribute *sitronix_ts_attrs_v0[] = {
+	&dev_attr_reprobe.attr,
+	NULL,
+};
+
+static struct attribute_group sitronix_ts_attr_group_v0 = {
+	.name = "sitronix_ts_attrs",
+	.attrs = sitronix_ts_attrs_v0,
+};
+
+static int sitronix_ts_create_sysfs_entry(struct i2c_client *client)
+{
+	int err;
+
+	err = sysfs_create_group(&(client->dev.kobj), &sitronix_ts_attr_group_v0);
+	if (err) {
+		dev_warn(&client->dev, "%s(%u): sysfs_create_group() failed!\n", __FUNCTION__, __LINE__);
+	}
+	return err;
+}
+
+static void sitronix_ts_destroy_sysfs_entry(struct i2c_client *client)
+{
+	sysfs_remove_group(&(client->dev.kobj), &sitronix_ts_attr_group_v0);
+
+	return;
+}
+#endif // SITRONIX_SYSFS
+
+static int sitronix_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	int i;
+	int ret = 0;
+	uint16_t max_x = 0, max_y = 0;
+	uint8_t err_code = 0;
+	uint8_t dev_status = 0;
+	struct device_node *np = client->dev.of_node;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		ret = -ENODEV;
+		goto err_check_functionality_failed;
+	}
+
+	if (!np)
+		return -ENODEV;
+
+	printk(KERN_DEBUG "%s, sending reset pulse\n", __func__);
+	gpio_rst = of_get_named_gpio(np, "reset-gpios", 0);
+	if (gpio_is_valid(gpio_rst)) {
+		ret = devm_gpio_request_one(&client->dev, gpio_rst, GPIOF_OUT_INIT_HIGH, "gpio_rst");
+		if (ret < 0) {
+			gpio_rst = -1;
+			printk(KERN_ERR "%s, request reset gpio failed; %d\n", __func__, ret);
+			return ret;
+		}
+		//gpio_set_value(gpio_rst, 0);
+		//msleep(1); // at least 50us
+		//gpio_set_value(gpio_rst, 1);
+		//msleep(100);
+		//printk(KERN_ERR "%s, controller reset completed\n", __func__);
+
+	} else {
+		gpio_rst = -1;
+		printk(KERN_DEBUG "%s, skipping reset due to missing pin\n", __func__);
+	}
+
+#ifdef CONFIG_ARCH_MSM
+	gpio_tlmm_config(GPIO_CFG(SITRONIX_RESET_GPIO, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA), GPIO_CFG_ENABLE);
+#endif // CONFIG_ARCH_MSM
+#ifdef CONFIG_ARCH_SC8810
+	client->irq = sitronix_ts_hw_init();
+#else
+	sitronix_ts_reset_ic();
+#endif // CONFIG_ARCH_SC8810
+
+	if(((ret = sitronix_ts_get_device_status(client, &err_code, &dev_status)) < 0) || (dev_status == 0x6) || ((err_code == 0x8)&&(dev_status == 0x0))){
+		if((dev_status == 0x6) || ((err_code == 0x8)&&(dev_status == 0x0))){
+			sitronix_ts_gpts.client = client;
+		}
+		ret = -EPERM;
+		goto err_device_info_error;
+	}
+
+	sitronix_ts_gpts.client = client;
+	sitronix_ts_gpts.suspend_state = 0;
+	i2c_set_clientdata(client, &sitronix_ts_gpts);
+	if((ret = sitronix_ts_get_touch_info(&sitronix_ts_gpts)) < 0)
+		goto err_device_info_error;
+
+#ifdef SITRONIX_IDENTIFY_ID
+	if((ret = sitronix_ts_identify(&sitronix_ts_gpts)) < 0)
+		goto err_device_info_error;
+#endif // SITRONIX_IDENTIFY_ID
+
+#ifndef SITRONIX_INT_POLLING_MODE
+	INIT_WORK(&(sitronix_ts_gpts.work), sitronix_ts_work_func);
+#else
+	INIT_DELAYED_WORK(&(sitronix_ts_gpts.work), sitronix_ts_work_func);
+#endif // SITRONIX_INT_POLLING_MODE
+
+#ifdef SITRONIX_MONITOR_THREAD
+	if(sitronix_ts_gpts.enable_monitor_thread == 1){
+		//== Add thread to monitor chip
+		atomic_set(&iMonitorThreadPostpone,1);
+		sitronix_ts_gpts.sitronix_mt_fp = sitronix_ts_gpts.RawCRC_enabled? sitronix_ts_monitor_thread_v2 : sitronix_ts_monitor_thread;
+		SitronixMonitorThread = kthread_run(sitronix_ts_gpts.sitronix_mt_fp,"Sitronix","Monitorthread");
+		if(IS_ERR(SitronixMonitorThread))
+			SitronixMonitorThread = NULL;
+	}
+#endif // SITRONIX_MONITOR_THREAD
+
+	sitronix_ts_gpts.input_dev = input_allocate_device();
+	if (sitronix_ts_gpts.input_dev == NULL){
+		printk("Can not allocate memory for input device.");
+		ret = -ENOMEM;
+		goto err_input_dev_alloc_failed;
+	}
+
+	sitronix_ts_gpts.input_dev->name = SITRONIX_I2C_TOUCH_MT_INPUT_DEV_NAME;
+	sitronix_ts_gpts.input_dev->dev.parent = &client->dev;
+	sitronix_ts_gpts.input_dev->id.bustype = BUS_I2C;
+
+	set_bit(EV_KEY, sitronix_ts_gpts.input_dev->evbit);
+	set_bit(BTN_TOUCH, sitronix_ts_gpts.input_dev->keybit);
+	set_bit(EV_ABS, sitronix_ts_gpts.input_dev->evbit);
+
+	sitronix_ts_gpts.keyevent_input = input_allocate_device();
+	if (sitronix_ts_gpts.keyevent_input == NULL){
+		printk("Can not allocate memory for key input device.");
+		ret = -ENOMEM;
+		goto err_input_dev_alloc_failed;
+	}
+	sitronix_ts_gpts.keyevent_input->name  = SITRONIX_I2C_TOUCH_KEY_INPUT_DEV_NAME;
+	sitronix_ts_gpts.keyevent_input->dev.parent = &client->dev;
+	set_bit(EV_KEY, sitronix_ts_gpts.keyevent_input->evbit);
+	for(i = 0; i < (sizeof(sitronix_sensor_key_array)/sizeof(struct sitronix_sensor_key_t)); i++){
+		set_bit(sitronix_sensor_key_array[i].code, sitronix_ts_gpts.keyevent_input->keybit);
+	}
+#ifdef SITRONIX_SMART_WAKE_UP
+	set_bit(KEY_POWER, sitronix_ts_gpts.keyevent_input->keybit);
+#endif	//SITRONIX_SMART_WAKE_UP
+
+#ifndef SITRONIX_AA_KEY
+	max_x = sitronix_ts_gpts.resolution_x;
+	max_y = sitronix_ts_gpts.resolution_y;
+#else
+#ifdef SITRONIX_KEY_BOUNDARY_MANUAL_SPECIFY
+	for(i = 0; i < (sizeof(sitronix_aa_key_array)/sizeof(struct sitronix_AA_key)); i++){
+		set_bit(sitronix_aa_key_array[i].code, sitronix_ts_gpts.keyevent_input->keybit);
+	}
+	max_x = SITRONIX_TOUCH_RESOLUTION_X;
+	max_y = SITRONIX_TOUCH_RESOLUTION_Y;
+#else
+	for(i = 0; i < (sizeof(sitronix_aa_key_array)/sizeof(struct sitronix_AA_key)); i++){
+		sitronix_aa_key_array[i].x_low = ((sitronix_ts_gpts.resolution_x / (sizeof(sitronix_aa_key_array)/sizeof(struct sitronix_AA_key)) ) * i ) + 15;
+		sitronix_aa_key_array[i].x_high = ((sitronix_ts_gpts.resolution_x / (sizeof(sitronix_aa_key_array)/sizeof(struct sitronix_AA_key)) ) * (i + 1)) - 15;
+		sitronix_aa_key_array[i].y_low = sitronix_ts_gpts.resolution_y - sitronix_ts_gpts.resolution_y / SCALE_KEY_HIGH_Y;
+		sitronix_aa_key_array[i].y_high = sitronix_ts_gpts.resolution_y;
+		DbgMsg("key[%d] %d, %d, %d, %d\n", i, sitronix_aa_key_array[i].x_low, sitronix_aa_key_array[i].x_high, sitronix_aa_key_array[i].y_low, sitronix_aa_key_array[i].y_high);
+		set_bit(sitronix_aa_key_array[i].code, sitronix_ts_gpts.keyevent_input->keybit);
+	}
+	max_x = sitronix_ts_gpts.resolution_x;
+	max_y = sitronix_ts_gpts.resolution_y - sitronix_ts_gpts.resolution_y / SCALE_KEY_HIGH_Y;
+#endif // SITRONIX_KEY_BOUNDARY_MANUAL_SPECIFY
+#endif // SITRONIX_AA_KEY
+	ret = input_register_device(sitronix_ts_gpts.keyevent_input);
+	if(ret < 0){
+		printk("Can not register key input device.");
+		goto err_input_register_device_failed;
+	}
+
+#ifdef SITRONIX_SUPPORT_MT_SLOT
+	input_mt_init_slots(sitronix_ts_gpts.input_dev, sitronix_ts_gpts.max_touches);
+#else
+	__set_bit(ABS_X, sitronix_ts_gpts.input_dev->absbit);
+	__set_bit(ABS_Y, sitronix_ts_gpts.input_dev->absbit);
+	__set_bit(ABS_MT_TOUCH_MAJOR, sitronix_ts_gpts.input_dev->absbit);
+	__set_bit(ABS_MT_WIDTH_MAJOR, sitronix_ts_gpts.input_dev->absbit);
+	__set_bit(ABS_MT_POSITION_X, sitronix_ts_gpts.input_dev->absbit);
+	__set_bit(ABS_MT_POSITION_Y, sitronix_ts_gpts.input_dev->absbit);
+	__set_bit(ABS_MT_TOOL_TYPE, sitronix_ts_gpts.input_dev->absbit);
+	__set_bit(ABS_MT_BLOB_ID, sitronix_ts_gpts.input_dev->absbit);
+	__set_bit(ABS_MT_TRACKING_ID, sitronix_ts_gpts.input_dev->absbit);
+	__set_bit(INPUT_PROP_DIRECT, sitronix_ts_gpts.input_dev->propbit);
+
+	input_set_abs_params(sitronix_ts_gpts.input_dev, ABS_MT_TOUCH_MAJOR, 0,  255, 0, 0);
+	input_set_abs_params(sitronix_ts_gpts.input_dev, ABS_MT_WIDTH_MAJOR, 0,  255, 0, 0);
+	input_set_abs_params(sitronix_ts_gpts.input_dev, ABS_MT_TRACKING_ID, 0, sitronix_ts_gpts.max_touches, 0, 0);
+	input_set_abs_params(sitronix_ts_gpts.input_dev, ABS_PRESSURE, 0, 255, 0, 0);
+#endif // SITRONIX_SUPPORT_MT_SLOT
+#ifndef SITRONIX_SWAP_XY
+	input_set_abs_params(sitronix_ts_gpts.input_dev, ABS_MT_POSITION_X, 0, max_x - 1, 0, 0);
+	input_set_abs_params(sitronix_ts_gpts.input_dev, ABS_MT_POSITION_Y, 0, max_y - 1, 0, 0);
+#else
+	input_set_abs_params(sitronix_ts_gpts.input_dev, ABS_MT_POSITION_X, 0, max_y - 1, 0, 0);
+	input_set_abs_params(sitronix_ts_gpts.input_dev, ABS_MT_POSITION_Y, 0, max_x - 1, 0, 0);
+#endif // SITRONIX_SWAP_XY
+
+	ret = input_register_device(sitronix_ts_gpts.input_dev);
+	if(ret < 0){
+		printk("Can not register input device.\n");
+		goto err_input_register_device_failed;
+	}
+
+#ifdef CONFIG_ARCH_MSM
+	gpio_tlmm_config(GPIO_CFG(SITRONIX_INT_GPIO, 0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA), GPIO_CFG_ENABLE);
+#endif // CONFIG_ARCH_MSM
+
+#ifdef SITRONIX_MULTI_SLAVE_ADDR
+#if defined(CONFIG_MACH_OMAP4_PANDA)
+	client->irq = OMAP_GPIO_IRQ(SITRONIX_INT_GPIO);
+#endif //defined(CONFIG_MACH_OMAP4_PANDA)
+#endif // SITRONIX_MULTI_SLAVE_ADDR
+	if (client->irq){
+		dev_info(&client->dev, "irq = %d\n", client->irq);
+#ifdef SITRONIX_LEVEL_TRIGGERED
+		ret = request_irq(client->irq, sitronix_ts_irq_handler, IRQF_TRIGGER_LOW | IRQF_DISABLED, client->name, &sitronix_ts_gpts);
+#else
+		ret = request_irq(client->irq, sitronix_ts_irq_handler, IRQF_TRIGGER_FALLING | IRQF_DISABLED, client->name, &sitronix_ts_gpts);
+#endif // SITRONIX_LEVEL_TRIGGERED
+		if (ret == 0){
+			atomic_set(&sitronix_ts_irq_on, 1);
+			sitronix_ts_gpts.use_irq = 1;
+		}else{
+			dev_err(&client->dev, "request_irq failed\n");
+			goto err_request_irq_failed;
+		}
+	}
+
+#ifdef SITRONIX_SYSFS
+	if(!sitronix_ts_sysfs_created){
+		ret = sitronix_ts_create_sysfs_entry(client);
+		if(ret < 0)
+			goto err_create_sysfs_failed;
+		sitronix_ts_sysfs_created = true;
+	}
+#endif // SITRONIX_SYSFS
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	sitronix_ts_gpts.early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	sitronix_ts_gpts.early_suspend.suspend = sitronix_ts_early_suspend;
+	sitronix_ts_gpts.early_suspend.resume = sitronix_ts_late_resume;
+	register_early_suspend(&sitronix_ts_gpts.early_suspend);
+#endif // CONFIG_HAS_EARLYSUSPEND
+	return 0;
+err_create_sysfs_failed:
+err_request_irq_failed:
+#ifdef SITRONIX_SYSFS
+	input_unregister_device(sitronix_ts_gpts.input_dev);
+	input_unregister_device(sitronix_ts_gpts.keyevent_input);
+#endif // SITRONIX_SYSFS
+err_input_register_device_failed:
+err_input_dev_alloc_failed:
+	if(sitronix_ts_gpts.input_dev)
+		input_free_device(sitronix_ts_gpts.input_dev);
+	if(sitronix_ts_gpts.keyevent_input)
+		input_free_device(sitronix_ts_gpts.keyevent_input);
+#ifdef SITRONIX_MONITOR_THREAD
+	if(sitronix_ts_gpts.enable_monitor_thread == 1){
+		if(SitronixMonitorThread){
+		      kthread_stop(SitronixMonitorThread);
+		      SitronixMonitorThread = NULL;
+		}
+	}
+#endif // SITRONIX_MONITOR_THREAD
+err_device_info_error:
+err_check_functionality_failed:
+	return ret;
+}
+
+static int sitronix_ts_remove(struct i2c_client *client)
+{
+	struct sitronix_ts_data *ts = i2c_get_clientdata(client);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&ts->early_suspend);
+#endif // CONFIG_HAS_EARLYSUSPEND
+#ifdef SITRONIX_SYSFS
+	if(!sitronix_ts_sysfs_using){
+		sitronix_ts_destroy_sysfs_entry(client);
+		sitronix_ts_sysfs_created = false;
+	}
+#endif // SITRONIX_SYSFS
+#ifdef SITRONIX_MONITOR_THREAD
+	if(ts->enable_monitor_thread == 1){
+		if(SitronixMonitorThread){
+		      kthread_stop(SitronixMonitorThread);
+		      SitronixMonitorThread = NULL;
+		}
+	}
+#endif // SITRONIX_MONITOR_THREAD
+	i2c_set_clientdata(client, NULL);
+	if (ts->use_irq)
+		free_irq(client->irq, ts);
+	if(ts->input_dev)
+		input_unregister_device(ts->input_dev);
+	if(ts->keyevent_input)
+		input_unregister_device(ts->keyevent_input);
+	return 0;
+}
+
+static int sitronix_ts_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	int ret;
+	struct sitronix_ts_data *ts = i2c_get_clientdata(client);
+
+	DbgMsg("%s\n", __FUNCTION__);
+//2.9.15 petitk add
+#ifdef SITRONIX_SMART_WAKE_UP
+	sitronix_swk_set_swk_enable(ts);
+#endif //SITRONIX_SMART_WAKE_UP
+
+#ifdef SITRONIX_MONITOR_THREAD
+	if(ts->enable_monitor_thread == 1){
+		if(SitronixMonitorThread){
+			kthread_stop(SitronixMonitorThread);
+			SitronixMonitorThread = NULL;
+		}
+		sitronix_ts_delay_monitor_thread_start = DELAY_MONITOR_THREAD_START_RESUME;
+	}
+#endif // SITRONIX_MONITOR_THREAD
+	if(ts->use_irq){
+		atomic_set(&sitronix_ts_irq_on, 0);
+		disable_irq_nosync(ts->client->irq);
+	}
+	ts->suspend_state = 1;
+
+	ret = sitronix_ts_set_powerdown_bit(ts, 1);
+	if(ts->chip_id == 2){
+#ifdef CONFIG_ARCH_MSM
+		gpio_tlmm_config(GPIO_CFG(SITRONIX_INT_GPIO, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA), GPIO_CFG_ENABLE);
+		gpio_set_value(SITRONIX_INT_GPIO, 1);
+#else
+		//gpio_direction_output(irq_to_gpio(client->irq), 1);
+#endif // CONFIG_ARCH_MSM
+	}
+	DbgMsg("%s return\n", __FUNCTION__);
+
+	return 0;
+}
+
+static int sitronix_ts_resume(struct i2c_client *client)
+{
+	int ret;
+	struct sitronix_ts_data *ts = i2c_get_clientdata(client);
+
+	DbgMsg("%s\n", __FUNCTION__);
+
+	if(ts->chip_id == 2){
+#ifdef CONFIG_ARCH_MSM
+		gpio_set_value(SITRONIX_INT_GPIO, 0);
+		gpio_tlmm_config(GPIO_CFG(SITRONIX_INT_GPIO, 0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA), GPIO_CFG_ENABLE);
+#else
+		//ret = irq_to_gpio(client->irq);
+		//gpio_set_value(ret, 0);
+		//gpio_direction_input(ret);
+#endif // CONFIG_ARCH_MSM
+	}else{
+		ret = sitronix_ts_set_powerdown_bit(ts, 0);
+	}
+
+	ts->suspend_state = 0;
+	if(ts->use_irq){
+		atomic_set(&sitronix_ts_irq_on, 1);
+		enable_irq(ts->client->irq);
+	}
+#ifdef SITRONIX_MONITOR_THREAD
+	if(ts->enable_monitor_thread == 1){
+		atomic_set(&iMonitorThreadPostpone,1);
+		SitronixMonitorThread = kthread_run(sitronix_ts_gpts.sitronix_mt_fp,"Sitronix","Monitorthread");
+		if(IS_ERR(SitronixMonitorThread))
+			SitronixMonitorThread = NULL;
+	}
+#endif // SITRONIX_MONITOR_THREAD
+	DbgMsg("%s return\n", __FUNCTION__);
+
+	return 0;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void sitronix_ts_early_suspend(struct early_suspend *h)
+{
+	struct sitronix_ts_data *ts;
+	DbgMsg("%s\n", __FUNCTION__);
+	ts = container_of(h, struct sitronix_ts_data, early_suspend);
+	sitronix_ts_suspend(ts->client, PMSG_SUSPEND);
+}
+
+static void sitronix_ts_late_resume(struct early_suspend *h)
+{
+	struct sitronix_ts_data *ts;
+	DbgMsg("%s\n", __FUNCTION__);
+	ts = container_of(h, struct sitronix_ts_data, early_suspend);
+	sitronix_ts_resume(ts->client);
+}
+#endif // CONFIG_HAS_EARLYSUSPEND
+
+static const struct i2c_device_id sitronix_ts_id[] = {
+	{ SITRONIX_I2C_TOUCH_DRV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, sitronix_ts_id);
+
+static const struct of_device_id sitronix_ts_of_match[] = {
+	{ .compatible = "sitronix,sitronix_i2c", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, sitronix_ts_of_match);
+
+#ifdef SITRONIX_MULTI_SLAVE_ADDR
+static int sitronix_ts_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+	uint8_t buffer[8];
+	sitronix_ts_reset_ic();
+	printk("%s: bus = %d\n", __FUNCTION__, client->adapter->nr);
+	if((client->adapter->nr == 3) && (!sitronix_i2c_read_bytes(client, STATUS_REG, buffer, 8))){
+		printk("detect successed\n");
+		strlcpy(info->type, SITRONIX_I2C_TOUCH_DRV_NAME, strlen(SITRONIX_I2C_TOUCH_DRV_NAME)+1);
+		return 0;
+	}else{
+		printk("detect failed\n");
+		return -ENODEV;
+	}
+}
+
+const unsigned short sitronix_i2c_addr[] = {0x38, 0x53, 0x70, I2C_CLIENT_END};
+#endif // SITRONIX_MULTI_SLAVE_ADDR
+
+static struct i2c_driver sitronix_ts_driver = {
+#ifdef SITRONIX_MULTI_SLAVE_ADDR
+	.class 		= I2C_CLASS_HWMON,
+#endif // SITRONIX_MULTI_SLAVE_ADDR
+	.probe		= sitronix_ts_probe,
+	.remove		= sitronix_ts_remove,
+	.id_table	= sitronix_ts_id,
+	.driver = {
+		.name	= SITRONIX_I2C_TOUCH_DRV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = sitronix_ts_of_match,
+	},
+#ifdef SITRONIX_MULTI_SLAVE_ADDR
+	.address_list = sitronix_i2c_addr,
+	.detect = sitronix_ts_detect,
+#endif // SITRONIX_MULTI_SLAVE_ADDR
+};
+
+#ifdef SITRONIX_FW_UPGRADE_FEATURE
+static struct file_operations nc_fops = {
+	.owner =        THIS_MODULE,
+	.write		= sitronix_write,
+	.read		= sitronix_read,
+	.open		= sitronix_open,
+	.unlocked_ioctl = sitronix_ioctl,
+	.release	= sitronix_release,
+};
+#endif // SITRONIX_FW_UPGRADE_FEATURE
+void sitronix_ts_reprobe(void)
+{
+	int retval = 0;
+	i2c_del_driver(&sitronix_ts_driver);
+	retval = i2c_add_driver(&sitronix_ts_driver);
+	if(retval < 0)
+		printk("fail to reprobe driver!\n");
+}
+
+static int __init 
+sitronix_ts_init(void)
+{
+#ifdef SITRONIX_FW_UPGRADE_FEATURE
+	int result;
+	int err = 0;
+	dev_t devno = MKDEV(sitronix_major, 0);
+#endif // SITRONIX_FW_UPGRADE_FEATURE
+	printk("Sitronix touch driver %d.%d.%d\n", DRIVER_MAJOR, DRIVER_MINOR, DRIVER_PATCHLEVEL);
+	printk("Release date: %s\n", DRIVER_DATE);
+#ifdef SITRONIX_FW_UPGRADE_FEATURE
+	result  = alloc_chrdev_region(&devno, 0, 1, SITRONIX_I2C_TOUCH_DEV_NAME);
+	if(result < 0){
+		printk("fail to allocate chrdev (%d) \n", result);
+		return 0;
+	}
+	sitronix_major = MAJOR(devno);
+	cdev_init(&sitronix_cdev, &nc_fops);
+	sitronix_cdev.owner = THIS_MODULE;
+	sitronix_cdev.ops = &nc_fops;
+        err =  cdev_add(&sitronix_cdev, devno, 1);
+	if(err){
+		printk("fail to add cdev (%d) \n", err);
+		return 0;
+	}
+
+	sitronix_class = class_create(THIS_MODULE, SITRONIX_I2C_TOUCH_DEV_NAME);
+	if (IS_ERR(sitronix_class)) {
+		result = PTR_ERR(sitronix_class);
+		unregister_chrdev(sitronix_major, SITRONIX_I2C_TOUCH_DEV_NAME);
+		printk("fail to create class (%d) \n", result);
+		return result;
+	}
+	device_create(sitronix_class, NULL, MKDEV(sitronix_major, 0), NULL, SITRONIX_I2C_TOUCH_DEV_NAME);
+#ifdef SITRONIX_PERMISSION_THREAD
+	SitronixPermissionThread = kthread_run(sitronix_ts_permission_thread,"Sitronix","Permissionthread");
+	if(IS_ERR(SitronixPermissionThread))
+		SitronixPermissionThread = NULL;
+#endif // SITRONIX_PERMISSION_THREAD
+#endif // SITRONIX_FW_UPGRADE_FEATURE
+	return i2c_add_driver(&sitronix_ts_driver);
+}
+
+static void __exit 
+sitronix_ts_exit(void)
+{
+#ifdef SITRONIX_FW_UPGRADE_FEATURE
+	dev_t dev_id = MKDEV(sitronix_major, 0);
+#endif // SITRONIX_FW_UPGRADE_FEATURE
+	i2c_del_driver(&sitronix_ts_driver);
+#ifdef SITRONIX_FW_UPGRADE_FEATURE
+	cdev_del(&sitronix_cdev);
+
+	device_destroy(sitronix_class, dev_id); //delete device node under /dev
+	class_destroy(sitronix_class); //delete class created by us
+	unregister_chrdev_region(dev_id, 1);
+#ifdef SITRONIX_PERMISSION_THREAD
+	if(SitronixPermissionThread)
+		SitronixPermissionThread = NULL;
+#endif // SITRONIX_PERMISSION_THREAD
+#endif // SITRONIX_FW_UPGRADE_FEATURE
+}
+
+module_init(sitronix_ts_init);
+module_exit(sitronix_ts_exit);
+
+MODULE_DESCRIPTION("Sitronix Multi-Touch Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/touchscreen/sitronix_i2c_touch.h b/drivers/input/touchscreen/sitronix_i2c_touch.h
new file mode 100644
index 0000000..e2fa549
--- /dev/null
+++ b/drivers/input/touchscreen/sitronix_i2c_touch.h
@@ -0,0 +1,271 @@
+/*
+ * drivers/input/touchscreen/sitronix_i2c_touch.h
+ *
+ * Touchscreen driver for Sitronix
+ *
+ * Copyright (C) 2011 Sitronix Technology Co., Ltd.
+ *	Rudy Huang <rudy_huang@sitronix.com.tw>
+ */
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+#ifndef __SITRONIX_I2C_TOUCH_h
+#define __SITRONIX_I2C_TOUCH_h
+
+#include <linux/ioctl.h> /* needed for the _IOW etc stuff used later */
+
+#define SITRONIX_TOUCH_DRIVER_VERSION 0x03
+#define SITRONIX_MAX_SUPPORTED_POINT 10
+#define SITRONIX_I2C_TOUCH_DRV_NAME "sitronix"
+#define SITRONIX_I2C_TOUCH_DEV_NAME "sitronixDev"
+#define SITRONIX_I2C_TOUCH_MT_INPUT_DEV_NAME "sitronix-i2c-touch-mt"
+#define SITRONIX_I2C_TOUCH_KEY_INPUT_DEV_NAME "sitronix-i2c-touch-key"
+
+#ifdef CONFIG_MACH_DEVKIT8000
+#define SITRONIX_RESET_GPIO	170
+#define SITRONIX_INT_GPIO	157
+#elif defined(CONFIG_MACH_OMAP4_PANDA)
+#define SITRONIX_RESET_GPIO	44
+#define SITRONIX_INT_GPIO	47
+#elif defined(CONFIG_ARCH_MSM8X60)
+#define SITRONIX_RESET_GPIO	58
+#define SITRONIX_INT_GPIO	61
+#endif // CONFIG_MACH_DEVKIT8000
+
+// MT SLOT feature is implmented in linux kernel 2.6.38 and later. Make sure that version of your linux kernel before using this feature.
+//#define SITRONIX_SUPPORT_MT_SLOT
+//#define SITRONIX_SWAP_XY
+//#define SITRONIX_I2C_COMBINED_MESSAGE
+#ifndef SITRONIX_I2C_COMBINED_MESSAGE
+#define SITRONIX_I2C_SINGLE_MESSAGE
+#endif // SITRONIX_I2C_COMBINED_MESSAGE
+//#define SITRONIX_MONITOR_THREAD
+#define DELAY_MONITOR_THREAD_START_PROBE 10000
+#define DELAY_MONITOR_THREAD_START_RESUME 3000
+#define SITRONIX_FW_UPGRADE_FEATURE
+//#define SITRONIX_PERMISSION_THREAD
+#define SITRONIX_SYSFS
+#define SITRONIX_LEVEL_TRIGGERED
+//#define SITRONIX_SMART_WAKE_UP
+
+// When enable_irq() is invoked, irq will be sent once while INT is not triggered if CONFIG_HARDIRQS_SW_RESEND is set.
+// This behavior is implemented by linux kernel, it is used to prevent irq from losting when irq is edge-triggered mode.
+#ifndef SITRONIX_LEVEL_TRIGGERED
+#define SITRONIX_INT_POLLING_MODE
+#define INT_POLLING_MODE_INTERVAL 14
+#endif // SITRONIX_LEVEL_TRIGGERED
+//#define SITRONIX_IDENTIFY_ID
+//#define SITRONIX_MULTI_SLAVE_ADDR
+
+//#define EnableDbgMsg 1
+//#define EnableUpgradeMsg 1
+
+#ifdef EnableDbgMsg
+#define DbgMsg(arg...) printk(arg)
+#else
+#define DbgMsg(arg...)
+#endif
+
+#ifdef EnableUpgradeMsg
+#define UpgradeMsg(arg...) printk(arg)
+#else
+#define UpgradeMsg(arg...)
+#endif
+
+typedef enum{
+	FIRMWARE_VERSION,
+	STATUS_REG,
+	DEVICE_CONTROL_REG,
+	TIMEOUT_TO_IDLE_REG,
+	XY_RESOLUTION_HIGH,
+	X_RESOLUTION_LOW,
+	Y_RESOLUTION_LOW,
+	DEVICE_CONTROL_REG2 = 0x09,
+	FIRMWARE_REVISION_3 = 0x0C,
+	FIRMWARE_REVISION_2,
+	FIRMWARE_REVISION_1,
+	FIRMWARE_REVISION_0,
+	FINGERS,
+	KEYS_REG,
+	XY0_COORD_H,
+	X0_COORD_L,
+	Y0_COORD_L,
+	I2C_PROTOCOL = 0x3E,
+	MAX_NUM_TOUCHES,
+	DATA_0_HIGH,
+	DATA_0_LOW,
+	MISC_CONTROL = 0xF1,
+	SMART_WAKE_UP_REG = 0xF2,
+	CHIP_ID = 0xF4,
+	PAGE_REG = 0xff,
+}RegisterOffset;
+
+typedef enum{
+	NO = 0x0,
+	CHARACTER_C	    = 0x63,
+	CHARACTER_E	    = 0x65,
+	CHARACTER_M	    = 0x6D,
+	CHARACTER_O	    = 0x6F,
+	CHARACTER_S	    = 0x73,
+	CHARACTER_V	    = 0x76,
+	CHARACTER_W	    = 0x77,
+	CHARACTER_Z	    = 0x7A,
+	LEFT_TO_RIGHT_SLIDE = 0xB0,
+	RIGHT_TO_LEFT_SLIDE = 0xB4,
+	TOP_TO_DOWN_SLIDE   = 0xB8,
+	DOWN_TO_UP_SLIDE    = 0xBC,
+	DOUBLE_CLICK	    = 0xC0,
+}SWK_ID;
+
+#define SITRONIX_TS_CHANGE_MODE_DELAY 150
+
+typedef enum{
+	XY_COORD_H,
+	X_COORD_L,
+	Y_COORD_L,
+	PIXEL_DATA_LENGTH_B,
+	PIXEL_DATA_LENGTH_A,
+}PIXEL_DATA_FORMAT;
+
+#define X_RES_H_SHFT 4
+#define X_RES_H_BMSK 0xf
+#define Y_RES_H_SHFT 0
+#define Y_RES_H_BMSK 0xf
+#define FINGERS_SHFT 0
+#define FINGERS_BMSK 0xf
+#define X_COORD_VALID_SHFT 7
+#define X_COORD_VALID_BMSK 0x1
+#define X_COORD_H_SHFT 4
+#define X_COORD_H_BMSK 0x7
+#define Y_COORD_H_SHFT 0
+#define Y_COORD_H_BMSK 0x7
+
+typedef enum{
+	SITRONIX_RESERVED_TYPE_0,
+	SITRONIX_A_TYPE,
+	SITRONIX_B_TYPE,
+}I2C_PROTOCOL_TYPE;
+
+#define I2C_PROTOCOL_SHFT 0x0
+#define I2C_PROTOCOL_BMSK 0x3
+
+typedef enum{
+	SENSING_BOTH,
+	SENSING_X_ONLY,
+	SENSING_Y_ONLY,
+	SENSING_BOTH_NOT,
+}ONE_D_SENSING_CONTROL_MODE;
+
+#define ONE_D_SENSING_CONTROL_SHFT 0x2
+#define ONE_D_SENSING_CONTROL_BMSK 0x3
+
+#define SMT_IOC_MAGIC   0xf1
+
+enum{
+	SMT_GET_DRIVER_REVISION = 1,
+	SMT_GET_FW_REVISION,
+	SMT_ENABLE_IRQ,
+	SMT_DISABLE_IRQ,
+	SMT_RESUME,
+	SMT_SUSPEND,
+	SMT_HW_RESET,
+	SMT_REPROBE,
+	SMT_IOC_MAXNR,
+};
+
+#define IOCTL_SMT_GET_DRIVER_REVISION				_IOC(_IOC_READ,  SMT_IOC_MAGIC, SMT_GET_DRIVER_REVISION, 			1)
+#define IOCTL_SMT_GET_FW_REVISION					_IOC(_IOC_READ,  SMT_IOC_MAGIC, SMT_GET_FW_REVISION, 				4)
+#define IOCTL_SMT_ENABLE_IRQ					_IOC(_IOC_NONE, SMT_IOC_MAGIC, SMT_ENABLE_IRQ, 0)
+#define IOCTL_SMT_DISABLE_IRQ					_IOC(_IOC_NONE, SMT_IOC_MAGIC, SMT_DISABLE_IRQ, 0)
+#define IOCTL_SMT_RESUME					_IOC(_IOC_NONE, SMT_IOC_MAGIC, SMT_RESUME, 0)
+#define IOCTL_SMT_SUSPEND					_IOC(_IOC_NONE, SMT_IOC_MAGIC, SMT_SUSPEND, 0)
+#define IOCTL_SMT_HW_RESET					_IOC(_IOC_NONE, SMT_IOC_MAGIC, SMT_HW_RESET, 0)
+#define IOCTL_SMT_REPROBE					_IOC(_IOC_NONE, SMT_IOC_MAGIC, SMT_REPROBE, 0)
+
+//#define SITRONIX_AA_KEY
+#define SITRONIX_KEY_BOUNDARY_MANUAL_SPECIFY
+
+typedef struct {
+	u8 y_h		:3,
+	   reserved	:1,
+	   x_h		:3,
+	   valid	:1;
+	u8 x_l;
+	u8 y_l;
+	u8 z;
+}xy_data_t;
+
+typedef struct {
+	xy_data_t	xy_data[SITRONIX_MAX_SUPPORTED_POINT];
+}stx_report_data_t;
+
+struct sitronix_sensor_key_t{
+	unsigned int code;
+};
+
+#ifndef SITRONIX_AA_KEY
+enum{
+	AREA_NONE,
+	AREA_DISPLAY,
+};
+#else
+enum{
+	AREA_NONE,
+	AREA_DISPLAY,
+	AREA_KEY,
+	AREA_INVALID,
+};
+
+struct sitronix_AA_key{
+	int x_low;
+	int x_high;
+	int y_low;
+	int y_high;
+	unsigned int code;
+};
+#endif // SITRONIX_AA_KEY
+
+typedef struct {
+	uint8_t offset;
+	uint8_t shft;
+	uint8_t bmsk;
+}sitronix_reg_field;
+
+typedef struct {
+	sitronix_reg_field dis_coord_flag;
+}sitronix_i2c_protocol_map;
+
+static sitronix_i2c_protocol_map sitronix_i2c_ptcl_v1 = {
+	.dis_coord_flag = {
+		.offset = 0x09,
+		.shft = 0,
+		.bmsk = 0x1,
+	},
+};
+
+static sitronix_i2c_protocol_map sitronix_i2c_ptcl_v2 = {
+	.dis_coord_flag = {
+		.offset = 0xF1,
+		.shft = 2,
+		.bmsk = 0x1,
+	},
+};
+
+struct sitronix_i2c_touch_platform_data {
+	uint32_t version;	/* Use this entry for panels with */
+				/* (major << 8 | minor) version or above. */
+				/* If non-zero another array entry follows */
+	void (*reset_ic)(void);
+};
+
+//petitk add
+
+//#define CONFIG_TOUCHSCREEN_SITRONIX_I2C_TOUCH
+//#define KERN_DEBUG    "<7>"    /* debug-level messages */
+////////////
+
+#endif // __SITRONIX_I2C_TOUCH_h
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index 459c14c..f3d1da4 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -1215,6 +1215,14 @@ config MFD_STW481X
 	  in various ST Microelectronics and ST-Ericsson embedded
 	  Nomadik series.
 
+config MFD_BD7181X
+	bool "BD71815/BD71817 Power Management chip"
+	depends on I2C=y
+	select MFD_CORE
+	help
+	  if you say yes here you get support for the BD71815/BD71817
+	  Power Management chips.
+
 endmenu
 endif
 
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index c0aedc3..e75359c 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -168,3 +168,4 @@ obj-$(CONFIG_MFD_AS3711)	+= as3711.o
 obj-$(CONFIG_MFD_AS3722)	+= as3722.o
 obj-$(CONFIG_MFD_STW481X)	+= stw481x.o
 obj-$(CONFIG_MFD_MXC_HDMI)	+= mxc-hdmi-core.o
+obj-$(CONFIG_MFD_BD7181X)	+= bd7181x.o
diff --git a/drivers/mfd/bd7181x.c b/drivers/mfd/bd7181x.c
new file mode 100644
index 0000000..942b7fc
--- /dev/null
+++ b/drivers/mfd/bd7181x.c
@@ -0,0 +1,382 @@
+/*
+ * @file bd7181x.c  --  RoHM BD7181X/BD71817 mfd driver
+ * 
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under  the terms of the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ * @author: Tony Luo <luofc@embedinfo.com>
+ * Copyright 2014 Embest Technology Co. Ltd. Inc.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/gpio.h>
+#include <linux/regmap.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/mfd/core.h>
+#include <linux/mfd/bd7181x.h>
+
+/** @brief bd7181x irq resource */
+static struct resource rtc_resources[] = {
+	{
+		.start  = BD7181X_IRQ_ALARM_12,
+		.end    = BD7181X_IRQ_ALARM_12,
+		.flags  = IORESOURCE_IRQ,
+	}
+};
+
+static struct resource power_resources[] = {
+	// irq# 0
+	{
+		.start	= BD7181X_IRQ_DCIN_03,
+		.end	= BD7181X_IRQ_DCIN_03,
+		.flags	= IORESOURCE_IRQ,
+	},
+	// irq# 1
+	{
+		.start	= BD7181X_IRQ_BAT_MON_08,
+		.end	= BD7181X_IRQ_BAT_MON_08,
+		.flags	= IORESOURCE_IRQ,
+	},
+	// irq# 2
+	{
+		.start	= BD7181X_IRQ_TEMPERATURE_11,
+		.end	= BD7181X_IRQ_TEMPERATURE_11,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+/** @brief bd7181x multi function cells */
+static struct mfd_cell bd7181x_mfd_cells[] = {
+	{
+		.name = "bd7181x-pmic",
+	},
+	{
+		.name = "bd7181x-power",
+		.num_resources = ARRAY_SIZE(power_resources),
+		.resources = &power_resources[0],
+	},
+	{
+		.name = "bd7181x-gpo",
+	},
+	{
+		.name = "bd7181x-rtc",
+		.num_resources = ARRAY_SIZE(rtc_resources),
+		.resources = &rtc_resources[0],
+	},
+};
+
+/** @brief bd7181x irqs */
+static const struct regmap_irq bd7181x_irqs[] = {
+	[BD7181X_IRQ_BUCK_01] = {
+		.mask = BD7181X_INT_EN_01_BUCKAST_MASK,
+		.reg_offset = 1,
+	},
+	[BD7181X_IRQ_DCIN_02] = {
+		.mask = BD7181X_INT_EN_02_DCINAST_MASK,
+		.reg_offset = 2,
+	},
+	[BD7181X_IRQ_DCIN_03] = {
+		.mask = BD7181X_INT_EN_03_DCINAST_MASK,
+		.reg_offset = 3,
+	},
+	[BD7181X_IRQ_VSYS_04] = {
+		.mask = BD7181X_INT_EN_04_VSYSAST_MASK,
+		.reg_offset = 4,
+	},
+	[BD7181X_IRQ_CHARGE_05] = {
+		.mask = BD7181X_INT_EN_05_CHGAST_MASK,
+		.reg_offset = 5,
+	},
+	[BD7181X_IRQ_BAT_06] = {
+		.mask = BD7181X_INT_EN_06_BATAST_MASK,
+		.reg_offset = 6,
+	},
+	[BD7181X_IRQ_BAT_MON_07] = {
+		.mask = BD7181X_INT_EN_07_BMONAST_MASK,
+		.reg_offset = 7,
+	},
+	[BD7181X_IRQ_BAT_MON_08] = {
+		.mask = BD7181X_INT_EN_08_BMONAST_MASK,
+		.reg_offset = 8,
+	},
+	[BD7181X_IRQ_BAT_MON_09] = {
+		.mask = BD7181X_INT_EN_09_BMONAST_MASK,
+		.reg_offset = 9,
+	},
+	[BD7181X_IRQ_BAT_MON_10] = {
+		.mask = BD7181X_INT_EN_10_BMONAST_MASK,
+		.reg_offset = 10,
+	},
+	[BD7181X_IRQ_TEMPERATURE_11] = {
+		.mask = BD7181X_INT_EN_11_TMPAST_MASK,
+		.reg_offset = 11,
+	},
+	[BD7181X_IRQ_ALARM_12] = {
+		.mask = BD7181X_INT_EN_12_ALMAST_MASK,
+		.reg_offset = 12,
+	},
+};
+
+/** @brief bd7181x irq chip definition */
+static struct regmap_irq_chip bd7181x_irq_chip = {
+	.name = "bd7181x",
+	.irqs = bd7181x_irqs,
+	.num_irqs = ARRAY_SIZE(bd7181x_irqs),
+	.num_regs = 13,
+	.irq_reg_stride = 1,
+	.status_base = BD7181X_REG_INT_STAT,
+	.mask_base = BD7181X_REG_INT_EN_01 - 1,
+	.mask_invert = true,
+	// .ack_base = BD7181X_REG_INT_STAT_00,
+};
+
+/** @brief bd7181x irq initialize 
+ *  @param bd7181x bd7181x device to init
+ *  @param bdinfo platform init data
+ *  @retval 0 probe success
+ *  @retval negative error number
+ */
+static int bd7181x_irq_init(struct bd7181x *bd7181x, struct bd7181x_board* bdinfo) {
+	int irq;
+	int ret = 0;
+
+	if (!bdinfo) {
+		dev_warn(bd7181x->dev, "No interrupt support, no pdata\n");
+		return -EINVAL;
+	}
+	
+	irq = gpio_to_irq(bdinfo->gpio_intr);
+
+	bd7181x->chip_irq = irq;
+	printk("bd7181x->chip_irq=%d \n", bd7181x->chip_irq);
+	ret = regmap_add_irq_chip(bd7181x->regmap, bd7181x->chip_irq,
+		IRQF_ONESHOT | IRQF_TRIGGER_FALLING, bdinfo->irq_base,
+		&bd7181x_irq_chip, &bd7181x->irq_data);
+	if (ret < 0) {
+		dev_warn(bd7181x->dev, "Failed to add irq_chip %d\n", ret);
+	}
+	return ret;
+}
+
+/** @brief bd7181x irq initialize 
+ *  @param bd7181x bd7181x device to init
+ *  @retval 0 probe success
+ *  @retval negative error number
+ */
+static int bd7181x_irq_exit(struct bd7181x *bd7181x)
+{
+	if (bd7181x->chip_irq > 0)
+		regmap_del_irq_chip(bd7181x->chip_irq, bd7181x->irq_data);
+	return 0;
+}
+
+/** @brief check whether volatile register 
+ *  @param dev kernel device pointer
+ *  @param reg register index
+ */
+static bool is_volatile_reg(struct device *dev, unsigned int reg)
+{
+	// struct bd7181x *bd7181x = dev_get_drvdata(dev);
+
+	/*
+	 * Caching all regulator registers.
+	 */
+	return true;
+}
+
+/** @brief regmap configures */
+static const struct regmap_config bd7181x_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.volatile_reg = is_volatile_reg,
+	.max_register = BD7181X_MAX_REGISTER - 1,
+	.cache_type = REGCACHE_RBTREE,
+};
+
+#ifdef CONFIG_OF
+static struct of_device_id bd7181x_of_match[] = {
+	{ .compatible = "rohm,bd71815", .data = (void *)0},
+	{ .compatible = "rohm,bd71817", .data = (void *)1},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, bd7181x_of_match);
+
+
+/** @brief parse device tree data of bd7181x
+ *  @param client client object provided by system
+ *  @param chip_id return chip id back to caller
+ *  @return board initialize data
+ */
+static struct bd7181x_board *bd7181x_parse_dt(struct i2c_client *client,
+						int *chip_id)
+{
+	struct device_node *np = client->dev.of_node;
+	struct bd7181x_board *board_info;
+	unsigned int prop;
+	const struct of_device_id *match;
+	int r = 0;
+
+	match = of_match_device(bd7181x_of_match, &client->dev);
+	if (!match) {
+		dev_err(&client->dev, "Failed to find matching dt id\n");
+		return NULL;
+	}
+
+	*chip_id  = (int)match->data;
+
+	board_info = devm_kzalloc(&client->dev, sizeof(*board_info),
+			GFP_KERNEL);
+	if (!board_info) {
+		dev_err(&client->dev, "Failed to allocate pdata\n");
+		return NULL;
+	}
+
+	board_info->gpio_intr = of_get_named_gpio(np, "gpio_intr", 0);
+	if (!gpio_is_valid(board_info->gpio_intr)) {
+		dev_err(&client->dev, "no pmic intr pin available\n");
+		goto err_intr;
+	}
+
+	r = of_property_read_u32(np, "irq_base", &prop);
+	if (!r) {
+		board_info->irq_base = prop;
+	} else {
+		board_info->irq_base = -1;
+	}
+
+	return board_info;
+
+err_intr:
+	devm_kfree(&client->dev, board_info);
+	return NULL;
+}
+#else
+static inline
+struct bd7181x_board *bd7181x_parse_dt(struct i2c_client *client,
+					 int *chip_id)
+{
+	return NULL;
+}
+#endif
+
+/** @brief probe bd7181x device
+ *  @param i2c client object provided by system
+ *  @param id chip id
+ *  @retval 0 probe success
+ *  @retval negative error number
+ */
+static int bd7181x_i2c_probe(struct i2c_client *i2c,
+			    const struct i2c_device_id *id)
+{
+	struct bd7181x *bd7181x;
+	struct bd7181x_board *pmic_plat_data;
+	struct bd7181x_board *of_pmic_plat_data = NULL;
+	int chip_id = id->driver_data;
+	int ret = 0;
+
+	pmic_plat_data = dev_get_platdata(&i2c->dev);
+
+	if (!pmic_plat_data && i2c->dev.of_node) {
+		pmic_plat_data = bd7181x_parse_dt(i2c, &chip_id);
+		of_pmic_plat_data = pmic_plat_data;
+	}
+
+	if (!pmic_plat_data)
+		return -EINVAL;
+
+	bd7181x = kzalloc(sizeof(struct bd7181x), GFP_KERNEL);
+	if (bd7181x == NULL)
+		return -ENOMEM;
+
+	bd7181x->of_plat_data = of_pmic_plat_data;
+	i2c_set_clientdata(i2c, bd7181x);
+	bd7181x->dev = &i2c->dev;
+	bd7181x->i2c_client = i2c;
+	bd7181x->id = chip_id;
+	mutex_init(&bd7181x->io_mutex);
+
+	bd7181x->regmap = devm_regmap_init_i2c(i2c, &bd7181x_regmap_config);
+	if (IS_ERR(bd7181x->regmap)) {
+		ret = PTR_ERR(bd7181x->regmap);
+		dev_err(&i2c->dev, "regmap initialization failed: %d\n", ret);
+		return ret;
+	}
+
+	bd7181x_irq_init(bd7181x, of_pmic_plat_data);
+
+	ret = mfd_add_devices(bd7181x->dev, -1,
+			      bd7181x_mfd_cells, ARRAY_SIZE(bd7181x_mfd_cells),
+			      NULL, 0,
+			      regmap_irq_get_domain(bd7181x->irq_data));
+	if (ret < 0)
+		goto err;
+
+	return ret;
+
+err:
+	mfd_remove_devices(bd7181x->dev);
+	kfree(bd7181x);
+	return ret;
+}
+
+/** @brief remove bd7181x device
+ *  @param i2c client object provided by system
+ *  @return 0
+ */
+static int bd7181x_i2c_remove(struct i2c_client *i2c)
+{
+	struct bd7181x *bd7181x = i2c_get_clientdata(i2c);
+
+	bd7181x_irq_exit(bd7181x);
+	mfd_remove_devices(bd7181x->dev);
+	kfree(bd7181x);
+
+	return 0;
+}
+
+static const struct i2c_device_id bd7181x_i2c_id[] = {
+	{ "bd71815", 0 },
+	{ "bd71817", 1 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, bd7181x_i2c_id);
+
+
+static struct i2c_driver bd7181x_i2c_driver = {
+	.driver = {
+		.name = "bd7181x",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(bd7181x_of_match),
+	},
+	.probe = bd7181x_i2c_probe,
+	.remove = bd7181x_i2c_remove,
+	.id_table = bd7181x_i2c_id,
+};
+
+static int __init bd7181x_i2c_init(void)
+{
+	return i2c_add_driver(&bd7181x_i2c_driver);
+}
+/* init early so consumer devices can complete system boot */
+subsys_initcall(bd7181x_i2c_init);
+
+static void __exit bd7181x_i2c_exit(void)
+{
+	i2c_del_driver(&bd7181x_i2c_driver);
+}
+module_exit(bd7181x_i2c_exit);
+
+MODULE_AUTHOR("Tony Luo <luofc@embest-tech.com>");
+MODULE_AUTHOR("Peter Yang <yanglsh@embest-tech.com>");
+MODULE_DESCRIPTION("BD71815/BD71817 chip multi-function driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/Kconfig b/drivers/power/Kconfig
index 63a199b..614cc75 100644
--- a/drivers/power/Kconfig
+++ b/drivers/power/Kconfig
@@ -397,6 +397,13 @@ config BATTERY_GOLDFISH
 	  Say Y to enable support for the battery and AC power in the
 	  Goldfish emulator.
 
+
+config BD7181X_POWER
+        tristate "ROHM BD71815/BD71817 Charger for Battery and Adapter Power"
+        depends on MFD_BD7181X
+        help
+          Say Y to enable support for the BD71815/BD71817 charger.
+
 source "drivers/power/reset/Kconfig"
 
 endif # POWER_SUPPLY
diff --git a/drivers/power/Makefile b/drivers/power/Makefile
index f98b373..0f4c833 100644
--- a/drivers/power/Makefile
+++ b/drivers/power/Makefile
@@ -59,3 +59,4 @@ obj-$(CONFIG_POWER_AVS)		+= avs/
 obj-$(CONFIG_CHARGER_SMB347)	+= smb347-charger.o
 obj-$(CONFIG_CHARGER_TPS65090)	+= tps65090-charger.o
 obj-$(CONFIG_POWER_RESET)	+= reset/
+obj-$(CONFIG_BD7181X_POWER)	+= bd7181x-power.o
diff --git a/drivers/power/bd7181x-power.c b/drivers/power/bd7181x-power.c
new file mode 100644
index 0000000..9f7cdbf
--- /dev/null
+++ b/drivers/power/bd7181x-power.c
@@ -0,0 +1,2257 @@
+/*
+ * bd7181x-power.c
+ * @file ROHM BD71815/BD71817 Charger driver
+ *
+ * Copyright 2014 Embest Technology Co. Ltd. Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/power_supply.h>
+#include <linux/mfd/bd7181x.h>
+#include <linux/delay.h>
+
+#if 0
+#define bd7181x_info	dev_info
+#else
+#define bd7181x_info(...)
+#endif
+
+#define JITTER_DEFAULT		3000		/* hope 3s is enough */
+#define JITTER_REPORT_CAP	10000		/* 10 seconds */
+#define BD7181X_BATTERY_CAP_MAH	910
+#define BD7181X_BATTERY_CAP	mAh_A10s(BD7181X_BATTERY_CAP_MAH)
+#define MAX_VOLTAGE		ocv_table[0]
+#define MIN_VOLTAGE		3400000
+#define THR_VOLTAGE		3800000
+#define MAX_CURRENT		890000		/* uA */
+#define AC_NAME			"bd7181x_ac"
+#define BAT_NAME		"bd7181x_bat"
+#define BD7181X_BATTERY_FULL	100
+
+#define BY_BAT_VOLT		0
+#define BY_VBATLOAD_REG		1
+#define INIT_COULOMB		BY_VBATLOAD_REG
+
+#define CALIB_CURRENT_A2A3	0xCE9E
+
+//VBAT Low voltage detection Threshold 
+#define VBAT_LOW_TH		0x00D4 // 0x00D4*16mV = 212*0.016 = 3.392v 
+
+#ifdef CONFIG_LAB126
+extern void usbotg_force_bsession(bool connected);
+#endif
+
+#define RS_30mOHM		/* This is for 30mOhm sense resistance */
+
+#ifdef RS_30mOHM
+#define A10s_mAh(s)		((s) * 1000 / (360 * 3))
+#define mAh_A10s(m)		((m) * (360 * 3) / 1000)
+#else
+#define A10s_mAh(s)		((s) * 1000 / 360)
+#define mAh_A10s(m)		((m) * 360 / 1000)
+#endif
+
+#define THR_RELAX_CURRENT	10		/* mA */
+#define THR_RELAX_TIME		(60 * 60)	/* sec. */
+
+#define BD7181X_DGRD_CYC_CAP	26	/* 1 micro Ah unit */
+
+#define BD7181X_DGRD_TEMP_M	25	/* 1 degrees C unit */
+#define BD7181X_DGRD_TEMP_L	5	/* 1 degrees C unit */
+#define BD7181X_DGRD_TEMP_CAP_H	(0)	/* 1 micro Ah unit */
+#define BD7181X_DGRD_TEMP_CAP_M	(1187)	/* 1 micro Ah unit */
+#define BD7181X_DGRD_TEMP_CAP_L	(5141)	/* 1 micro Ah unit */
+
+#define CANCEL_ADJ_COULOMB_SOC_H_1	700	/* unit 0.1% */
+#define CANCEL_ADJ_COULOMB_SOC_L_1	550	/* unit 0.1% */
+#define CANCEL_ADJ_COULOMB_SOC_H_2	350	/* unit 0.1% */
+#define CANCEL_ADJ_COULOMB_SOC_L_2	0	/* unit 0.1% */
+
+#define FORCE_ADJ_COULOMB_TEMP_H	35	/* 1 degrees C unit */
+#define FORCE_ADJ_COULOMB_TEMP_L	15	/* 1 degrees C unit */
+
+unsigned int battery_cycle;
+
+
+static int ocv_table[] = {
+	4200000,
+	4167456,
+	4109781,
+	4065242,
+	4025618,
+	3989877,
+	3958031,
+	3929302,
+	3900935,
+	3869637,
+	3838475,
+	3815196,
+	3799778,
+	3788385,
+	3779627,
+	3770675,
+	3755368,
+	3736049,
+	3713545,
+	3685118,
+	3645278,
+	3465599,
+	2830610
+};	/* unit 1 micro V */
+
+static int soc_table[] = {
+	1000,
+	1000,
+	950,
+	900,
+	850,
+	800,
+	750,
+	700,
+	650,
+	600,
+	550,
+	500,
+	450,
+	400,
+	350,
+	300,
+	250,
+	200,
+	150,
+	100,
+	50,
+	0,
+	-50
+	/* unit 0.1% */
+};
+
+
+/** @brief power deivce */
+struct bd7181x_power {
+	struct device *dev;
+	struct bd7181x *mfd;			/**< parent for access register */
+	struct power_supply ac;			/**< alternating current power */
+	struct power_supply bat;		/**< battery power */
+	struct delayed_work bd_work;		/**< delayed work for timed work */
+
+	int	reg_index;			/**< register address saved for sysfs */
+
+	int    vbus_status;			/**< last vbus status */
+	int    charge_status;			/**< last charge status */
+	int    bat_status;			/**< last bat status */
+
+	int	hw_ocv1;			/**< HW ocv1 */
+	int	hw_ocv2;			/**< HW ocv2 */
+	int	bat_online;			/**< battery connect */
+	int	charger_online;			/**< charger connect */
+	int	vcell;				/**< battery voltage */
+	int	vsys;				/**< system voltage */
+	int	vcell_min;			/**< minimum battery voltage */
+	int	vsys_min;			/**< minimum system voltage */
+	int	rpt_status;			/**< battery status report */
+	int	prev_rpt_status;		/**< previous battery status report */
+	int	bat_health;			/**< battery health */
+	int	designed_cap;			/**< battery designed capacity */
+	int	full_cap;			/**< battery capacity */
+	int	curr;				/**< battery current from DS-ADC */
+	int	curr_sar;			/**< battery current from VM_IBAT */
+	int	temp;				/**< battery tempature */
+	u32	coulomb_cnt;			/**< Coulomb Counter */
+	int	state_machine;			/**< initial-procedure state machine */
+
+	u32	soc_org;			/**< State Of Charge using designed capacity without by load */
+	u32	soc_norm;			/**< State Of Charge using full capacity without by load */
+	u32	soc;				/**< State Of Charge using full capacity with by load */
+	u32	clamp_soc;			/**< Clamped State Of Charge using full capacity with by load */
+
+	int	relax_time;			/**< Relax Time */
+
+	u32	cycle;				/**< Charging and Discharging cycle number */
+	volatile int calib_current;		/**< calibration current */
+};
+
+
+#define CALIB_NORM			0
+#define CALIB_START			1
+#define CALIB_GO			2
+
+enum {
+	STAT_POWER_ON,
+	STAT_INITIALIZED,
+};
+
+static int bd7181x_calc_soc_org(struct bd7181x_power* pwr);
+
+/** @brief read a register group once
+ *  @param mfd bd7181x device
+ *  @param reg	 register address of lower register
+ *  @return register value
+ */
+#ifdef __BD7181X_REGMAP_H__
+static u16 bd7181x_reg_read16(struct bd7181x* mfd, int reg) {
+	u16 v;
+
+	v = (u16)bd7181x_reg_read(mfd, reg) << 8;
+	v |= (u16)bd7181x_reg_read(mfd, reg + 1) << 0;
+	return v;
+}
+#else
+static u16 bd7181x_reg_read16(struct bd7181x* mfd, int reg) {
+	union {
+		u16 long_type;
+		char chars[2];
+	} u;
+	int r;
+
+	r = regmap_bulk_read(mfd->regmap, reg, u.chars, sizeof u.chars);
+	if (r) {
+		return -1;
+	}
+	return be16_to_cpu(u.long_type);
+}
+#endif
+
+/** @brief write a register group once
+ * @param mfd bd7181x device
+ * @param reg register address of lower register
+ * @param val value to write
+ * @retval 0 success
+ * @retval -1 fail
+ */
+static int bd7181x_reg_write16(struct bd7181x *mfd, int reg, u16 val) {
+	union {
+		u16 long_type;
+		char chars[2];
+	} u;
+	int r;
+
+	u.long_type = cpu_to_be16(val);
+	// printk("write16 0x%.4X 0x%.4X\n", val, u.long_type);
+#ifdef __BD7181X_REGMAP_H__
+	r = mfd->write(mfd, reg, sizeof u.chars, u.chars);
+#else
+	r = regmap_bulk_write(mfd->regmap, reg, u.chars, sizeof u.chars);
+#endif
+	if (r) {
+		return -1;
+	}
+	return 0;	
+}
+
+/** @brief read quad register once
+ *  @param mfd bd7181x device
+ *  @param reg	 register address of lower register
+ *  @return register value
+ */
+static int bd7181x_reg_read32(struct bd7181x *mfd, int reg) {
+	union {
+		u32 long_type;
+		char chars[4];
+	} u;
+	int r;
+
+#ifdef __BD7181X_REGMAP_H__
+	r = mfd->read(mfd, reg, sizeof u.chars, u.chars);
+#else
+	r = regmap_bulk_read(mfd->regmap, reg, u.chars, sizeof u.chars);
+#endif
+	if (r) {
+		return -1;
+	}
+	return be32_to_cpu(u.long_type);
+}
+
+#if 0
+/** @brief write quad register once
+ * @param mfd bd7181x device
+ * @param reg register address of lower register
+ * @param val value to write
+ * @retval 0 success
+ * @retval -1 fail
+ */
+static int bd7181x_reg_write32(struct bd7181x *mfd, int reg, unsigned val) {
+	union {
+		u32 long_type;
+		char chars[4];
+	} u;
+	int r;
+
+	u.long_type = cpu_to_be32(val);
+	r = regmap_bulk_write(mfd->regmap, reg, u.chars, sizeof u.chars);
+	if (r) {
+		return -1;
+	}
+	return 0;
+}
+#endif
+
+#if INIT_COULOMB == BY_VBATLOAD_REG
+/** @brief get initial battery voltage and current
+ * @param pwr power device
+ * @return 0
+ */
+static int bd7181x_get_init_bat_stat(struct bd7181x_power *pwr) {
+	struct bd7181x *mfd = pwr->mfd;
+	int vcell;
+
+	vcell = bd7181x_reg_read16(mfd, BD7181X_REG_VM_OCV_PRE_U) * 1000;
+	bd7181x_info(pwr->dev, "VM_OCV_PRE = %d\n", vcell);
+	pwr->hw_ocv1 = vcell;
+
+	vcell = bd7181x_reg_read16(mfd, BD7181X_REG_VM_OCV_PST_U) * 1000;
+	bd7181x_info(pwr->dev, "VM_OCV_PST = %d\n", vcell);
+	pwr->hw_ocv2 = vcell;
+
+	return 0;
+}
+#endif
+
+/** @brief get battery average voltage and current
+ * @param pwr power device
+ * @param vcell pointer to return back voltage in unit uV.
+ * @param curr  pointer to return back current in unit uA.
+ * @return 0
+ */
+static int bd7181x_get_vbat_curr(struct bd7181x_power *pwr, int *vcell, int *curr) {
+	struct bd7181x* mfd = pwr->mfd;
+	int tmp_vcell, tmp_curr;
+
+	tmp_vcell = 0;
+	tmp_curr = 0;
+
+	tmp_vcell = bd7181x_reg_read16(mfd, BD7181X_REG_VM_SA_VBAT_U);
+	tmp_curr = bd7181x_reg_read16(mfd, BD7181X_REG_VM_SA_IBAT_U);
+	if (tmp_curr & IBAT_SA_DIR_Discharging) {
+		tmp_curr = -(tmp_curr & ~IBAT_SA_DIR_Discharging);
+	}
+
+	*vcell = tmp_vcell * 1000;
+#ifdef RS_30mOHM
+	*curr = tmp_curr * 1000 / 3;
+#else
+	*curr = tmp_curr * 1000;
+#endif
+	return 0;
+}
+
+/** @brief get battery current from DS-ADC
+ * @param pwr power device
+ * @return current in unit uA
+ */
+static int bd7181x_get_current_ds_adc(struct bd7181x_power *pwr) {
+	int r;
+	
+	r = bd7181x_reg_read16(pwr->mfd, BD7181X_REG_CC_CURCD_U);
+	if (r < 0) {
+		return 0;
+	}
+	if (r & CURDIR_Discharging) {
+		r = -(r & ~CURDIR_Discharging);
+	}
+#ifdef RS_30mOHM
+	return r * 1000 / 3;
+#else
+	return r * 1000;
+#endif
+}
+
+/** @brief get system average voltage
+ * @param pwr power device
+ * @param vcell pointer to return back voltage in unit uV.
+ * @return 0
+ */
+static int bd7181x_get_vsys(struct bd7181x_power *pwr, int *vsys) {
+	struct bd7181x* mfd = pwr->mfd;
+	int tmp_vsys;
+
+	tmp_vsys = 0;
+
+	tmp_vsys = bd7181x_reg_read16(mfd, BD7181X_REG_VM_SA_VSYS_U);
+
+	*vsys = tmp_vsys * 1000;
+
+	return 0;
+}
+
+/** @brief get battery minimum average voltage
+ * @param pwr power device
+ * @param vcell pointer to return back voltage in unit uV.
+ * @return 0
+ */
+static int bd7181x_get_vbat_min(struct bd7181x_power *pwr, int *vcell) {
+	struct bd7181x* mfd = pwr->mfd;
+	int tmp_vcell;
+
+	tmp_vcell = 0;
+
+	tmp_vcell = bd7181x_reg_read16(mfd, BD7181X_REG_VM_SA_VBAT_MIN_U);
+	bd7181x_set_bits(pwr->mfd, BD7181X_REG_VM_SA_MINMAX_CLR, VBAT_SA_MIN_CLR);
+
+	*vcell = tmp_vcell * 1000;
+
+	return 0;
+}
+
+/** @brief get system minimum average voltage
+ * @param pwr power device
+ * @param vcell pointer to return back voltage in unit uV.
+ * @return 0
+ */
+static int bd7181x_get_vsys_min(struct bd7181x_power *pwr, int *vcell) {
+	struct bd7181x* mfd = pwr->mfd;
+	int tmp_vcell;
+
+	tmp_vcell = 0;
+
+	tmp_vcell = bd7181x_reg_read16(mfd, BD7181X_REG_VM_SA_VSYS_MIN_U);
+	bd7181x_set_bits(pwr->mfd, BD7181X_REG_VM_SA_MINMAX_CLR, VSYS_SA_MIN_CLR);
+
+	*vcell = tmp_vcell * 1000;
+
+	return 0;
+}
+
+/** @brief get battery capacity
+ * @param ocv open circuit voltage
+ * @return capcity in unit 0.1 percent
+ */
+static int bd7181x_voltage_to_capacity(int ocv) {
+	int i = 0;
+	int soc;
+
+	if (ocv > ocv_table[0]) {
+		soc = soc_table[0];
+	} else {
+		i = 0;
+		while (soc_table[i] != -50) {
+			if ((ocv <= ocv_table[i]) && (ocv > ocv_table[i+1])) {
+				soc = (soc_table[i] - soc_table[i+1]) * (ocv - ocv_table[i+1]) / (ocv_table[i] - ocv_table[i+1]);
+				soc += soc_table[i+1];
+				break;
+			}
+			i++;
+		}
+		if (soc_table[i] == -50)
+			soc = soc_table[i];
+	}
+	return soc;
+}
+
+/** @brief get battery temperature
+ * @param pwr power device
+ * @return temperature in unit deg.Celsius
+ */
+static int bd7181x_get_temp(struct bd7181x_power *pwr) {
+	struct bd7181x* mfd = pwr->mfd;
+	int t;
+
+	t = 200 - (int)bd7181x_reg_read(mfd, BD7181X_REG_VM_BTMP);
+
+	// battery temperature error
+	t = (t > 200)? 200: t;
+	
+	return t;
+}
+
+static int bd7181x_reset_coulomb_count(struct bd7181x_power* pwr);
+
+/** @brief get battery charge status
+ * @param pwr power device
+ * @return temperature in unit deg.Celsius
+ */
+static int bd7181x_charge_status(struct bd7181x_power *pwr)
+{
+	u8 state;
+	int ret = 1;
+
+	state = bd7181x_reg_read(pwr->mfd, BD7181X_REG_CHG_STATE);
+	// bd7181x_info(pwr->dev, "CHG_STATE %d\n", state);
+
+	switch (state) {
+	case 0x00:
+		ret = 0;
+		pwr->rpt_status = POWER_SUPPLY_STATUS_DISCHARGING;
+		pwr->bat_health = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case 0x01:
+	case 0x02:
+	case 0x03:
+	case 0x0E:
+		pwr->rpt_status = POWER_SUPPLY_STATUS_CHARGING;
+		pwr->bat_health = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case 0x0F:
+		ret = 0;
+		pwr->rpt_status = POWER_SUPPLY_STATUS_FULL;
+		pwr->bat_health = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case 0x10:
+	case 0x11:
+	case 0x12:
+	case 0x13:
+	case 0x14:
+	case 0x20:
+	case 0x21:
+	case 0x22:
+	case 0x23:
+	case 0x24:
+		ret = 0;
+		pwr->rpt_status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		pwr->bat_health = POWER_SUPPLY_HEALTH_OVERHEAT;
+		break;
+	case 0x30:
+	case 0x31:
+	case 0x32:
+	case 0x40:
+		ret = 0;
+		pwr->rpt_status = POWER_SUPPLY_STATUS_DISCHARGING;
+		pwr->bat_health = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case 0x7f:
+	default:
+		ret = 0;
+		pwr->rpt_status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		pwr->bat_health = POWER_SUPPLY_HEALTH_DEAD;
+		break;	
+	}
+
+	bd7181x_reset_coulomb_count(pwr);
+
+	pwr->prev_rpt_status = pwr->rpt_status;
+
+	return ret;
+}
+
+#if INIT_COULOMB == BY_BAT_VOLT
+static int bd7181x_calib_voltage(struct bd7181x_power* pwr, int* ocv) {
+	int r, curr, volt;
+
+	bd7181x_get_vbat_curr(pwr, &volt, &curr);
+
+	r = bd7181x_reg_read(pwr->mfd, BD7181X_REG_CHG_STATE);
+	if (r >= 0 && curr > 0) {
+		// voltage increment caused by battery inner resistor
+		if (r == 3) volt -= 100 * 1000;
+		else if (r == 2) volt -= 50 * 1000;
+	}
+	*ocv = volt;
+
+	return 0;
+}
+#endif
+
+/** @brief set initial coulomb counter value from battery voltage
+ * @param pwr power device
+ * @return 0
+ */
+static int calibration_coulomb_counter(struct bd7181x_power* pwr) {
+	u32 bcap;
+	int soc, ocv;
+
+#if INIT_COULOMB == BY_VBATLOAD_REG
+	/* Get init OCV by HW */
+	bd7181x_get_init_bat_stat(pwr);
+
+	ocv = (pwr->hw_ocv1 >= pwr->hw_ocv2)? pwr->hw_ocv1: pwr->hw_ocv2;
+	bd7181x_info(pwr->dev, "ocv %d\n", ocv);
+#elif INIT_COULOMB == BY_BAT_VOLT
+	bd7181x_calib_voltage(pwr, &ocv);
+#endif
+
+	/* Get init soc from ocv/soc table */
+	soc = bd7181x_voltage_to_capacity(ocv);
+	bd7181x_info(pwr->dev, "soc %d[0.1%%]\n", soc);
+	if (soc < 0)
+		soc = 0;
+	bcap = pwr->designed_cap * soc / 1000;
+
+	bd7181x_reg_write16(pwr->mfd, BD7181X_REG_CC_CCNTD_1, 0);
+	bd7181x_reg_write16(pwr->mfd, BD7181X_REG_CC_CCNTD_3, ((bcap + pwr->designed_cap / 200) & 0x1FFFUL));
+
+	pwr->coulomb_cnt = bd7181x_reg_read32(pwr->mfd, BD7181X_REG_CC_CCNTD_3) & 0x1FFFFFFFUL;
+	bd7181x_info(pwr->dev, "%s() CC_CCNTD = %d\n", __func__, pwr->coulomb_cnt);
+
+	/* Start canceling offset of the DS ADC. This needs 1 second at least */
+	bd7181x_set_bits(pwr->mfd, BD7181X_REG_CC_CTRL, CCCALIB);
+
+	return 0;
+}
+
+/** @brief adjust coulomb counter values at relaxed state
+ * @param pwr power device
+ * @return 0
+ */
+static int bd7181x_adjust_coulomb_count(struct bd7181x_power* pwr) {
+	u32 relaxed_coulomb_cnt;
+
+	relaxed_coulomb_cnt = bd7181x_reg_read32(pwr->mfd, BD7181X_REG_REX_CCNTD_3) & 0x1FFFFFFFUL;
+	if (relaxed_coulomb_cnt != 0) {
+		u32 bcap;
+		int soc, ocv;
+		int diff_coulomb_cnt;
+
+		/* Get OCV at relaxed state by HW */
+		ocv = bd7181x_reg_read16(pwr->mfd, BD7181X_REG_REX_SA_VBAT_U) * 1000;
+		bd7181x_info(pwr->dev, "ocv %d\n", ocv);
+
+		/* Clear Relaxed Coulomb Counter */
+		bd7181x_set_bits(pwr->mfd, BD7181X_REG_REX_CTRL_1, REX_CLR);
+
+		diff_coulomb_cnt = relaxed_coulomb_cnt - (bd7181x_reg_read32(pwr->mfd, BD7181X_REG_CC_CCNTD_3) & 0x1FFFFFFFUL);
+		diff_coulomb_cnt = diff_coulomb_cnt >> 16;
+		bd7181x_info(pwr->dev, "diff_coulomb_cnt = %d\n", diff_coulomb_cnt);
+
+		/* Get soc at relaxed state from ocv/soc table */
+		soc = bd7181x_voltage_to_capacity(ocv);
+		bd7181x_info(pwr->dev, "soc %d[0.1%%]\n", soc);
+		if (soc < 0)
+			soc = 0;
+
+		if ((soc > CANCEL_ADJ_COULOMB_SOC_H_1) || ((soc < CANCEL_ADJ_COULOMB_SOC_L_1) && (soc > CANCEL_ADJ_COULOMB_SOC_H_2)) || (soc < CANCEL_ADJ_COULOMB_SOC_L_2) || 
+			((pwr->temp <= FORCE_ADJ_COULOMB_TEMP_H) && (pwr->temp >= FORCE_ADJ_COULOMB_TEMP_L))) {
+			bcap = pwr->designed_cap * soc / 1000;
+
+			/* Stop Coulomb Counter */
+			bd7181x_clear_bits(pwr->mfd, BD7181X_REG_CC_CTRL, CCNTENB);
+
+			bd7181x_reg_write16(pwr->mfd, BD7181X_REG_CC_CCNTD_1, 0);
+			bd7181x_reg_write16(pwr->mfd, BD7181X_REG_CC_CCNTD_3, ((bcap + pwr->designed_cap / 200) & 0x1FFFUL) + diff_coulomb_cnt);
+
+			pwr->coulomb_cnt = bd7181x_reg_read32(pwr->mfd, BD7181X_REG_CC_CCNTD_3) & 0x1FFFFFFFUL;
+			bd7181x_info(pwr->dev, "Adjust Coulomb Counter at Relaxed State\n");
+			bd7181x_info(pwr->dev, "CC_CCNTD = %d\n", pwr->coulomb_cnt);
+
+			/* Start Coulomb Counter */
+			bd7181x_set_bits(pwr->mfd, BD7181X_REG_CC_CTRL, CCNTENB);
+
+			/* If the following commented out code is enabled, the SOC is not clamped at the relax time. */
+			/* Reset SOCs */
+			/* bd7181x_calc_soc_org(pwr); */
+			/* pwr->soc_norm = pwr->soc_org; */
+			/* pwr->soc = pwr->soc_norm; */
+			/* pwr->clamp_soc = pwr->soc; */
+		}
+	}
+
+	return 0;
+}
+
+/** @brief reset coulomb counter values at full charged state
+ * @param pwr power device
+ * @return 0
+ */
+static int bd7181x_reset_coulomb_count(struct bd7181x_power* pwr)
+{
+	u32 full_charged_coulomb_cnt;
+
+	full_charged_coulomb_cnt = bd7181x_reg_read32(pwr->mfd, BD7181X_REG_FULL_CCNTD_3) & 0x1FFFFFFFUL;
+	if (full_charged_coulomb_cnt != 0) {
+		int diff_coulomb_cnt;
+
+		/* Clear Full Charged Coulomb Counter */
+		bd7181x_set_bits(pwr->mfd, BD7181X_REG_FULL_CTRL, FULL_CLR);
+
+		diff_coulomb_cnt = full_charged_coulomb_cnt - (bd7181x_reg_read32(pwr->mfd, BD7181X_REG_CC_CCNTD_3) & 0x1FFFFFFFUL);
+		diff_coulomb_cnt = diff_coulomb_cnt >> 16;
+		if (diff_coulomb_cnt > 0) {
+			diff_coulomb_cnt = 0;
+		}
+		bd7181x_info(pwr->dev, "diff_coulomb_cnt = %d\n", diff_coulomb_cnt);
+
+		/* Stop Coulomb Counter */
+		bd7181x_clear_bits(pwr->mfd, BD7181X_REG_CC_CTRL, CCNTENB);
+
+		bd7181x_reg_write16(pwr->mfd, BD7181X_REG_CC_CCNTD_1, 0);
+		bd7181x_reg_write16(pwr->mfd, BD7181X_REG_CC_CCNTD_3, ((pwr->designed_cap + pwr->designed_cap / 200) & 0x1FFFUL) + diff_coulomb_cnt);
+
+		pwr->coulomb_cnt = bd7181x_reg_read32(pwr->mfd, BD7181X_REG_CC_CCNTD_3) & 0x1FFFFFFFUL;
+		bd7181x_info(pwr->dev, "Reset Coulomb Counter at POWER_SUPPLY_STATUS_FULL\n");
+		bd7181x_info(pwr->dev, "CC_CCNTD = %d\n", pwr->coulomb_cnt);
+
+		/* Start Coulomb Counter */
+		bd7181x_set_bits(pwr->mfd, BD7181X_REG_CC_CTRL, CCNTENB);
+	}
+
+	return 0;
+}
+
+/** @brief get battery parameters, such as voltages, currents, temperatures.
+ * @param pwr power device
+ * @return 0
+ */
+static int bd7181x_get_voltage_current(struct bd7181x_power* pwr)
+{
+
+	/* Read detailed vcell and current */
+	bd7181x_get_vbat_curr(pwr, &pwr->vcell, &pwr->curr_sar);
+	bd7181x_info(pwr->dev, "VM_VBAT = %d\n", pwr->vcell);
+	bd7181x_info(pwr->dev, "VM_IBAT = %d\n", pwr->curr_sar);
+
+	pwr->curr = bd7181x_get_current_ds_adc(pwr);
+	bd7181x_info(pwr->dev, "CC_CURCD = %d\n", pwr->curr);
+
+	/* Read detailed vsys */
+	bd7181x_get_vsys(pwr, &pwr->vsys);
+	bd7181x_info(pwr->dev, "VM_VSYS = %d\n", pwr->vsys);
+
+	/* Read detailed vbat_min */
+	bd7181x_get_vbat_min(pwr, &pwr->vcell_min);
+	bd7181x_info(pwr->dev, "VM_VBAT_MIN = %d\n", pwr->vcell_min);
+
+	/* Read detailed vsys_min */
+	bd7181x_get_vsys_min(pwr, &pwr->vsys_min);
+	bd7181x_info(pwr->dev, "VM_VSYS_MIN = %d\n", pwr->vsys_min);
+
+	/* Get tempature */
+	pwr->temp = bd7181x_get_temp(pwr);
+	// bd7181x_info(pwr->dev, "Temperature %d degrees C\n", pwr->temp);
+
+	return 0;
+}
+
+/** @brief adjust coulomb counter values at relaxed state by SW
+ * @param pwr power device
+ * @return 0
+ */
+static int bd7181x_adjust_coulomb_count_sw(struct bd7181x_power* pwr)
+{
+	int tmp_curr_mA;
+
+	tmp_curr_mA = pwr->curr / 1000;
+	if ((tmp_curr_mA * tmp_curr_mA) <= (THR_RELAX_CURRENT * THR_RELAX_CURRENT)) { /* No load */
+		pwr->relax_time += (JITTER_DEFAULT / 1000);
+	}
+	else {
+		pwr->relax_time = 0;
+	}
+	
+	if (pwr->relax_time >= THR_RELAX_TIME) { /* Battery is relaxed. */
+		u32 bcap;
+		int soc, ocv;
+
+		pwr->relax_time = 0;
+
+		/* Get OCV */
+		ocv = pwr->vcell;
+
+		/* Get soc at relaxed state from ocv/soc table */
+		soc = bd7181x_voltage_to_capacity(ocv);
+		bd7181x_info(pwr->dev, "soc %d[0.1%%]\n", soc);
+		if (soc < 0)
+			soc = 0;
+
+		if ((soc > CANCEL_ADJ_COULOMB_SOC_H_1) || ((soc < CANCEL_ADJ_COULOMB_SOC_L_1) && (soc > CANCEL_ADJ_COULOMB_SOC_H_2)) || (soc < CANCEL_ADJ_COULOMB_SOC_L_2) || 
+			((pwr->temp <= FORCE_ADJ_COULOMB_TEMP_H) && (pwr->temp >= FORCE_ADJ_COULOMB_TEMP_L))) {
+			bcap = pwr->designed_cap * soc / 1000;
+
+			/* Stop Coulomb Counter */
+			bd7181x_clear_bits(pwr->mfd, BD7181X_REG_CC_CTRL, CCNTENB);
+
+			bd7181x_reg_write16(pwr->mfd, BD7181X_REG_CC_CCNTD_1, 0);
+			bd7181x_reg_write16(pwr->mfd, BD7181X_REG_CC_CCNTD_3, ((bcap + pwr->designed_cap / 200) & 0x1FFFUL));
+
+			pwr->coulomb_cnt = bd7181x_reg_read32(pwr->mfd, BD7181X_REG_CC_CCNTD_3) & 0x1FFFFFFFUL;
+			bd7181x_info(pwr->dev, "Adjust Coulomb Counter by SW at Relaxed State\n");
+			bd7181x_info(pwr->dev, "CC_CCNTD = %d\n", pwr->coulomb_cnt);
+
+			/* Start Coulomb Counter */
+			bd7181x_set_bits(pwr->mfd, BD7181X_REG_CC_CTRL, CCNTENB);
+
+			/* If the following commented out code is enabled, the SOC is not clamped at the relax time. */
+			/* Reset SOCs */
+			/* bd7181x_calc_soc_org(pwr); */
+			/* pwr->soc_norm = pwr->soc_org; */
+			/* pwr->soc = pwr->soc_norm; */
+			/* pwr->clamp_soc = pwr->soc; */
+		}
+
+	}
+
+	return 0;
+}
+
+/** @brief get coulomb counter values
+ * @param pwr power device
+ * @return 0
+ */
+static int bd7181x_coulomb_count(struct bd7181x_power* pwr) {
+	if (pwr->state_machine == STAT_POWER_ON) {
+		pwr->state_machine = STAT_INITIALIZED;
+		/* Start Coulomb Counter */
+		bd7181x_set_bits(pwr->mfd, BD7181X_REG_CC_CTRL, CCNTENB);
+	} else if (pwr->state_machine == STAT_INITIALIZED) {
+		pwr->coulomb_cnt = bd7181x_reg_read32(pwr->mfd, BD7181X_REG_CC_CCNTD_3) & 0x1FFFFFFFUL;
+		// bd7181x_info(pwr->dev, "CC_CCNTD = %d\n", pwr->coulomb_cnt);
+	}
+	return 0;
+}
+
+/** @brief calc cycle
+ * @param pwr power device
+ * @return 0
+ */
+static int bd7181x_update_cycle(struct bd7181x_power* pwr) {
+	int charged_coulomb_cnt;
+
+	charged_coulomb_cnt = bd7181x_reg_read16(pwr->mfd, BD7181X_REG_CCNTD_CHG_3);
+	if (charged_coulomb_cnt >= pwr->designed_cap) {
+		pwr->cycle++;
+		bd7181x_info(pwr->dev, "Update cycle = %d\n", pwr->cycle);
+		battery_cycle = pwr->cycle;
+		charged_coulomb_cnt -= pwr->designed_cap;
+		/* Stop Coulomb Counter */
+		bd7181x_clear_bits(pwr->mfd, BD7181X_REG_CC_CTRL, CCNTENB);
+
+		bd7181x_reg_write16(pwr->mfd, BD7181X_REG_CCNTD_CHG_3, charged_coulomb_cnt);
+
+		/* Start Coulomb Counter */
+		bd7181x_set_bits(pwr->mfd, BD7181X_REG_CC_CTRL, CCNTENB);
+	}
+	return 0;
+}
+
+/** @brief calc full capacity value by Cycle and Temperature
+ * @param pwr power device
+ * @return 0
+ */
+static int bd7181x_calc_full_cap(struct bd7181x_power* pwr) {
+	u32 designed_cap_uAh;
+	u32 full_cap_uAh;
+
+	/* Calculate full capacity by cycle */
+	designed_cap_uAh = A10s_mAh(pwr->designed_cap) * 1000;
+	full_cap_uAh = designed_cap_uAh - BD7181X_DGRD_CYC_CAP * pwr->cycle;
+	pwr->full_cap = mAh_A10s(full_cap_uAh / 1000);
+	bd7181x_info(pwr->dev, "Calculate full capacity by cycle\n");
+	bd7181x_info(pwr->dev, "%s() pwr->full_cap = %d\n", __func__, pwr->full_cap);
+
+	/* Calculate full capacity by temperature */
+	bd7181x_info(pwr->dev, "Temperature = %d\n", pwr->temp);
+	if (pwr->temp >= BD7181X_DGRD_TEMP_M) {
+		full_cap_uAh += (pwr->temp - BD7181X_DGRD_TEMP_M) * BD7181X_DGRD_TEMP_CAP_H;
+		pwr->full_cap = mAh_A10s(full_cap_uAh / 1000);
+	}
+	else if (pwr->temp >= BD7181X_DGRD_TEMP_L) {
+		full_cap_uAh += (pwr->temp - BD7181X_DGRD_TEMP_M) * BD7181X_DGRD_TEMP_CAP_M;
+		pwr->full_cap = mAh_A10s(full_cap_uAh / 1000);
+	}
+	else {
+		full_cap_uAh += (BD7181X_DGRD_TEMP_L - BD7181X_DGRD_TEMP_M) * BD7181X_DGRD_TEMP_CAP_M;
+		full_cap_uAh += (pwr->temp - BD7181X_DGRD_TEMP_L) * BD7181X_DGRD_TEMP_CAP_L;
+		pwr->full_cap = mAh_A10s(full_cap_uAh / 1000);
+	}
+	bd7181x_info(pwr->dev, "Calculate full capacity by cycle and temperature\n");
+	bd7181x_info(pwr->dev, "%s() pwr->full_cap = %d\n", __func__, pwr->full_cap);
+
+	return 0;
+}
+
+/** @brief calculate SOC values by designed capacity
+ * @param pwr power device
+ * @return 0
+ */
+static int bd7181x_calc_soc_org(struct bd7181x_power* pwr) {
+	pwr->soc_org = (pwr->coulomb_cnt >> 16) * 100 /  pwr->designed_cap;
+	if (pwr->soc_org > 100) {
+		pwr->soc_org = 100;
+		/* Stop Coulomb Counter */
+		bd7181x_clear_bits(pwr->mfd, BD7181X_REG_CC_CTRL, CCNTENB);
+
+		bd7181x_reg_write16(pwr->mfd, BD7181X_REG_CC_CCNTD_1, 0);
+		bd7181x_reg_write16(pwr->mfd, BD7181X_REG_CC_CCNTD_3, ((pwr->designed_cap + pwr->designed_cap / 200) & 0x1FFFUL));
+
+		pwr->coulomb_cnt = bd7181x_reg_read32(pwr->mfd, BD7181X_REG_CC_CCNTD_3) & 0x1FFFFFFFUL;
+		bd7181x_info(pwr->dev, "Limit Coulomb Counter\n");
+		bd7181x_info(pwr->dev, "CC_CCNTD = %d\n", pwr->coulomb_cnt);
+
+		/* Start Coulomb Counter */
+		bd7181x_set_bits(pwr->mfd, BD7181X_REG_CC_CTRL, CCNTENB);
+	}
+		bd7181x_info(pwr->dev, "%s() pwr->soc_org = %d\n", __func__, pwr->soc_org);
+	return 0;
+}
+
+/** @brief calculate SOC values by full capacity
+ * @param pwr power device
+ * @return 0
+ */
+static int bd7181x_calc_soc_norm(struct bd7181x_power* pwr) {
+	int lost_cap;
+	int mod_coulomb_cnt;
+
+	lost_cap = pwr->designed_cap - pwr->full_cap;
+	bd7181x_info(pwr->dev, "%s() lost_cap = %d\n", __func__, lost_cap);
+	mod_coulomb_cnt = (pwr->coulomb_cnt >> 16) - lost_cap;
+	if ((mod_coulomb_cnt > 0) && (pwr->full_cap > 0)) {
+		pwr->soc_norm = mod_coulomb_cnt * 100 /  pwr->full_cap;
+	}
+	else {
+		pwr->soc_norm = 0;
+	}
+	if (pwr->soc_norm > 100) {
+		pwr->soc_norm = 100;
+	}
+		bd7181x_info(pwr->dev, "%s() pwr->soc_norm = %d\n", __func__, pwr->soc_norm);
+	return 0;
+}
+
+/** @brief get OCV value by SOC
+ * @param pwr power device
+ * @return 0
+ */
+int bd7181x_get_ocv(struct bd7181x_power* pwr, int dsoc) {
+	int i = 0;
+	int ocv = 0;
+
+	if (dsoc > soc_table[0]) {
+		ocv = MAX_VOLTAGE;
+	}
+	else if (dsoc == 0) {
+			ocv = ocv_table[21];
+	}
+	else {
+		i = 0;
+		while (i < 22) {
+			if ((dsoc <= soc_table[i]) && (dsoc > soc_table[i+1])) {
+				ocv = (ocv_table[i] - ocv_table[i+1]) * (dsoc - soc_table[i+1]) / (soc_table[i] - soc_table[i+1]) + ocv_table[i+1];
+				break;
+			}
+			i++;
+		}
+		if (i == 22)
+			ocv = ocv_table[22];
+	}
+	bd7181x_info(pwr->dev, "%s() ocv = %d\n", __func__, ocv);
+	return ocv;
+}
+
+/** @brief calculate SOC value by full_capacity and load
+ * @param pwr power device
+ * @return OCV
+ */
+static int bd7181x_calc_soc(struct bd7181x_power* pwr) {
+	int ocv_table_load[23];
+
+	pwr->soc = pwr->soc_norm;
+
+	switch (pwr->rpt_status) { /* Adjust for 0% between THR_VOLTAGE and MIN_VOLTAGE */
+	case POWER_SUPPLY_STATUS_DISCHARGING:
+	case POWER_SUPPLY_STATUS_NOT_CHARGING:
+		if (pwr->vsys_min <= THR_VOLTAGE) {
+			int i;
+			int ocv;
+			int lost_cap;
+			int mod_coulomb_cnt;
+			int dsoc;
+
+			lost_cap = pwr->designed_cap - pwr->full_cap;
+			mod_coulomb_cnt = (pwr->coulomb_cnt >> 16) - lost_cap;
+			dsoc = mod_coulomb_cnt * 1000 /  pwr->full_cap;
+			bd7181x_info(pwr->dev, "%s() dsoc = %d\n", __func__, dsoc);
+			ocv = bd7181x_get_ocv(pwr, dsoc);
+			for (i = 1; i < 23; i++) {
+				ocv_table_load[i] = ocv_table[i] - (ocv - pwr->vsys_min);
+				if (ocv_table_load[i] <= MIN_VOLTAGE) {
+					bd7181x_info(pwr->dev, "%s() ocv_table_load[%d] = %d\n", __func__, i, ocv_table_load[i]);
+					break;
+				}
+			}
+			if (i < 23) {
+				int j;
+				int dv = (ocv_table_load[i-1] - ocv_table_load[i]) / 5;
+				int lost_cap2;
+				int mod_coulomb_cnt2, mod_full_cap;
+				for (j = 1; j < 5; j++){
+					if ((ocv_table_load[i] + dv * j) > MIN_VOLTAGE) {
+						break;
+					}
+				}
+				lost_cap2 = ((21 - i) * 5 + (j - 1)) * pwr->full_cap / 100;
+				bd7181x_info(pwr->dev, "%s() lost_cap2 = %d\n", __func__, lost_cap2);
+				mod_coulomb_cnt2 = mod_coulomb_cnt - lost_cap2;
+				mod_full_cap = pwr->full_cap - lost_cap2;
+				if ((mod_coulomb_cnt2 > 0) && (mod_full_cap > 0)) {
+					pwr->soc = mod_coulomb_cnt2 * 100 / mod_full_cap;
+				}
+				else {
+					pwr->soc = 0;
+				}
+				bd7181x_info(pwr->dev, "%s() pwr->soc(by load) = %d\n", __func__, pwr->soc);
+			}
+		}
+		break;
+	default:
+		break;
+	}
+
+	switch (pwr->rpt_status) {/* Adjust for 0% and 100% */
+	case POWER_SUPPLY_STATUS_DISCHARGING:
+	case POWER_SUPPLY_STATUS_NOT_CHARGING:
+		if (pwr->vsys_min <= MIN_VOLTAGE) {
+			pwr->soc = 0;
+		}
+		else {
+			if (pwr->soc == 0) {
+				pwr->soc = 1;
+			}
+		}
+		break;
+	case POWER_SUPPLY_STATUS_CHARGING:
+		if (pwr->soc == 100) {
+			pwr->soc = 99;
+		}
+		break;
+	default:
+		break;
+	}
+	bd7181x_info(pwr->dev, "%s() pwr->soc = %d\n", __func__, pwr->soc);
+	return 0;
+}
+
+/** @brief calculate Clamped SOC value by full_capacity and load
+ * @param pwr power device
+ * @return OCV
+ */
+static int bd7181x_calc_soc_clamp(struct bd7181x_power* pwr) {
+	switch (pwr->rpt_status) {/* Adjust for 0% and 100% */
+	case POWER_SUPPLY_STATUS_DISCHARGING:
+	case POWER_SUPPLY_STATUS_NOT_CHARGING:
+		if (pwr->soc <= pwr->clamp_soc) {
+			pwr->clamp_soc = pwr->soc;
+		}
+		break;
+	default:
+		pwr->clamp_soc = pwr->soc;
+		break;
+	}
+	bd7181x_info(pwr->dev, "%s() pwr->clamp_soc = %d\n", __func__, pwr->clamp_soc);
+	return 0;
+}
+
+/** @brief get battery and DC online status
+ * @param pwr power device
+ * @return 0
+ */
+static int bd7181x_get_online(struct bd7181x_power* pwr) {
+	int r;
+
+#if 0
+#define TS_THRESHOLD_VOLT	0xD9
+	r = bd7181x_reg_read(pwr->mfd, BD7181X_REG_VM_VTH);
+	pwr->bat_online = (r > TS_THRESHOLD_VOLT);
+#endif
+#if 0
+	r = bd7181x_reg_read(pwr->mfd, BD7181X_REG_BAT_STAT);
+	if (r >= 0 && (r & BAT_DET_DONE)) {
+		pwr->bat_online = (r & BAT_DET) != 0;
+	}
+#endif
+#if 1
+#define BAT_OPEN	0x7
+	r = bd7181x_reg_read(pwr->mfd, BD7181X_REG_BAT_TEMP);
+	pwr->bat_online = (r != BAT_OPEN);
+#endif	
+	r = bd7181x_reg_read(pwr->mfd, BD7181X_REG_DCIN_STAT);
+	if (r >= 0) {
+		pwr->charger_online = (r & VBUS_DET) != 0;
+	}
+
+	return 0;
+}
+
+/** @brief init bd7181x sub module charger
+ * @param pwr power device
+ * @return 0
+ */
+static int bd7181x_init_hardware(struct bd7181x_power *pwr)
+{
+	struct bd7181x *mfd = pwr->mfd;
+	int r;
+
+	r = bd7181x_reg_write(mfd, BD7181X_REG_DCIN_CLPS, 0x36);
+
+#define XSTB		0x02
+	r = bd7181x_reg_read(mfd, BD7181X_REG_CONF);
+
+#if 0
+	for (i = 0; i < 300; i++) {
+		r = bd7181x_reg_read(pwr->mfd, BD7181X_REG_BAT_STAT);
+		if (r >= 0 && (r & BAT_DET_DONE)) {
+			break;
+		}
+		msleep(5);
+	}
+#endif
+	if ((r & XSTB) == 0x00) {
+	//if (r & BAT_DET) {
+		/* Init HW, when the battery is inserted. */
+
+		bd7181x_reg_write(mfd, BD7181X_REG_CONF, r | XSTB);
+
+#define TEST_SEQ_00		0x00
+#define TEST_SEQ_01		0x76
+#define TEST_SEQ_02		0x66
+#define TEST_SEQ_03		0x56
+#if 0
+		bd7181x_reg_write(mfd, BD7181X_REG_TEST_MODE, TEST_SEQ_01);
+		bd7181x_reg_write(mfd, BD7181X_REG_TEST_MODE, TEST_SEQ_02);
+		bd7181x_reg_write(mfd, BD7181X_REG_TEST_MODE, TEST_SEQ_03);
+		bd7181x_reg_write16(pwr->mfd, 0xA2, CALIB_CURRENT_A2A3);
+		bd7181x_reg_write(mfd, BD7181X_REG_TEST_MODE, TEST_SEQ_00);
+#endif
+
+		/* Stop Coulomb Counter */
+		bd7181x_clear_bits(mfd, BD7181X_REG_CC_CTRL, CCNTENB);
+
+		/* Set Coulomb Counter Reset bit*/
+		bd7181x_set_bits(mfd, BD7181X_REG_CC_CTRL, CCNTRST);
+
+		/* Clear Coulomb Counter Reset bit*/
+		bd7181x_clear_bits(mfd, BD7181X_REG_CC_CTRL, CCNTRST);
+
+		/* Set default Battery Capacity */
+		pwr->designed_cap = BD7181X_BATTERY_CAP;
+		pwr->full_cap = BD7181X_BATTERY_CAP;
+
+		/* Set initial Coulomb Counter by HW OCV */
+		calibration_coulomb_counter(pwr);
+
+		/* WDT_FST auto set */
+		bd7181x_set_bits(mfd, BD7181X_REG_CHG_SET1, WDT_AUTO);
+
+		/* VBAT Low voltage detection Setting, added by John Zhang*/
+		bd7181x_reg_write16(mfd, BD7181X_REG_ALM_VBAT_TH_U, VBAT_LOW_TH); 
+
+		/* Mask Relax decision by PMU STATE */
+		bd7181x_set_bits(pwr->mfd, BD7181X_REG_REX_CTRL_1, REX_PMU_STATE_MASK);
+
+		/* Set Battery Capacity Monitor threshold1 as 90% */
+		bd7181x_reg_write16(mfd, BD7181X_REG_CC_BATCAP1_TH_U, (BD7181X_BATTERY_CAP * 9 / 10)); 
+		bd7181x_info(pwr->dev, "BD7181X_REG_CC_BATCAP1_TH = %d\n", (BD7181X_BATTERY_CAP * 9 / 10));
+
+		/* Enable LED ON when charging */
+		bd7181x_set_bits(pwr->mfd, BD7181X_REG_LED_CTRL, CHGDONE_LED_EN);
+
+		pwr->state_machine = STAT_POWER_ON;
+	} else {
+		pwr->designed_cap = BD7181X_BATTERY_CAP;
+		pwr->full_cap = BD7181X_BATTERY_CAP;	// bd7181x_reg_read16(pwr->mfd, BD7181X_REG_CC_BATCAP_U);
+		pwr->state_machine = STAT_INITIALIZED;	// STAT_INITIALIZED
+	}
+
+#ifdef CONFIG_LAB126
+	r = bd7181x_reg_read(mfd, BD7181X_REG_BAT_STAT);
+	if (r & BAT_DET){
+		/* Set Battery Capacity Monitor threshold1 as 90% */
+		bd7181x_reg_write16(mfd, BD7181X_REG_CC_BATCAP1_TH_U, (BD7181X_BATTERY_CAP * 9 / 10)); 
+		bd7181x_info(pwr->dev, "BD7181X_REG_CC_BATCAP1_TH = %d\n", (BD7181X_BATTERY_CAP * 9 / 10));
+
+		/* Enable LED ON when charging */
+		bd7181x_set_bits(pwr->mfd, BD7181X_REG_LED_CTRL, CHGDONE_LED_EN);
+	}
+#endif
+
+	pwr->temp = bd7181x_get_temp(pwr);
+	bd7181x_info(pwr->dev, "Temperature = %d\n", pwr->temp);
+	bd7181x_adjust_coulomb_count(pwr);
+	bd7181x_reset_coulomb_count(pwr);
+	pwr->coulomb_cnt = bd7181x_reg_read32(mfd, BD7181X_REG_CC_CCNTD_3) & 0x1FFFFFFFUL;
+	bd7181x_calc_soc_org(pwr);
+	pwr->soc_norm = pwr->soc_org;
+	pwr->soc = pwr->soc_norm;
+	pwr->clamp_soc = pwr->soc;
+	bd7181x_info(pwr->dev, "%s() CC_CCNTD = %d\n", __func__, pwr->coulomb_cnt);
+	bd7181x_info(pwr->dev, "%s() pwr->soc = %d\n", __func__, pwr->soc);
+	bd7181x_info(pwr->dev, "%s() pwr->clamp_soc = %d\n", __func__, pwr->clamp_soc);
+
+	pwr->cycle = battery_cycle;
+	pwr->curr = 0;
+	pwr->curr_sar = 0;
+	pwr->relax_time = 0;
+
+	return 0;
+}
+
+/**@brief timed work function called by system
+ *  read battery capacity,
+ *  sense change of charge status, etc.
+ * @param work work struct
+ * @return  void
+ */
+
+static void bd_work_callback(struct work_struct *work)
+{
+	struct bd7181x_power *pwr;
+	struct delayed_work *delayed_work;
+	int status, changed = 0;
+	static int cap_counter = 0;
+
+	delayed_work = container_of(work, struct delayed_work, work);
+	pwr = container_of(delayed_work, struct bd7181x_power, bd_work);
+
+	status = bd7181x_reg_read(pwr->mfd, BD7181X_REG_DCIN_STAT);
+	if (status != pwr->vbus_status) {
+		//printk("DCIN_STAT CHANGED from 0x%X to 0x%X\n", pwr->vbus_status, status);
+		pwr->vbus_status = status;
+#ifdef CONFIG_LAB126
+	   if(status != 0) //DCIN connected
+	   {
+		   usbotg_force_bsession(1);
+	   }
+	   else
+	   {
+		   usbotg_force_bsession(0);
+	   }
+#endif
+		changed = 1;
+	}
+
+	status = bd7181x_reg_read(pwr->mfd, BD7181X_REG_BAT_STAT);
+	status &= ~BAT_DET_DONE;
+	if (status != pwr->bat_status) {
+		//printk("BAT_STAT CHANGED from 0x%X to 0x%X\n", pwr->bat_status, status);
+		pwr->bat_status = status;
+		changed = 1;
+	}
+
+	status = bd7181x_reg_read(pwr->mfd, BD7181X_REG_CHG_STATE);
+	if (status != pwr->charge_status) {
+		//printk("CHG_STATE CHANGED from 0x%X to 0x%X\n", pwr->charge_status, status);
+		pwr->charge_status = status;
+		//changed = 1;
+	}
+
+	bd7181x_get_voltage_current(pwr);
+	bd7181x_adjust_coulomb_count(pwr);
+	bd7181x_reset_coulomb_count(pwr);
+	bd7181x_adjust_coulomb_count_sw(pwr);
+	bd7181x_coulomb_count(pwr);
+	bd7181x_update_cycle(pwr);
+	bd7181x_calc_full_cap(pwr);
+	bd7181x_calc_soc_org(pwr);
+	bd7181x_calc_soc_norm(pwr);
+	bd7181x_calc_soc(pwr);
+	bd7181x_calc_soc_clamp(pwr);
+	bd7181x_get_online(pwr);
+	bd7181x_charge_status(pwr);
+
+	if (changed || cap_counter++ > JITTER_REPORT_CAP / JITTER_DEFAULT) {
+		power_supply_changed(&pwr->ac);
+		power_supply_changed(&pwr->bat);
+		cap_counter = 0;
+	}
+
+	if (pwr->calib_current == CALIB_NORM) {
+		schedule_delayed_work(&pwr->bd_work, msecs_to_jiffies(JITTER_DEFAULT));
+	} else if (pwr->calib_current == CALIB_START) {
+		pwr->calib_current = CALIB_GO;
+	}
+}
+
+/**@brief bd7181x power interrupt
+ * @param irq system irq
+ * @param pwrsys bd7181x power device of system
+ * @retval IRQ_HANDLED success
+ * @retval IRQ_NONE error
+ */
+static irqreturn_t bd7181x_power_interrupt(int irq, void *pwrsys)
+{
+	struct device *dev = pwrsys;
+	struct bd7181x *mfd = dev_get_drvdata(dev->parent);
+	// struct bd7181x_power *pwr = dev_get_drvdata(dev);
+	int reg, r;
+
+	printk("bd7181x_power_interrupt() in.\n");
+	
+	reg = bd7181x_reg_read(mfd, BD7181X_REG_INT_STAT_03);
+	if (reg < 0)
+		return IRQ_NONE;
+
+	printk("INT_STAT_03 = 0x%.2X\n", reg);
+
+	r = bd7181x_reg_write(mfd, BD7181X_REG_INT_STAT_03, reg);
+	if (r)
+		return IRQ_NONE;
+
+	if (reg & DCIN_MON_DET) {
+		printk("\n~~~DCIN removed\n");
+	} else if (reg & DCIN_MON_RES) {
+		printk("\n~~~DCIN inserted\n");
+	}
+
+	return IRQ_HANDLED;
+}
+
+/**@brief bd7181x vbat low voltage detection interrupt
+ * @param irq system irq
+ * @param pwrsys bd7181x power device of system
+ * @retval IRQ_HANDLED success
+ * @retval IRQ_NONE error
+ * added by John Zhang at 2015-07-22
+ */
+static irqreturn_t bd7181x_vbat_interrupt(int irq, void *pwrsys)
+{
+	struct device *dev = pwrsys;
+	struct bd7181x *mfd = dev_get_drvdata(dev->parent);
+	// struct bd7181x_power *pwr = dev_get_drvdata(dev);
+	int reg, r;
+
+	printk("bd7181x_vbat_interrupt() in.\n");
+	
+	reg = bd7181x_reg_read(mfd, BD7181X_REG_INT_STAT_08);
+	if (reg < 0)
+		return IRQ_NONE;
+
+	printk("INT_STAT_08 = 0x%.2X\n", reg);
+
+	r = bd7181x_reg_write(mfd, BD7181X_REG_INT_STAT_08, reg);
+	if (r)
+		return IRQ_NONE;
+
+	if (reg & VBAT_MON_DET) {
+		printk("\n~~~ VBAT LOW Detected ... \n");
+		
+	} else if (reg & VBAT_MON_RES) {
+		printk("\n~~~ VBAT LOW Resumed ... \n");
+	}
+
+	return IRQ_HANDLED;
+	
+}
+
+/**@brief bd7181x int_stat_11 detection interrupt
+ * @param irq system irq
+ * @param pwrsys bd7181x power device of system
+ * @retval IRQ_HANDLED success
+ * @retval IRQ_NONE error
+ * added 2015-12-26
+ */
+static irqreturn_t bd7181x_int_11_interrupt(int irq, void *pwrsys)
+{
+	struct device *dev = pwrsys;
+	struct bd7181x *mfd = dev_get_drvdata(dev->parent);
+	// struct bd7181x_power *pwr = dev_get_drvdata(dev);
+	int reg, r;
+	
+	printk("bd7181x_int_11_interrupt() in.\n");
+	
+	reg = bd7181x_reg_read(mfd, BD7181X_REG_INT_STAT_11);
+	if (reg < 0)
+		return IRQ_NONE;
+
+	printk("INT_STAT_11 = 0x%.2X\n", reg);
+
+	r = bd7181x_reg_write(mfd, BD7181X_REG_INT_STAT_11, reg);
+	if (r) {
+		return IRQ_NONE;
+	}
+
+	if (reg & INT_STAT_11_VF_DET) {
+		printk("\n~~~ VF Detected ... \n");
+	} else if (reg & INT_STAT_11_VF_RES) {
+		printk("\n~~~ VF Resumed ... \n");
+	} else if (reg & INT_STAT_11_VF125_DET) {
+		printk("\n~~~ VF125 Detected ... \n");
+	} else if (reg & INT_STAT_11_VF125_RES) {
+		printk("\n~~~ VF125 Resumed ... \n");
+	} else if (reg & INT_STAT_11_OVTMP_DET) {
+		printk("\n~~~ Overtemp Detected ... \n");
+	} else if (reg & INT_STAT_11_OVTMP_RES) {
+		printk("\n~~~ Overtemp Detected ... \n");
+	} else if (reg & INT_STAT_11_LOTMP_DET) {
+		printk("\n~~~ Lowtemp Detected ... \n");
+	} else if (reg & INT_STAT_11_LOTMP_RES) {
+		printk("\n~~~ Lowtemp Detected ... \n");
+	}
+
+	return IRQ_HANDLED;
+
+}
+
+/** @brief get property of power supply ac
+ *  @param psy power supply deivce
+ *  @param psp property to get
+ *  @param val property value to return
+ *  @retval 0  success
+ *  @retval negative fail
+ */
+static int bd7181x_charger_get_property(struct power_supply *psy,
+					enum power_supply_property psp, union power_supply_propval *val)
+{
+	struct bd7181x_power *pwr = dev_get_drvdata(psy->dev->parent);
+	u32 vot;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = pwr->charger_online;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		vot = bd7181x_reg_read16(pwr->mfd, BD7181X_REG_VM_DCIN_U);
+		val->intval = 5000 * vot;		// 5 milli volt steps
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/** @brief get property of power supply bat
+ *  @param psy power supply deivce
+ *  @param psp property to get
+ *  @param val property value to return
+ *  @retval 0  success
+ *  @retval negative fail
+ */
+
+static int bd7181x_battery_get_property(struct power_supply *psy,
+					enum power_supply_property psp, union power_supply_propval *val)
+{
+	struct bd7181x_power *pwr = dev_get_drvdata(psy->dev->parent);
+	// u32 cap, vot, r;
+	// u8 ret;
+
+	switch (psp) {
+	/*
+	case POWER_SUPPLY_PROP_STATUS:
+		r = bd7181x_reg_read(pwr->mfd, BD7181X_REG_CHG_STATE);
+		// printk("CHG_STATE = 0x%.2X\n", r);
+		switch(r) {
+		case CHG_STATE_SUSPEND:
+			val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
+			break;
+		case CHG_STATE_TRICKLE_CHARGE:
+		case CHG_STATE_PRE_CHARGE:
+		case CHG_STATE_FAST_CHARGE:
+			val->intval = POWER_SUPPLY_STATUS_CHARGING;
+			break;
+		case CHG_STATE_TOP_OFF:
+		case CHG_STATE_DONE:
+			val->intval = POWER_SUPPLY_STATUS_FULL;
+			break;
+		default:
+			val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
+		}
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		ret = bd7181x_reg_read(pwr->mfd, BD7181X_REG_BAT_STAT);
+		if (ret & DBAT_DET)
+			val->intval = POWER_SUPPLY_HEALTH_DEAD;
+		else if (ret & VBAT_OV)
+			val->intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+		else
+			val->intval = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		cap = bd7181x_reg_read16(pwr->mfd, BD7181X_REG_CC_BATCAP_U);
+		// printk("CC_BATCAP = 0x%.4X\n", cap);
+		val->intval = cap * 100 / 0x1FFF;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		vot = bd7181x_reg_read16(pwr->mfd, BD7181X_REG_VM_VBAT_U) * 1000;
+		val->intval = vot;
+		break;
+	*/
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = pwr->rpt_status;
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = pwr->bat_health;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		if (pwr->rpt_status == POWER_SUPPLY_STATUS_CHARGING)
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_FAST;
+		else
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = pwr->bat_online;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = pwr->vcell;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		val->intval = pwr->clamp_soc;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_NOW:
+		{
+		u32 t;
+
+		t = pwr->coulomb_cnt >> 16;
+		t = A10s_mAh(t);
+		if (t > A10s_mAh(pwr->designed_cap)) t = A10s_mAh(pwr->designed_cap);
+		val->intval = t * 1000;		/* uA to report */
+		}
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = pwr->bat_online;
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = POWER_SUPPLY_TECHNOLOGY_LION;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		val->intval = BD7181X_BATTERY_FULL * A10s_mAh(pwr->designed_cap) * 10;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		val->intval = BD7181X_BATTERY_FULL * A10s_mAh(pwr->full_cap) * 10;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = pwr->curr_sar;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		val->intval = pwr->curr;
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		val->intval = pwr->temp * 10; /* 0.1 degrees C unit */
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		val->intval = MAX_VOLTAGE;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MIN:
+		val->intval = MIN_VOLTAGE;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		val->intval = MAX_CURRENT;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/** @brief ac properties */
+static enum power_supply_property bd7181x_charger_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+};
+
+/** @brief bat properies */
+static enum power_supply_property bd7181x_battery_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_CHARGE_NOW,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX,
+	POWER_SUPPLY_PROP_VOLTAGE_MIN,
+	POWER_SUPPLY_PROP_CURRENT_MAX,
+};
+
+/** @brief directly set raw value to chip register, format: 'register value' */
+static ssize_t bd7181x_sysfs_set_registers(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf,
+					   size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct bd7181x_power *pwr = container_of(psy, struct bd7181x_power, bat);
+	ssize_t ret = 0;
+	unsigned int reg;
+	unsigned int val;
+
+	ret = sscanf(buf, "%x %x", &reg, &val);
+	if (ret < 1) {
+		pwr->reg_index = -1;
+		return count;
+	}
+
+	if (ret == 1 && reg <= BD7181X_MAX_REGISTER) {
+		pwr->reg_index = reg;
+		return count;
+	}
+	if (reg > BD7181X_MAX_REGISTER || val > 255)
+		return -EINVAL;
+
+	ret = bd7181x_reg_write(pwr->mfd, reg, val);
+	if (ret < 0)
+		return ret;
+	return count;
+}
+
+/** @brief print value of chip register, format: 'register=value' */
+static ssize_t bd7181x_sysfs_print_reg(struct bd7181x_power *pwr,
+				       u8 reg,
+				       char *buf)
+{
+	int ret = bd7181x_reg_read(pwr->mfd, reg);
+
+	if (ret < 0)
+		return sprintf(buf, "%#.2x=error %d\n", reg, ret);
+	return sprintf(buf, "[0x%.2X] = %.2X\n", reg, ret);
+}
+
+/** @brief show all raw values of chip register, format per line: 'register=value' */
+static ssize_t bd7181x_sysfs_show_registers(struct device *dev,
+					    struct device_attribute *attr,
+					    char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct bd7181x_power *pwr = container_of(psy, struct bd7181x_power, bat);
+	ssize_t ret = 0;
+	int i;
+
+	if (pwr->reg_index >= 0) {
+		ret += bd7181x_sysfs_print_reg(pwr, pwr->reg_index, buf + ret);
+	} else {
+		for (i = 0; i <= BD7181X_MAX_REGISTER; i++) {
+			ret += bd7181x_sysfs_print_reg(pwr, i, buf + ret);
+		}
+	}
+	return ret;
+}
+
+static DEVICE_ATTR(registers, S_IWUSR | S_IRUGO,
+		bd7181x_sysfs_show_registers, bd7181x_sysfs_set_registers);
+
+static int first_offset(struct bd7181x_power *pwr)
+{
+	unsigned char ra2, ra3, ra6, ra7;
+	unsigned char ra2_temp;
+	struct bd7181x *mfd = pwr->mfd;
+
+	bd7181x_reg_write(mfd, BD7181X_REG_TEST_MODE, TEST_SEQ_01);
+	bd7181x_reg_write(mfd, BD7181X_REG_TEST_MODE, TEST_SEQ_02);
+	bd7181x_reg_write(mfd, BD7181X_REG_TEST_MODE, TEST_SEQ_03);
+
+
+	ra2 = bd7181x_reg_read(mfd, 0xA2);	// I want to know initial A2 & A3.
+	ra3 = bd7181x_reg_read(mfd, 0xA3);	// I want to know initial A2 & A3.
+	ra6 = bd7181x_reg_read(mfd, 0xA6);
+	ra7 = bd7181x_reg_read(mfd, 0xA7);
+
+	bd7181x_reg_write(mfd, 0xA2, 0x00);
+	bd7181x_reg_write(mfd, 0xA3, 0x00);
+
+	bd7181x_info(pwr->dev, "TEST[A2] = 0x%.2X\n", ra2);
+	bd7181x_info(pwr->dev, "TEST[A3] = 0x%.2X\n", ra3);
+	bd7181x_info(pwr->dev, "TEST[A6] = 0x%.2X\n", ra6);
+	bd7181x_info(pwr->dev, "TEST[A7] = 0x%.2X\n", ra7);
+
+	//-------------- First Step -------------------
+	bd7181x_info(pwr->dev, "Frist Step begginning \n");
+
+	// delay some time , Make a state of IBAT=0mA
+	// mdelay(1000 * 10);
+
+	ra2_temp = ra2;
+
+	if (ra7 != 0) {
+		//if 0<0xA7<20 decrease the Test register 0xA2[7:3] until 0xA7 becomes 0x00.
+		if ((ra7 > 0) && (ra7 < 20)) {
+			do {
+				ra2 = bd7181x_reg_read(mfd, 0xA2);
+				ra2_temp = ra2 >> 3;
+				ra2_temp -= 1;
+				ra2_temp <<= 3;
+				bd7181x_reg_write(mfd, 0xA2, ra2_temp);
+				bd7181x_info(pwr->dev, "TEST[A2] = 0x%.2X\n", ra2_temp);
+
+				ra7 = bd7181x_reg_read(mfd, 0xA7);
+				bd7181x_info(pwr->dev, "TEST[A7] = 0x%.2X\n", ra7);
+				mdelay(1000);	// 1sec?
+			} while (ra7);
+
+			bd7181x_info(pwr->dev, "A7 becomes 0 . \n");
+
+		}		// end if((ra7 > 0)&&(ra7 < 20)) 
+		else if ((ra7 > 0xDF) && (ra7 < 0xFF))
+			//if DF<0xA7<FF increase the Test register 0xA2[7:3] until 0xA7 becomes 0x00.
+		{
+			do {
+				ra2 = bd7181x_reg_read(mfd, 0xA2);
+				ra2_temp = ra2 >> 3;
+				ra2_temp += 1;
+				ra2_temp <<= 3;
+
+				bd7181x_reg_write(mfd, 0xA2, ra2_temp);
+				bd7181x_info(pwr->dev, "TEST[A2] = 0x%.2X\n", ra2_temp);
+
+				ra7 = bd7181x_reg_read(mfd, 0xA7);
+				bd7181x_info(pwr->dev, "TEST[A7] = 0x%.2X\n", ra7);
+				mdelay(1000);	// 1sec?                           
+			} while (ra7);
+
+			bd7181x_info(pwr->dev, "A7 becomes 0 . \n");
+		}
+	}
+
+	// please use "ra2_temp" at step2.
+	return ra2_temp;
+}
+
+static int second_step(struct bd7181x_power *pwr, u8 ra2_temp)
+{
+	u16 ra6, ra7;
+	u8 aft_ra2, aft_ra3;
+	u8 r79, r7a;
+	unsigned int LNRDSA_FUSE;
+	long ADC_SIGN;
+	long DSADGAIN1_INI;
+	struct bd7181x *mfd = pwr->mfd;
+
+	//-------------- Second Step -------------------
+	bd7181x_info(pwr->dev, "Second Step begginning \n");
+
+	// need to change boad setting ( input 1A tio 10mohm)
+	// delay some time , Make a state of IBAT=1000mA
+	// mdelay(1000 * 10);
+
+// rough adjust
+	bd7181x_info(pwr->dev, "ra2_temp = 0x%.2X\n", ra2_temp);
+
+	ra6 = bd7181x_reg_read(mfd, 0xA6);
+	ra7 = bd7181x_reg_read(mfd, 0xA7);
+	ra6 <<= 8;
+	ra6 |= ra7;		// [0xA6 0xA7]
+	bd7181x_info(pwr->dev, "TEST[A6,A7] = 0x%.4X\n", ra6);
+
+	bd7181x_reg_write(mfd, 0xA2, ra2_temp);	// this value from step1
+	bd7181x_reg_write(mfd, 0xA3, 0x00);
+
+	bd7181x_reg_write(mfd, BD7181X_REG_TEST_MODE, TEST_SEQ_00);
+
+	r79 = bd7181x_reg_read(mfd, 0x79);
+	r7a = bd7181x_reg_read(mfd, 0x7A);
+
+	ADC_SIGN = r79 >> 7;
+	ADC_SIGN = 1 - (2 * ADC_SIGN);
+	DSADGAIN1_INI = r79 << 8;
+	DSADGAIN1_INI = DSADGAIN1_INI + r7a;
+	DSADGAIN1_INI = DSADGAIN1_INI & 0x7FFF;
+	DSADGAIN1_INI = DSADGAIN1_INI * ADC_SIGN; //  unit 0.001
+
+	// unit 0.000001
+	DSADGAIN1_INI *= 1000;
+	{
+	if (DSADGAIN1_INI > 1000001) {
+		DSADGAIN1_INI = 2048000000UL - (DSADGAIN1_INI - 1000000) * 8187;
+	} else if (DSADGAIN1_INI < 999999) {
+		DSADGAIN1_INI = -(DSADGAIN1_INI - 1000000) * 8187;
+	} else {
+		DSADGAIN1_INI = 0;
+	}
+	}
+
+	LNRDSA_FUSE = (int) DSADGAIN1_INI / 1000000;
+
+	bd7181x_info(pwr->dev, "LNRDSA_FUSE = 0x%.8X\n", LNRDSA_FUSE);
+
+	aft_ra2 = (LNRDSA_FUSE >> 8) & 255;
+	aft_ra3 = (LNRDSA_FUSE) & 255;
+
+	aft_ra2 = aft_ra2 + ra2_temp;
+
+	bd7181x_reg_write(mfd, BD7181X_REG_TEST_MODE, TEST_SEQ_01);
+	bd7181x_reg_write(mfd, BD7181X_REG_TEST_MODE, TEST_SEQ_02);
+	bd7181x_reg_write(mfd, BD7181X_REG_TEST_MODE, TEST_SEQ_03);
+
+	bd7181x_reg_write(mfd, 0xA2, aft_ra2);
+	bd7181x_reg_write(mfd, 0xA3, aft_ra3);
+
+	return 0;
+}
+
+static int third_step(struct bd7181x_power *pwr, unsigned thr) {
+	u16 ra2_a3, ra6, ra7;
+	u8 ra2, ra3;
+	u8 aft_ra2, aft_ra3;
+	struct bd7181x *mfd = pwr->mfd;
+
+// fine adjust
+	ra2 = bd7181x_reg_read(mfd, 0xA2);	//
+	ra3 = bd7181x_reg_read(mfd, 0xA3);	//
+
+	ra6 = bd7181x_reg_read(mfd, 0xA6);
+	ra7 = bd7181x_reg_read(mfd, 0xA7);
+	ra6 <<= 8;
+	ra6 |= ra7;		// [0xA6 0xA7]
+	bd7181x_info(pwr->dev, "TEST[A6,A7] = 0x%.4X\n", ra6);
+
+
+	if (ra6 > thr) {
+		do {
+			ra2_a3 = bd7181x_reg_read(mfd, 0xA2);
+			ra2_a3 <<= 8;
+			ra3 = bd7181x_reg_read(mfd, 0xA3);
+			ra2_a3 |= ra3;
+			//ra2_a3 >>= 3; // ? 0xA3[7:3] , or 0xA3[7:0]
+
+			ra2_a3 -= 1;
+			//ra2_a3 <<= 3;
+			ra3 = ra2_a3;
+			bd7181x_reg_write(mfd, 0xA3, ra3);
+
+			ra2_a3 >>= 8;
+			ra2 = ra2_a3;
+			bd7181x_reg_write(mfd, 0xA2, ra2);
+
+			bd7181x_info(pwr->dev, "TEST[A2] = 0x%.2X , TEST[A3] = 0x%.2X \n", ra2, ra3);
+
+			mdelay(1000);	// 1sec?
+
+			ra6 = bd7181x_reg_read(mfd, 0xA6);
+			ra7 = bd7181x_reg_read(mfd, 0xA7);
+			ra6 <<= 8;
+			ra6 |= ra7;	// [0xA6 0xA7]
+			bd7181x_info(pwr->dev, "TEST[A6,A7] = 0x%.4X\n", ra6);
+		} while (ra6 > thr);
+	} else if (ra6 < thr) {
+		do {
+			ra2_a3 = bd7181x_reg_read(mfd, 0xA2);
+			ra2_a3 <<= 8;
+			ra3 = bd7181x_reg_read(mfd, 0xA3);
+			ra2_a3 |= ra3;
+			//ra2_a3 >>= 3; // ? 0xA3[7:3] , or 0xA3[7:0]
+
+			ra2_a3 += 1;
+			//ra2_a3 <<= 3;
+			ra3 = ra2_a3;
+			bd7181x_reg_write(mfd, 0xA3, ra3);
+
+			ra2_a3 >>= 8;
+			ra2 = ra2_a3;
+			bd7181x_reg_write(mfd, 0xA2, ra2);
+
+			bd7181x_info(pwr->dev, "TEST[A2] = 0x%.2X , TEST[A3] = 0x%.2X \n", ra2, ra3);
+
+			mdelay(1000);	// 1sec?
+
+			ra6 = bd7181x_reg_read(mfd, 0xA6);
+			ra7 = bd7181x_reg_read(mfd, 0xA7);
+			ra6 <<= 8;
+			ra6 |= ra7;	// [0xA6 0xA7]
+			bd7181x_info(pwr->dev, "TEST[A6,A7] = 0x%.4X\n", ra6);
+
+		} while (ra6 < thr);
+	}
+
+	bd7181x_info(pwr->dev, "[0xA6 0xA7] becomes [0x%.4X] . \n", thr);
+	bd7181x_info(pwr->dev, " Calibation finished ... \n\n");
+
+	aft_ra2 = bd7181x_reg_read(mfd, 0xA2);	// 
+	aft_ra3 = bd7181x_reg_read(mfd, 0xA3);	// I want to know initial A2 & A3.
+
+	bd7181x_info(pwr->dev, "TEST[A2,A3] = 0x%.2X%.2X\n", aft_ra2, aft_ra3);
+
+	// bd7181x_reg_write(mfd, BD7181X_REG_TEST_MODE, TEST_SEQ_00);
+
+	return 0;
+}
+
+static ssize_t bd7181x_sysfs_set_calibrate(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf,
+					   size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct bd7181x_power *pwr = container_of(psy, struct bd7181x_power, bat);
+	ssize_t ret = 0;
+	unsigned int val, mA;
+	static u8 rA2;
+
+	ret = sscanf(buf, "%d %d", &val, &mA);
+	if (ret < 1) {
+		bd7181x_info(pwr->dev, "error: write a integer string");
+		return count;
+	}
+
+	if (val == 1) {
+		pwr->calib_current = CALIB_START;
+		while (pwr->calib_current != CALIB_GO) {
+			msleep(500);
+		}
+		rA2 = first_offset(pwr);
+	}
+	if (val == 2) {
+		second_step(pwr, rA2);
+	}
+	if (val == 3) {
+		if (ret <= 1) {
+			bd7181x_info(pwr->dev, "error: Fine adjust need a mA argument!");
+		} else {
+		unsigned int ra6_thr;
+
+		ra6_thr = mA * 0xFFFF / 20000;
+		bd7181x_info(pwr->dev, "Fine adjust at %d mA, ra6 threshold %d(0x%X)\n", mA, ra6_thr, ra6_thr);
+		third_step(pwr, ra6_thr);
+		}
+	}
+	if (val == 4) {
+		bd7181x_reg_write(pwr->mfd, BD7181X_REG_TEST_MODE, TEST_SEQ_00);
+		pwr->calib_current = CALIB_NORM;
+		schedule_delayed_work(&pwr->bd_work, msecs_to_jiffies(0));
+	}
+
+	return count;
+}
+
+static ssize_t bd7181x_sysfs_show_calibrate(struct device *dev,
+					    struct device_attribute *attr,
+					    char *buf)
+{
+	// struct power_supply *psy = dev_get_drvdata(dev);
+	// struct bd7181x_power *pwr = container_of(psy, struct bd7181x_power, bat);
+	ssize_t ret = 0;
+
+	ret = 0;
+	ret += sprintf(buf + ret, "write string value\n"
+		"\t1      0 mA for step one\n"
+		"\t2      1000 mA for rough adjust\n"
+		"\t3 <mA> for fine adjust\n"
+		"\t4      exit current calibration\n");
+	return ret;
+}
+
+static DEVICE_ATTR(calibrate, S_IWUSR | S_IRUGO,
+		bd7181x_sysfs_show_calibrate, bd7181x_sysfs_set_calibrate);
+
+static struct attribute *bd7181x_sysfs_attributes[] = {
+	/*
+	 * TODO: some (appropriate) of these attrs should be switched to
+	 * use pwr supply class props.
+	 */
+	&dev_attr_registers.attr,
+	&dev_attr_calibrate.attr,
+	NULL,
+};
+
+static const struct attribute_group bd7181x_sysfs_attr_group = {
+	.attrs = bd7181x_sysfs_attributes,
+};
+
+/** @brief powers supplied by bd7181x_ac */
+static char *bd7181x_ac_supplied_to[] = {
+	BAT_NAME,
+};
+
+/** @brief probe pwr device 
+ * @param pdev platform deivce of bd7181x_power
+ * @retval 0 success
+ * @retval negative fail
+ */
+static int __init bd7181x_power_probe(struct platform_device *pdev)
+{
+	struct bd7181x *bd7181x = dev_get_drvdata(pdev->dev.parent);
+	struct bd7181x_power *pwr;
+	int irq, ret, reg;
+
+	pwr = kzalloc(sizeof(*pwr), GFP_KERNEL);
+	if (pwr == NULL)
+		return -ENOMEM;
+
+	pwr->dev = &pdev->dev;
+	pwr->mfd = bd7181x;
+
+	platform_set_drvdata(pdev, pwr);
+
+	if (battery_cycle <= 0) {
+		battery_cycle = 0;
+	}
+	dev_err(pwr->dev, "battery_cycle = %d\n", battery_cycle);
+
+	/* If the product often power up/down and the power down time is long, the Coulomb Counter may have a drift. */
+	/* If so, it may be better accuracy to enable Coulomb Counter using following commented out code */
+	/* for counting Coulomb when the product is power up(including sleep). */
+	/* The condition  */
+	/* (1) Product often power up and down, the power down time is long and there is no power consumed in power down time. */
+	/* (2) Kernel must call this routin at power up time. */
+	/* (3) Kernel must call this routin at charging time. */
+	/* (4) Must use this code with "Stop Coulomb Counter" code in bd7181x_power_remove() function */
+	/* Start Coulomb Counter */
+	/* bd7181x_set_bits(pwr->mfd, BD7181x_REG_CC_CTRL, CCNTENB); */
+
+	bd7181x_init_hardware(pwr);
+
+	pwr->bat.name = BAT_NAME;
+	pwr->bat.type = POWER_SUPPLY_TYPE_BATTERY;
+	pwr->bat.properties = bd7181x_battery_props;
+	pwr->bat.num_properties = ARRAY_SIZE(bd7181x_battery_props);
+	pwr->bat.get_property = bd7181x_battery_get_property;
+
+	ret = power_supply_register(&pdev->dev, &pwr->bat);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register usb: %d\n", ret);
+		goto fail_register_bat;
+	}
+
+	pwr->ac.name = AC_NAME;
+	pwr->ac.type = POWER_SUPPLY_TYPE_MAINS;
+	pwr->ac.properties = bd7181x_charger_props;
+	pwr->ac.supplied_to = bd7181x_ac_supplied_to;
+	pwr->ac.num_supplicants = ARRAY_SIZE(bd7181x_ac_supplied_to);
+	pwr->ac.num_properties = ARRAY_SIZE(bd7181x_charger_props);
+	pwr->ac.get_property = bd7181x_charger_get_property;
+
+	ret = power_supply_register(&pdev->dev, &pwr->ac);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register ac: %d\n", ret);
+		goto fail_register_ac;
+	}
+
+	/*Add DC_IN Inserted and Remove ISR */
+	irq  = platform_get_irq(pdev, 0); // get irq number 
+#ifdef __BD7181X_REGMAP_H__
+	irq += bd7181x->irq_base;
+#endif
+	if (irq <= 0) {
+		dev_warn(&pdev->dev, "platform irq error # %d\n", irq);
+		return -ENXIO;
+	}
+
+	ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
+		bd7181x_power_interrupt, IRQF_TRIGGER_LOW | IRQF_EARLY_RESUME,
+		dev_name(&pdev->dev), &pdev->dev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "IRQ %d is not free.\n", irq);
+	}
+
+	/*add VBAT Low Voltage detection, John Zhang*/
+	irq  = platform_get_irq(pdev, 1);
+#ifdef __BD7181X_REGMAP_H__
+	irq += bd7181x->irq_base;
+#endif
+	if (irq <= 0) {
+		dev_warn(&pdev->dev, "platform irq error # %d\n", irq);
+		return -ENXIO;
+	}
+
+	ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
+		bd7181x_vbat_interrupt, IRQF_TRIGGER_LOW | IRQF_EARLY_RESUME,
+		dev_name(&pdev->dev), &pdev->dev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "IRQ %d is not free.\n", irq);
+	}
+
+	/* add INT_STAT_11 */
+	irq  = platform_get_irq(pdev, 2);
+#ifdef __BD7181X_REGMAP_H__
+	irq += bd7181x->irq_base;
+#endif
+	if (irq <= 0) {
+		dev_warn(&pdev->dev, "platform irq error # %d\n", irq);
+		return -ENXIO;
+	}
+
+	ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
+		bd7181x_int_11_interrupt, IRQF_TRIGGER_LOW | IRQF_EARLY_RESUME,
+		dev_name(&pdev->dev), &pdev->dev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "IRQ %d is not free.\n", irq);
+	}
+
+	/* Enable INT_11 */
+	ret = bd7181x_reg_write(bd7181x, BD7181X_REG_INT_EN_11, 0xFF);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "Write BD7181X_REG_INT_EN_11 failed\n");
+	}
+	reg = bd7181x_reg_read(bd7181x, BD7181X_REG_INT_EN_11);
+	if (reg < 0) {
+		dev_warn(&pdev->dev, "Read BD7181X_REG_INT_EN_11 failed\n");
+	}
+	dev_info(&pdev->dev, "BD7181X_REG_INT_EN_11=0x%x\n", reg);
+
+
+	ret = sysfs_create_group(&pwr->bat.dev->kobj, &bd7181x_sysfs_attr_group);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to register sysfs interface\n");
+	}
+
+	pwr->reg_index = -1;
+
+	INIT_DELAYED_WORK(&pwr->bd_work, bd_work_callback);
+
+	/* Schedule timer to check current status */
+	pwr->calib_current = CALIB_NORM;
+	schedule_delayed_work(&pwr->bd_work, msecs_to_jiffies(0));
+
+	return 0;
+
+//error_exit:
+	power_supply_unregister(&pwr->ac);
+fail_register_ac:
+	power_supply_unregister(&pwr->bat);
+fail_register_bat:
+	platform_set_drvdata(pdev, NULL);
+	kfree(pwr);
+
+	return ret;
+}
+
+/** @brief remove pwr device
+ * @param pdev platform deivce of bd7181x_power
+ * @return 0
+ */
+
+static int __exit bd7181x_power_remove(struct platform_device *pdev)
+{
+	struct bd7181x_power *pwr = platform_get_drvdata(pdev);
+
+	/* If the product often power up/down and the power down time is long, the Coulomb Counter may have a drift. */
+	/* If so, it may be better accuracy to disable Coulomb Counter using following commented out code */
+	/* for stopping counting Coulomb when the product is power down(without sleep). */
+	/* The condition  */
+	/* (1) Product often power up and down, the power down time is long and there is no power consumed in power down time. */
+	/* (2) Kernel must call this routin at power down time. */
+	/* (3) Must use this code with "Start Coulomb Counter" code in bd7181x_power_probe() function */
+	/* Stop Coulomb Counter */
+	/* bd7181x_clear_bits(pwr->mfd, BD7181x_REG_CC_CTRL, CCNTENB); */
+
+	sysfs_remove_group(&pwr->bat.dev->kobj, &bd7181x_sysfs_attr_group);
+
+	cancel_delayed_work(&pwr->bd_work);
+
+	power_supply_unregister(&pwr->bat);
+	power_supply_unregister(&pwr->ac);
+	platform_set_drvdata(pdev, NULL);
+	kfree(pwr);
+
+	return 0;
+}
+
+static struct platform_driver bd7181x_power_driver = {
+	.driver = {
+		.name = "bd7181x-power",
+		.owner = THIS_MODULE,
+	},
+	.remove = __exit_p(bd7181x_power_remove),
+};
+
+/** @brief module initialize function */
+static int __init bd7181x_power_init(void)
+{
+	return platform_driver_probe(&bd7181x_power_driver, bd7181x_power_probe);
+}
+
+module_init(bd7181x_power_init);
+
+/** @brief module deinitialize function */
+static void __exit bd7181x_power_exit(void)
+{
+	platform_driver_unregister(&bd7181x_power_driver);
+}
+
+module_exit(bd7181x_power_exit);
+
+module_param(battery_cycle, uint, S_IWUSR | S_IRUGO);
+MODULE_PARM_DESC(battery_parameters, "battery_cycle:battery charge/discharge cycles");
+
+MODULE_AUTHOR("Tony Luo <luofc@embest-tech.com>");
+MODULE_AUTHOR("Peter Yang <yanglsh@embest-tech.com>");
+MODULE_DESCRIPTION("BD71815/BD71817 Battery Charger Power driver");
+MODULE_LICENSE("GPL");
+
+
+/*-------------------------------------------------------*/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+
+#define PROCFS_NAME 		"bd7181x_rev"
+#if defined(BD7181X_REV_LONG)
+#define BD7181X_REV			"BD7181x Driver: \n" \
+							"1.Rev1583/rev1584: \n" \
+							"  Reason of change: \n" \
+							"  \tDVDREF LDO is not staying ON.\n" \
+							"  Changes: \n" \
+							"  \tThis LDO is disabled in the .dts file. \n" \
+							"  \tWe are now keeping this LDO always ON.\n" \
+							"2.Rev1585: \n" \
+							"  Reason of change: \n" \
+							"  \tBugs found during testing.\n" \
+							"  Changes: \n" \
+							"  \tTemp measurment in init function SOC when very low gives wrong value.\n" \
+							"  \tChanges done by Lab incoroprated with Rohm.\n" \
+							"3.Rev1586: \n" \
+							"  Reason of change: \n" \
+							"  \tLab production testing of green led's and \n" \
+							"  \tship mode requires some initilzation of  \n" \
+							"  \tregisters during driver boot up.\n" \
+							"  Changes: \n" \
+							"  \tRegisters are being set in the probe/init function as requesed by lab.\n" \
+							"4.Rev1587: \n" \
+							"  Reason of change: \n" \
+							"  \tRead changes history.\n" \
+							"  Changes: \n" \
+							"  \tAdd module comand '/proc/bd7181x_rev'.\n" \
+							"  \tInstruction: 'cat /proc/bd7181x_rev' \n"
+							"5.Rev1588: \n" \
+							"  Reason of change: \n" \
+							"  \tImplement Interrupt to process VF/VF125/OVTMP/LOTMP Detect/Resume.\n" \
+							"  Changes: \n" \
+							"  \tAdd interrupt resource 'power_resources[2]' at 'bd7181x.c'.\n" \
+							"  \tAdd interrupt handler function 'bd7181x_int_11_interrupt()' at 'bd7181x-power.c'\n"
+#else
+#define BD7181X_REV			"BD7181x Driver: Rev1589\n"
+#endif
+
+#define BD7181X_BUF_SIZE	1024
+static char procfs_buffer[BD7181X_BUF_SIZE];
+/**
+ * This function is called then the /proc file is read
+ *
+ */
+static int onetime = 0;
+static ssize_t bd7181x_proc_read (struct file *file, char __user *buffer, size_t count, loff_t *data)
+{
+	int ret = 0, error = 0;
+	if(onetime==0) {
+		onetime = 1;
+		memset( procfs_buffer, 0, BD7181X_BUF_SIZE);
+		sprintf(procfs_buffer, "%s", BD7181X_REV);
+		ret = strlen(procfs_buffer);
+		error = copy_to_user(buffer, procfs_buffer, strlen(procfs_buffer));
+	} else {
+		//Clear for next time
+		onetime = 0;
+	}
+	return (error!=0)?0:ret;
+}
+
+static const struct file_operations bd7181x_proc_fops = {
+	.owner		= THIS_MODULE,
+	.read		= bd7181x_proc_read,
+};
+
+/**
+ *This function is called when the module is loaded
+ *
+ */
+int bd7181x_revision_init(void)
+{
+	struct proc_dir_entry *bd7181x_proc_entry;
+
+	/* create the /proc/bd7181x_rev */
+	bd7181x_proc_entry = proc_create(PROCFS_NAME, 0644, NULL, &bd7181x_proc_fops);
+	if (bd7181x_proc_entry == NULL) {
+		printk("Error: Could not initialize /proc/%s\n", PROCFS_NAME);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+module_init(bd7181x_revision_init);
+/*-------------------------------------------------------*/
diff --git a/drivers/regulator/Kconfig b/drivers/regulator/Kconfig
index ed96adc..ad12a7a 100644
--- a/drivers/regulator/Kconfig
+++ b/drivers/regulator/Kconfig
@@ -596,5 +596,12 @@ config REGULATOR_WM8994
 	  This driver provides support for the voltage regulators on the
 	  WM8994 CODEC.
 
+
+config REGULATOR_BD7181X
+    tristate "RoHM BD71815/BD71817 Power Regulator"
+    depends on MFD_BD7181X
+    help
+      This driver supports BD71815/BD71817 voltage regulator chips.
+
 endif
 
diff --git a/drivers/regulator/Makefile b/drivers/regulator/Makefile
index a2163ca..5ae2f74 100644
--- a/drivers/regulator/Makefile
+++ b/drivers/regulator/Makefile
@@ -81,6 +81,6 @@ obj-$(CONFIG_REGULATOR_WM831X) += wm831x-ldo.o
 obj-$(CONFIG_REGULATOR_WM8350) += wm8350-regulator.o
 obj-$(CONFIG_REGULATOR_WM8400) += wm8400-regulator.o
 obj-$(CONFIG_REGULATOR_WM8994) += wm8994-regulator.o
-
+obj-$(CONFIG_REGULATOR_BD7181X) += bd7181x-regulator.o
 
 ccflags-$(CONFIG_REGULATOR_DEBUG) += -DDEBUG
diff --git a/drivers/regulator/bd7181x-regulator.c b/drivers/regulator/bd7181x-regulator.c
new file mode 100644
index 0000000..cb0f924
--- /dev/null
+++ b/drivers/regulator/bd7181x-regulator.c
@@ -0,0 +1,551 @@
+/*
+ * @file bd7181x-regulator.c RoHM BD71815/BD71817 regulator driver
+ *
+ * Copyright 2014 Embest Technology Co. Ltd. Inc.
+ *
+ * @author Tony Luo <luofc@embedinfo.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under  the terms of the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/mfd/bd7181x.h>
+#include <linux/regulator/of_regulator.h>
+
+#define BD7181X_VOL_OFFSET		0
+#define BD7181X_STANDBY_OFFSET		0
+
+struct bd7181x_regulator {
+	struct regulator_desc desc;
+	unsigned char stby_reg;
+	unsigned char stby_mask;
+};
+
+/** @brief bd7181x regulator type */
+struct bd7181x_pmic {
+	struct bd7181x_regulator descs[BD7181X_REGULATOR_CNT];	/**< regulator description to system */
+	struct bd7181x *mfd;					/**< parent device */
+	struct device *dev;					/**< regulator kernel device */
+	struct regulator_dev *rdev[BD7181X_REGULATOR_CNT];	/**< regulator device of system */
+};
+
+static const int bd7181x_wled_currents[] = {
+	// 0x00
+	10, 20, 30, 50,
+	70, 100, 200, 300,
+	500, 700, 1000, 2000,
+	3000, 4000, 5000, 6000,
+	// 0x10
+	7000, 8000, 9000, 10000,
+	11000, 12000, 13000, 14000,
+	15000, 16000, 17000, 18000,
+	19000, 20000, 21000, 22000,
+	// 0x20
+	23000, 24000, 25000,
+};
+
+static int bd7181x_set_ramp_delay(struct regulator_dev *rdev, int ramp_delay) {
+	struct bd7181x_pmic *pmic = rdev_get_drvdata(rdev);
+	struct bd7181x *mfd = pmic->mfd;
+	// int id = rdev->desc->id;
+	unsigned int ramp_bits;
+	int ret;
+
+	if (1 /*TODO*/ ) {
+		ramp_delay = 12500 / ramp_delay;
+		ramp_bits = (ramp_delay >> 1) - (ramp_delay >> 3);
+		ret = regmap_update_bits(mfd->regmap,
+					 rdev->desc->vsel_reg + 4,
+					 0xc0, ramp_bits << 6);
+		if (ret < 0)
+			dev_err(pmic->dev, "ramp failed, err %d\n", ret);
+	} else
+		ret = -EACCES;
+
+	return ret;
+}
+
+static int bd7181x_led_set_current_limit(struct regulator_dev *rdev,
+					int min_uA, int max_uA)
+{
+	struct bd7181x_pmic* pmic = rdev_get_drvdata(rdev);
+	struct bd7181x* mfd = pmic->mfd;
+	u8 addr;
+	// int id = rdev_get_id(rdev);
+	int i;
+
+	addr = BD7181X_REG_LED_DIMM;
+
+	for (i = ARRAY_SIZE(bd7181x_wled_currents) - 1 ; i >= 0; i--) {
+		if (bd7181x_wled_currents[i] >= min_uA &&
+			bd7181x_wled_currents[i] <= max_uA)
+			return bd7181x_update_bits(mfd, addr, 0x3F, i);
+	}
+
+	return -EINVAL;
+}
+
+static int bd7181x_led_get_current_limit(struct regulator_dev *rdev)
+{
+	struct bd7181x_pmic* pmic = rdev_get_drvdata(rdev);
+	struct bd7181x* mfd = pmic->mfd;
+	// int id = rdev_get_id(rdev);
+	u8 addr;
+	int r;
+
+	addr = BD7181X_REG_LED_DIMM;
+
+	r = bd7181x_reg_read(mfd, addr);
+	if (r < 0) {
+		return r;
+	}
+
+	r = r & 0x3F;
+
+	return (r < ARRAY_SIZE(bd7181x_wled_currents)) ?
+			bd7181x_wled_currents[r] : -EINVAL;
+}
+
+static struct regulator_ops bd7181x_ldo_regulator_ops = {
+	.enable = regulator_enable_regmap,
+	.disable = regulator_disable_regmap,
+	.is_enabled = regulator_is_enabled_regmap,
+	.list_voltage = regulator_list_voltage_linear,
+	.set_voltage_sel = regulator_set_voltage_sel_regmap,
+	.get_voltage_sel = regulator_get_voltage_sel_regmap,
+};
+
+static struct regulator_ops bd7181x_fixed_regulator_ops = {
+	.enable = regulator_enable_regmap,
+	.disable = regulator_disable_regmap,
+	.is_enabled = regulator_is_enabled_regmap,
+	.list_voltage = regulator_list_voltage_linear,
+};
+
+static struct regulator_ops bd7181x_buck_regulator_ops = {
+	.enable = regulator_enable_regmap,
+	.disable = regulator_disable_regmap,
+	.is_enabled = regulator_is_enabled_regmap,
+	.list_voltage = regulator_list_voltage_linear,
+	.set_voltage_sel = regulator_set_voltage_sel_regmap,
+	.get_voltage_sel = regulator_get_voltage_sel_regmap,
+	.set_voltage_time_sel = regulator_set_voltage_time_sel,
+	.set_ramp_delay = bd7181x_set_ramp_delay,
+};
+
+static struct regulator_ops bd7181x_led_regulator_ops = {
+	.enable = regulator_enable_regmap,
+	.disable = regulator_disable_regmap,
+	.is_enabled = regulator_is_enabled_regmap,
+	.list_voltage = regulator_list_voltage_table,
+	.map_voltage = regulator_map_voltage_ascend,
+	.set_voltage_sel = regulator_set_voltage_sel_regmap,
+	.get_voltage_sel = regulator_get_voltage_sel_regmap,
+	.set_current_limit = bd7181x_led_set_current_limit,
+	.get_current_limit = bd7181x_led_get_current_limit,
+};
+
+#define BD7181X_FIXED_REG(_name, ereg, emsk, voltage)	\
+	[BD7181X_ ## _name] = {	\
+		.desc = {	\
+			.name = #_name,	\
+			.n_voltages = 1,	\
+			.ops = &bd7181x_fixed_regulator_ops,	\
+			.type = REGULATOR_VOLTAGE,	\
+			.id = BD7181X_ ## _name,	\
+			.owner = THIS_MODULE,	\
+			.min_uV = (voltage),	\
+			.enable_reg = (ereg),	\
+			.enable_mask = (emsk),	\
+		},	\
+	}
+
+#define BD7181X_BUCK_REG(_name, base, ereg, min, max, step)	\
+	[BD7181X_ ## _name] = {	\
+		.desc = {	\
+			.name = #_name,\
+			.n_voltages = ((max) - (min)) / (step) + 1,	\
+			.ops = &bd7181x_buck_regulator_ops,	\
+			.type = REGULATOR_VOLTAGE,	\
+			.id = BD7181X_ ## _name,	\
+			.owner = THIS_MODULE,	\
+			.min_uV = (min),	\
+			.uV_step = (step),	\
+			.vsel_reg = (base) + BD7181X_VOL_OFFSET,	\
+			.vsel_mask = 0x3f,	\
+			.enable_reg = (ereg),	\
+			.enable_mask = 0x04,	\
+		},	\
+		.stby_reg = (base) + BD7181X_STANDBY_OFFSET,	\
+		.stby_mask = 0x3f,	\
+	}
+
+#define BD7181X_LED_REG(_name, base, mask, ereg, emsk, voltages)	\
+	[BD7181X_ ## _name] = {	\
+		.desc = {	\
+			.name = #_name,	\
+			.n_voltages = ARRAY_SIZE(voltages),	\
+			.ops = &bd7181x_led_regulator_ops,	\
+			.type = REGULATOR_CURRENT,	\
+			.id = BD7181X_ ## _name,	\
+			.owner = THIS_MODULE,	\
+			.volt_table = voltages,	\
+			.vsel_reg = (base),	\
+			.vsel_mask = (mask),	\
+			.enable_reg = (ereg),	\
+			.enable_mask = (emsk),	\
+		},	\
+	}
+
+#define BD7181X_LDO_REG(_name, base, ereg, emsk, min, max, step)	\
+	[BD7181X_ ## _name] = {	\
+		.desc = {	\
+			.name = #_name,	\
+			.n_voltages = ((max) - (min)) / (step) + 1,	\
+			.ops = &bd7181x_ldo_regulator_ops,	\
+			.type = REGULATOR_VOLTAGE,	\
+			.id = BD7181X_ ## _name,	\
+			.owner = THIS_MODULE,	\
+			.min_uV = (min),	\
+			.uV_step = (step),	\
+			.vsel_reg = (base),	\
+			.vsel_mask = 0x3f,	\
+			.enable_reg = (ereg),	\
+			.enable_mask = (emsk),	\
+		},	\
+		.stby_reg = (base),	\
+		.stby_mask = 0x20,	\
+	}
+
+static struct bd7181x_regulator bd7181x_regulators[] = {
+	BD7181X_BUCK_REG(BUCK1, BD7181X_REG_BUCK1_VOLT_H, BD7181X_REG_BUCK1_MODE, 800000, 2000000, 25000),
+	BD7181X_BUCK_REG(BUCK2, BD7181X_REG_BUCK2_VOLT_H, BD7181X_REG_BUCK2_MODE, 800000, 2000000, 25000),
+	BD7181X_BUCK_REG(BUCK3, BD7181X_REG_BUCK3_VOLT, BD7181X_REG_BUCK3_MODE,  1200000, 2700000, 50000),
+	BD7181X_BUCK_REG(BUCK4, BD7181X_REG_BUCK4_VOLT, BD7181X_REG_BUCK4_MODE,  1100000, 1850000, 25000),
+	BD7181X_BUCK_REG(BUCK5, BD7181X_REG_BUCK5_VOLT, BD7181X_REG_BUCK5_MODE,  1800000, 3300000, 50000),
+	BD7181X_LDO_REG(LDO1, BD7181X_REG_LDO1_VOLT, BD7181X_REG_LDO_MODE1, 0x40, 800000, 3300000, 50000),
+	BD7181X_LDO_REG(LDO2, BD7181X_REG_LDO2_VOLT, BD7181X_REG_LDO_MODE2, 0x04, 800000, 3300000, 50000),
+	BD7181X_LDO_REG(LDO3, BD7181X_REG_LDO3_VOLT, BD7181X_REG_LDO_MODE2, 0x40, 800000, 3300000, 50000),
+	BD7181X_LDO_REG(LDO4, BD7181X_REG_LDO4_VOLT, BD7181X_REG_LDO_MODE3, 0x04, 800000, 3300000, 50000),
+	BD7181X_LDO_REG(LDO5, BD7181X_REG_LDO5_VOLT_H,BD7181X_REG_LDO_MODE3,0x40, 800000, 3300000, 50000),
+	BD7181X_FIXED_REG(LDODVREF, BD7181X_REG_LDO_MODE4, 0x40, 3000000),
+	BD7181X_FIXED_REG(LDOLPSR, BD7181X_REG_LDO_MODE4,  0x04, 1800000),
+	BD7181X_LED_REG(WLED, BD7181X_REG_LED_DIMM, 0x3F, BD7181X_REG_LED_CTRL, 0x04, bd7181x_wled_currents),
+};
+
+#ifdef CONFIG_OF
+
+static struct of_regulator_match bd7181x_matches[] = {
+	{ .name = "buck1",	},
+	{ .name = "buck2",	},
+	{ .name = "buck3",	},
+	{ .name = "buck4",	},
+	{ .name = "buck5",	},
+	{ .name = "ldo1",	},
+	{ .name = "ldo2",	},
+	{ .name = "ldo3",	},
+	{ .name = "ldo4",	},
+	{ .name = "ldo5",	},
+	{ .name = "dvref",	},
+	{ .name = "lpsr",	},
+	{ .name = "wled",	},
+};
+
+/**@brief parse bd7181x regulator device tree
+ * @param pdev platform device of bd7181x regulator
+ * @param bd7181x_reg_matches return regualtor matches
+ * @retval 0 parse success
+ * @retval NULL parse fail
+ */
+static int bd7181x_parse_dt_reg_data(
+		struct platform_device *pdev,
+		struct of_regulator_match **reg_matches)
+{
+	// struct bd7181x *bd7181x = dev_get_drvdata(pdev->dev.parent);
+	struct device_node *np, *regulators;
+	struct of_regulator_match *matches;
+	int ret, count;
+
+	np = of_node_get(pdev->dev.parent->of_node);
+	regulators = of_find_node_by_name(np, "regulators");
+	if (!regulators) {
+		dev_err(&pdev->dev, "regulator node not found\n");
+		return -EINVAL;
+	}
+
+	count = ARRAY_SIZE(bd7181x_matches);
+	matches = bd7181x_matches;
+
+	ret = of_regulator_match(&pdev->dev, regulators, matches, count);
+	of_node_put(regulators);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Error parsing regulator init data: %d\n",
+			ret);
+		return ret;
+	}
+
+	*reg_matches = matches;
+
+	return 0;
+}
+#else
+static inline int bd7181x_parse_dt_reg_data(
+			struct platform_device *pdev,
+			struct of_regulator_match **reg_matches)
+{
+	*reg_matches = NULL;
+	return 0;
+}
+#endif
+
+/** @brief out32k mode constants */
+static const char* out32k_modes[] = {"open_drain", "cmos"};
+
+/** @brief retrive out32k output mode */
+static ssize_t show_mode(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct bd7181x_pmic *pmic = dev_get_drvdata(dev);
+	int o;
+
+	o = bd7181x_reg_read(pmic->mfd, BD7181X_REG_OUT32K);
+	o = (o & OUT32K_MODE) != 0;
+
+	return sprintf(buf, "%s\n", out32k_modes[o]);
+}
+
+/** @brief set out32k output mode */
+static ssize_t set_mode(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct bd7181x_pmic *pmic = dev_get_drvdata(dev);
+	int o, r;
+
+	if (strncmp(buf, out32k_modes[0], strlen(out32k_modes[0])) == 0) {
+		o = 0;
+	} else {
+		o = OUT32K_MODE;
+	}
+
+	r = bd7181x_update_bits(pmic->mfd, BD7181X_REG_OUT32K, OUT32K_MODE, o);
+	if (r < 0) {
+		return r;
+	}
+	return count;
+}
+
+/** @brief retrive out32k output value */
+static ssize_t show_value(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct bd7181x_pmic *pmic = dev_get_drvdata(dev);
+	int o;
+
+	o = bd7181x_reg_read(pmic->mfd, BD7181X_REG_OUT32K);
+	o = (o & OUT32K_EN) != 0;
+
+	return sprintf(buf, "%d\n", o);
+}
+
+/** @brief set o output value */
+static ssize_t set_value(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct bd7181x_pmic *pmic = dev_get_drvdata(dev);
+	int o, r;
+
+	if (sscanf(buf, "%d", &o) < 1) {
+		return -EINVAL;
+	}
+
+	if (o != 0) {
+		o = OUT32K_EN;
+	}
+	r = bd7181x_update_bits(pmic->mfd, BD7181X_REG_OUT32K, OUT32K_EN, o);
+	if (r < 0) {
+		return r;
+	}
+	return count;
+}
+
+/** @brief list all supported modes */
+static ssize_t available_modes(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int i, r;
+
+	r = 0;
+	for (i = 0; i < ARRAY_SIZE(out32k_modes) && r >= 0; i++) {
+		r += sprintf(buf + r, "%s ", out32k_modes[i]);
+	}
+	r += sprintf(buf + r, "\n");
+
+	return r;
+}
+
+/** @brief list all supported values */
+static ssize_t available_values(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "0 1 \n");
+}
+
+static DEVICE_ATTR(out32k_mode, 0666, show_mode, set_mode);
+static DEVICE_ATTR(out32k_value, 0666, show_value, set_value);
+static DEVICE_ATTR(available_mode, 0444, available_modes, NULL);
+static DEVICE_ATTR(available_value, 0444, available_values, NULL);
+
+/** @brief device sysfs attribute table, about o */
+static struct attribute *gpo_attributes[] = {
+	&dev_attr_out32k_mode.attr,
+	&dev_attr_out32k_value.attr,
+	&dev_attr_available_mode.attr,
+	&dev_attr_available_value.attr,
+	NULL
+};
+
+static const struct attribute_group gpo_attr_group = {
+	.attrs	= gpo_attributes,
+};
+
+
+/**@brief probe bd7181x regulator device
+ @param pdev bd7181x regulator platform device
+ @retval 0 success
+ @retval negative fail
+*/
+static int bd7181x_probe(struct platform_device *pdev)
+{
+	struct bd7181x_pmic *pmic;
+	struct bd7181x_board *pdata;
+	struct regulator_config config = {};
+	struct bd7181x *bd7181x = dev_get_drvdata(pdev->dev.parent);
+	struct of_regulator_match *matches = NULL;
+	int i, err;
+
+	pmic = kzalloc(sizeof(*pmic), GFP_KERNEL);
+	if (!pmic) {
+		dev_err(&pdev->dev, "Memory allocation failed for pmic\n");
+		return -ENOMEM;
+	}
+
+	memcpy(pmic->descs, bd7181x_regulators,	sizeof(pmic->descs));
+
+	pmic->dev = &pdev->dev;
+	pmic->mfd = bd7181x;
+	platform_set_drvdata(pdev, pmic);
+
+	bd7181x_clear_bits(pmic->mfd, BD7181X_REG_PWRCTRL, RESTARTEN); // Disable to go to ship-mode
+	bd7181x_clear_bits(pmic->mfd, BD7181X_REG_GPO, RESTARTEN); // Turn OFF the green LED
+	bd7181x_set_bits(pmic->mfd, BD7181X_REG_CHG_SET1, CHG_EN); // Enable charger
+
+	pdata = dev_get_platdata(bd7181x->dev);
+	if (!pdata && bd7181x->dev->of_node) {
+		bd7181x_parse_dt_reg_data(pdev,	&matches);
+		if (matches == NULL) {
+			dev_err(&pdev->dev, "Platform data not found\n");
+			return -EINVAL;
+		}
+	}
+
+	for (i = 0; i < BD7181X_REGULATOR_CNT; i++) {
+		struct regulator_init_data *init_data;
+		struct regulator_desc *desc;
+		struct regulator_dev *rdev;
+
+		desc = &pmic->descs[i].desc;
+		desc->name = bd7181x_matches[i].name;
+		
+		if (pdata) {
+			init_data = pdata->init_data[i];
+		} else {
+			init_data = matches[i].init_data;
+		}
+
+		config.dev = pmic->dev;
+		config.init_data = init_data;
+		config.driver_data = pmic;
+		config.regmap = bd7181x->regmap;
+		config.of_node = matches[i].of_node;
+
+		rdev = regulator_register(desc, &config);
+		if (IS_ERR(rdev)) {
+			dev_err(bd7181x->dev,
+				"failed to register %s regulator\n",
+				desc->name);
+			err = PTR_ERR(rdev);
+			goto err;
+		}
+		pmic->rdev[i] = rdev;
+	}
+
+	err = sysfs_create_group(&pdev->dev.kobj, &gpo_attr_group);
+	if (err != 0) {
+		dev_err(&pdev->dev, "Failed to create attribute group: %d\n", err);
+		goto err;
+	}
+
+	return 0;
+
+err:
+	while (--i >= 0)
+		regulator_unregister(pmic->rdev[i]);
+
+	kfree(pmic);
+	return err;
+}
+
+/**@brief remove bd7181x regulator device
+ @param pdev bd7181x regulator platform device
+ @return 0
+*/
+static int __exit bd7181x_remove(struct platform_device *pdev)
+{
+	struct bd7181x_pmic *pmic = platform_get_drvdata(pdev);
+	int i;
+
+	sysfs_remove_group(&pdev->dev.kobj, &gpo_attr_group);
+
+	for (i = 0; i < BD7181X_REGULATOR_CNT; i++)
+		regulator_unregister(pmic->rdev[i]);
+
+	kfree(pmic);
+	return 0;
+}
+
+static struct platform_driver bd7181x_driver = {
+	.driver = {
+		.name = "bd7181x-pmic",
+		.owner = THIS_MODULE,
+	},
+	.probe = bd7181x_probe,
+	.remove = bd7181x_remove,
+};
+
+/**@brief module initialize function */
+static int __init bd7181x_init(void)
+{
+	return platform_driver_register(&bd7181x_driver);
+}
+subsys_initcall(bd7181x_init);
+
+/**@brief module deinitialize function */
+static void __exit bd7181x_cleanup(void)
+{
+	platform_driver_unregister(&bd7181x_driver);
+}
+module_exit(bd7181x_cleanup);
+
+MODULE_AUTHOR("Tony Luo <luofc@embedinfo.com>");
+MODULE_DESCRIPTION("BD71815/BD71817 voltage regulator driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:bd7181x-pmic");
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index db933de..7cf924b 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -539,6 +539,15 @@ config RTC_DRV_S5M
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-s5m.
 
+config RTC_DRV_BD7181X
+	tristate "BD71815/BD71817 RTC"
+	depends on RTC_CLASS && MFD_BD7181X
+	help
+	  If you say yes here you get support for the RTC on the
+          RoHM BD71815/BD71817 chips.
+
+          This driver can also be built as a module.
+
 endif # I2C
 
 comment "SPI RTC drivers"
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index b427bf7..48779e9 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -105,6 +105,7 @@ obj-$(CONFIG_RTC_DRV_RS5C313)	+= rtc-rs5c313.o
 obj-$(CONFIG_RTC_DRV_RS5C348)	+= rtc-rs5c348.o
 obj-$(CONFIG_RTC_DRV_RS5C372)	+= rtc-rs5c372.o
 obj-$(CONFIG_RTC_DRV_RV3029C2)	+= rtc-rv3029c2.o
+obj-$(CONFIG_RTC_DRV_BD7181X)	+= rtc-bd7181x.o
 obj-$(CONFIG_RTC_DRV_RX4581)	+= rtc-rx4581.o
 obj-$(CONFIG_RTC_DRV_RX8025)	+= rtc-rx8025.o
 obj-$(CONFIG_RTC_DRV_RX8581)	+= rtc-rx8581.o
diff --git a/drivers/rtc/rtc-bd7181x.c b/drivers/rtc/rtc-bd7181x.c
new file mode 100644
index 0000000..2f15517
--- /dev/null
+++ b/drivers/rtc/rtc-bd7181x.c
@@ -0,0 +1,417 @@
+/*
+ * @file RoHM BD71815/BD71817 Real Time Clock interface
+ *
+ * Copyright (C) 2014 Embest Technology Co. Ltd. Inc.
+ *
+ * @author Peter Yang <yanglsh@embest-tech.com>
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/rtc.h>
+#include <linux/bcd.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/of.h>
+#include <linux/mfd/bd7181x.h>
+
+/** @brief bd7181x rtc struct */
+struct bd7181x_rtc {
+	struct rtc_device	*rtc;		/**< system rtc device */
+	int irq;				/**< rtc irq */
+};
+
+/* @brief Total number of RTC registers needed to set time*/
+// #define NUM_TIME_REGS	(BD7181X_REG_YEAR - BD7181X_REG_SEC + 1)
+
+/**@brief enable or disable rtc alarm irq
+ * @param dev rtc device of system
+ * @param enabled enable if non-zero
+ * @retval 0 success
+ * @retval negative error number
+ */
+static int bd7181x_rtc_alarm_irq_enable(struct device *dev, unsigned enabled)
+{
+	struct bd7181x *mfd = dev_get_drvdata(dev->parent);
+	u8 val = 0;
+
+	if (enabled)
+		val = ALM0;
+
+	return regmap_write(mfd->regmap, BD7181X_REG_INT_EN_12, val);
+}
+
+/**@brief bd7181x rtc time convert to linux time
+ * @param tm linux rtc time
+ * @param hw_rtc bd7181x rtc time
+ * @return argument tm
+ */
+static struct rtc_time* hw_to_rtc_time(struct rtc_time* tm, const struct bd7181x_rtc_alarm* hw_rtc) {
+	u8 hour;
+
+	tm->tm_sec = bcd2bin(hw_rtc->sec);
+	tm->tm_min = bcd2bin(hw_rtc->min);
+	hour = hw_rtc->hour & ~HOUR_24HOUR;
+	tm->tm_hour = bcd2bin(hour);
+	tm->tm_mday = bcd2bin(hw_rtc->day);
+	tm->tm_mon = bcd2bin(hw_rtc->month) - 1;
+	tm->tm_year = bcd2bin(hw_rtc->year) + 100;
+	return tm;
+}
+
+/**@brief linux time convert bd7181x rtc time
+ * @param hw_rtc bd7181x rtc time
+ * @param tm linux rtc time
+ * @return argument hw_rtc
+ */
+static struct bd7181x_rtc_alarm* rtc_time_to_hw(struct bd7181x_rtc_alarm* hw_rtc, const struct rtc_time* tm) {
+	hw_rtc->sec = bin2bcd(tm->tm_sec);
+	hw_rtc->min = bin2bcd(tm->tm_min);
+	hw_rtc->hour = HOUR_24HOUR | bin2bcd(tm->tm_hour);
+	hw_rtc->day = bin2bcd(tm->tm_mday);
+	hw_rtc->month = bin2bcd(tm->tm_mon + 1);
+	hw_rtc->year = bin2bcd(tm->tm_year - 100);
+
+	return hw_rtc;
+}
+
+/*
+ * Gets current bd7181x RTC time and date parameters.
+ *
+ * The RTC's time/alarm representation is not what gmtime(3) requires
+ * Linux to use:
+ *
+ *  - Months are 1..12 vs Linux 0-11
+ *  - Years are 0..99 vs Linux 1900..N (we assume 21st century)
+ */
+/**@brief read date/time from bd7181x rtc
+ * @param dev rtc device of system
+ * @param tm date/time store target
+ * @retval 0 success
+ * @retval negative error number
+ */
+static int bd7181x_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	struct bd7181x_rtc_alarm rtc_data[1];
+	struct bd7181x *mfd = dev_get_drvdata(dev->parent);
+	int ret;
+
+	ret = regmap_bulk_read(mfd->regmap, BD7181X_REG_SEC, rtc_data, sizeof rtc_data);
+	if (ret < 0) {
+		dev_err(dev, "reading from RTC failed with err:%d\n", ret);
+		return ret;
+	}
+
+	hw_to_rtc_time(tm, rtc_data);
+
+	return ret;
+}
+
+/**@brief write date/time to bd7181x rtc
+ * @param dev rtc device of system
+ * @param tm date/time source
+ * @retval 0 success
+ * @retval negative error number
+ */
+static int bd7181x_rtc_set_time(struct device *dev, struct rtc_time *tm)
+{
+	struct bd7181x_rtc_alarm rtc_data[1];
+	struct bd7181x *mfd = dev_get_drvdata(dev->parent);
+	int ret;
+
+	rtc_time_to_hw(rtc_data, tm);
+
+	/* update all the time registers in one shot */
+	ret = regmap_bulk_write(mfd->regmap, BD7181X_REG_SEC, rtc_data, sizeof rtc_data);
+	if (ret < 0) {
+		dev_err(dev, "rtc_set_time error %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+/**@brief Gets current bd7181x RTC alarm time.
+ * @param dev rtc device of system
+ * @param alm alarm date/time store target
+ * @retval 0 success
+ * @retval negative error number
+ */
+static int bd7181x_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)
+{
+	struct bd7181x_rtc_alarm rtc_data[1];
+	u32 int_val;
+	struct bd7181x *mfd = dev_get_drvdata(dev->parent);
+	int ret;
+
+	ret = regmap_bulk_read(mfd->regmap, BD7181X_REG_ALM0_SEC, rtc_data, sizeof rtc_data);
+	if (ret < 0) {
+		dev_err(dev, "rtc_read_alarm error %d\n", ret);
+		return ret;
+	}
+	
+	hw_to_rtc_time(&alm->time, rtc_data);
+
+	ret = regmap_read(mfd->regmap, BD7181X_REG_INT_EN_12, &int_val);
+	if (ret < 0)
+		return ret;
+
+	if (int_val & ALM0)
+		alm->enabled = 1;
+
+	return ret;
+}
+
+/**@brief Set current bd7181x RTC alarm time
+ * @param dev rtc device of system
+ * @param alm alarm date/time to set
+ * @retval 0 success
+ * @retval negative error number
+ */
+static int bd7181x_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)
+{
+	struct bd7181x_rtc_alarm rtc_data[1];
+	struct bd7181x *mfd = dev_get_drvdata(dev->parent);
+	int ret;
+
+	// printk("%s() L%d\n", __func__, __LINE__);
+
+	ret = bd7181x_rtc_alarm_irq_enable(dev, 0);
+	if (ret)
+		return ret;
+
+	rtc_time_to_hw(rtc_data, &alm->time);
+
+	/* update all the alarm registers in one shot */
+	ret = regmap_bulk_write(mfd->regmap, BD7181X_REG_ALM0_SEC, rtc_data, sizeof rtc_data);
+	if (ret) {
+		dev_err(dev, "rtc_set_alarm error %d\n", ret);
+		return ret;
+	}
+
+	if (alm->enabled)
+		ret = bd7181x_rtc_alarm_irq_enable(dev, 1);
+
+	return ret;
+}
+
+/**@brief bd7181x rtc alarm interrupt
+ * @param irq system irq
+ * @param rtc rtc device of system
+ * @retval IRQ_HANDLED success
+ * @retval IRQ_NONE error
+ */
+static irqreturn_t bd7181x_rtc_interrupt(int irq, void *rtc)
+{
+	struct device *dev = rtc;
+	unsigned long events = 0;
+	struct bd7181x *mfd = dev_get_drvdata(dev->parent);
+	struct bd7181x_rtc *bd_rtc = dev_get_drvdata(dev);
+	int ret;
+	u32 rtc_reg;
+
+	printk("bd7181x_vbat_interrupt() in.\n");
+
+	ret = regmap_read(mfd->regmap, BD7181X_REG_INT_STAT_12, &rtc_reg);
+	if (ret)
+		return IRQ_NONE;
+
+	printk("BD7181X_REG_INT_STAT_12=0x%x\n", rtc_reg);
+
+	if (rtc_reg & ALM0)
+		events = RTC_IRQF | RTC_AF;
+
+	ret = regmap_write(mfd->regmap, BD7181X_REG_INT_STAT_12, rtc_reg);
+	if (ret)
+		return IRQ_NONE;
+
+	printk("\n~~~IRQ ALARM.\n");
+
+	/* Notify RTC core on event */
+	rtc_update_irq(bd_rtc->rtc, 1, events);
+
+	return IRQ_HANDLED;
+}
+
+/** @brief function operations definition */
+static struct rtc_class_ops bd7181x_rtc_ops = {
+	.read_time	= bd7181x_rtc_read_time,
+	.set_time	= bd7181x_rtc_set_time,
+	.read_alarm	= bd7181x_rtc_read_alarm,
+	.set_alarm	= bd7181x_rtc_set_alarm,
+	.alarm_irq_enable = bd7181x_rtc_alarm_irq_enable,
+};
+
+/**@brief probe bd7181x rtc device
+ @param pdev bd7181x rtc platform device
+ @retval 0 success
+ @retval negative fail
+*/
+static int bd7181x_rtc_probe(struct platform_device *pdev)
+{
+	struct bd7181x *bd7181x = NULL;
+	struct bd7181x_rtc *bd_rtc = NULL;
+	int ret;
+	int irq;
+	u32 rtc_reg;
+
+	bd7181x = dev_get_drvdata(pdev->dev.parent);
+
+	bd_rtc = devm_kzalloc(&pdev->dev, sizeof(struct bd7181x_rtc),
+			GFP_KERNEL);
+	if (!bd_rtc)
+		return -ENOMEM;
+
+	/* Clear pending interrupts */
+	ret = regmap_read(bd7181x->regmap, BD7181X_REG_INT_STAT_12, &rtc_reg);
+	if (ret < 0)
+		return ret;
+
+	ret = regmap_write(bd7181x->regmap, BD7181X_REG_INT_STAT_12, rtc_reg);
+	if (ret < 0)
+		return ret;
+
+	dev_dbg(&pdev->dev, "Enabling rtc-bd7181x.\n");
+
+	#if 0
+	/* Enable RTC alarm interrupt */
+	ret = regmap_update_bits(bd7181x->regmap, BD7181X_REG_INT_EN_00, ALMALE, ALMALE);
+	if (ret < 0)
+		return ret;
+	#endif
+	/* Disable ALM0 mask */
+	ret = regmap_write(bd7181x->regmap, BD7181X_REG_ALM0_MASK, 0);
+	if (ret < 0)
+		return ret;
+
+	irq  = platform_get_irq(pdev, 0);
+	if (irq <= 0) {
+		dev_warn(&pdev->dev, "Wake up is not possible as irq = %d\n", irq);
+		return -ENXIO;
+	}
+
+	ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
+		bd7181x_rtc_interrupt, IRQF_TRIGGER_LOW | IRQF_EARLY_RESUME,
+		dev_name(&pdev->dev), &pdev->dev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "IRQ is not free.\n");
+		return ret;
+	}
+	bd_rtc->irq = irq;
+	device_set_wakeup_capable(&pdev->dev, 1);
+
+	bd_rtc->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
+		&bd7181x_rtc_ops, THIS_MODULE);
+	if (IS_ERR(bd_rtc->rtc)) {
+		ret = PTR_ERR(bd_rtc->rtc);
+		dev_err(&pdev->dev, "RTC device register: err %d\n", ret);
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, bd_rtc);
+
+	return 0;
+}
+
+/*
+ * Disable bd7181x RTC interrupts.
+ * Sets status flag to free.
+ */
+/**@brief remove bd7181x rtc device
+ @param pdev bd7181x rtc platform device
+ @return 0
+*/
+static int bd7181x_rtc_remove(struct platform_device *pdev)
+{
+	bd7181x_rtc_alarm_irq_enable(&pdev->dev, 0);
+
+	return 0;
+}
+
+/**@brief shutdown bd7181x rtc device
+ @param pdev bd7181x rtc platform device
+ @return void
+*/
+static void bd7181x_rtc_shutdown(struct platform_device *pdev)
+{
+	/* mask timer interrupts, but leave alarm interrupts on to enable
+	   power-on when alarm is triggered */
+	bd7181x_rtc_alarm_irq_enable(&pdev->dev, 0);
+}
+
+#ifdef CONFIG_PM_SLEEP
+/**@brief suspend bd7181x rtc device
+ * @param dev rtc device of system
+ * @retval 0
+ */
+static int bd7181x_rtc_suspend(struct device *dev)
+{
+	struct bd7181x_rtc *bd_rtc = dev_get_drvdata(dev);
+
+	if (device_may_wakeup(dev))
+		enable_irq_wake(bd_rtc->irq);
+	return 0;
+}
+
+/**@brief resume bd7181x rtc device
+ * @param dev rtc device of system
+ * @retval 0
+ */
+static int bd7181x_rtc_resume(struct device *dev)
+{
+	struct bd7181x_rtc *bd_rtc = dev_get_drvdata(dev);
+
+	if (device_may_wakeup(dev))
+		disable_irq_wake(bd_rtc->irq);
+	return 0;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(bd7181x_rtc_pm_ops, bd7181x_rtc_suspend, bd7181x_rtc_resume);
+
+#ifdef CONFIG_OF
+static const struct of_device_id bd7181x_rtc_of_match[] = {
+	{.compatible = "ti,bd7181x-rtc", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, bd7181x_rtc_of_match);
+#endif
+
+static struct platform_driver bd7181xrtc_driver = {
+	.probe		= bd7181x_rtc_probe,
+	.remove		= bd7181x_rtc_remove,
+	.shutdown	= bd7181x_rtc_shutdown,
+	.driver		= {
+		.owner		= THIS_MODULE,
+		.name		= "bd7181x-rtc",
+		.pm		= &bd7181x_rtc_pm_ops,
+		.of_match_table = of_match_ptr(bd7181x_rtc_of_match),
+	},
+};
+
+/**@brief module initialize function */
+static int __init bd7181x_rtc_init(void)
+{
+	return platform_driver_register(&bd7181xrtc_driver);
+}
+module_init(bd7181x_rtc_init);
+
+/**@brief module deinitialize function */
+static void __exit bd7181x_rtc_exit(void)
+{
+	platform_driver_unregister(&bd7181xrtc_driver);
+}
+module_exit(bd7181x_rtc_exit);
+
+MODULE_AUTHOR("Peter Yang <yanglsh@embest-tech.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:bd7181x-rtc");
diff --git a/drivers/video/mxc/mxc_ipuv3_fb.c b/drivers/video/mxc/mxc_ipuv3_fb.c
index eb9b2f2..17cae63 100644
--- a/drivers/video/mxc/mxc_ipuv3_fb.c
+++ b/drivers/video/mxc/mxc_ipuv3_fb.c
@@ -45,6 +45,7 @@
 #include <linux/module.h>
 #include <linux/mxcfb.h>
 #include <linux/of_device.h>
+#include <linux/of_gpio.h>
 #include <linux/platform_device.h>
 #include <linux/sched.h>
 #include <linux/slab.h>
@@ -54,6 +55,7 @@
 
 #include "mxc_dispdrv.h"
 
+
 /*
  * Driver name
  */
@@ -2329,6 +2331,7 @@ static int mxcfb_blank(int blank, struct fb_info *info)
 	}
 	if (!ret)
 		mxc_fbi->cur_blank = blank;
+
 	return ret;
 }
 
@@ -3413,6 +3416,36 @@ static int mxcfb_get_of_property(struct platform_device *pdev,
 		return -ENOENT;
 	}
 
+	if (of_find_property(np, "dispctrl-gpios", NULL)) {
+		enum of_gpio_flags flags;
+		int gpio;
+		int index = 0;
+		for (;; index++) {
+			gpio = of_get_named_gpio_flags(np, "dispctrl-gpios", index, &flags);
+			if (gpio < 0)
+				break; /* End of the phandle list */
+
+			if (!gpio_is_valid(gpio)) {
+				return -EINVAL;
+			}
+
+			err = devm_gpio_request_one(&pdev->dev, gpio, GPIOF_OUT_INIT_LOW, NULL);
+			if (err < 0) {
+				dev_dbg(&pdev->dev, "could not allocate gpio\n");
+				return err;
+			}
+
+			if (!(flags & OF_GPIO_ACTIVE_LOW)) {
+				if (gpio_cansleep(gpio))
+					gpio_set_value_cansleep(gpio, 1);
+				else
+					gpio_set_value(gpio, 1);
+			}
+
+			devm_gpio_free(&pdev->dev, gpio);
+		}
+	}
+
 	len = min(sizeof(plat_data->disp_dev) - 1, strlen(disp_dev));
 	memcpy(plat_data->disp_dev, disp_dev, len);
 	plat_data->disp_dev[len] = '\0';
diff --git a/drivers/video/mxc/mxc_lcdif.c b/drivers/video/mxc/mxc_lcdif.c
index d635edd..7b0b066 100644
--- a/drivers/video/mxc/mxc_lcdif.c
+++ b/drivers/video/mxc/mxc_lcdif.c
@@ -19,6 +19,9 @@
 #include <linux/of_device.h>
 #include <linux/pinctrl/consumer.h>
 #include <linux/platform_device.h>
+#include <video/of_display_timing.h>
+#include <video/of_videomode.h>
+#include <video/videomode.h>
 
 #include "mxc_dispdrv.h"
 
@@ -48,6 +51,18 @@ static struct fb_videomode lcdif_modedb[] = {
 	FB_SYNC_CLK_LAT_FALL,
 	FB_VMODE_NONINTERLACED,
 	0,},
+	{
+	/* 800x480 @ 49 Hz , pixel clk @ 33.5MHz */
+	"EA7-WVGA", 49, 800, 480, 33500, 89, 164, 75, 75, 10, 10,
+	FB_SYNC_CLK_LAT_FALL,
+	FB_VMODE_NONINTERLACED,
+	0,},
+	{
+	/* Special placeholder, will be filled in by content in device tree */
+	"eadisp_special", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	FB_SYNC_CLK_LAT_FALL,
+	FB_VMODE_NONINTERLACED,
+	0,},
 };
 static int lcdif_modedb_sz = ARRAY_SIZE(lcdif_modedb);
 
@@ -102,10 +117,11 @@ static struct mxc_dispdrv_driver lcdif_drv = {
 static int lcd_get_of_property(struct platform_device *pdev,
 				struct mxc_lcd_platform_data *plat_data)
 {
-	struct device_node *np = pdev->dev.of_node;
+	struct device_node *np = pdev->dev.of_node, *child;
 	int err;
 	u32 ipu_id, disp_id;
 	const char *default_ifmt;
+	int i;
 
 	err = of_property_read_string(np, "default_ifmt", &default_ifmt);
 	if (err) {
@@ -152,6 +168,33 @@ static int lcd_get_of_property(struct platform_device *pdev,
 		return -ENOENT;
 	}
 
+	for (i = 0; i < lcdif_modedb_sz; i++) {
+		if (strcmp(lcdif_modedb[i].name, "eadisp_special")==0) {
+			struct videomode vm;
+
+			/* Read customized display information, should only be one display node but iterate anyway */
+			for_each_child_of_node(np, child) {
+				err = of_get_videomode(child, &vm, OF_USE_NATIVE_MODE);
+				if (err) {
+					return -EINVAL;
+				}
+				err = fb_videomode_from_videomode(&vm, &lcdif_modedb[i]);
+				if (err < 0) {
+					return -EINVAL;
+				}
+
+				if (!(vm.flags & DISPLAY_FLAGS_DE_HIGH)) {
+					lcdif_modedb[i].sync |= FB_SYNC_OE_LOW_ACT;
+				}
+				if (vm.flags & DISPLAY_FLAGS_PIXDATA_NEGEDGE) {
+					lcdif_modedb[i].sync |= FB_SYNC_CLK_LAT_FALL;
+				}
+				break;
+			}
+			break;
+		}
+	}
+
 	return err;
 }
 
diff --git a/include/linux/mfd/bd7181x.h b/include/linux/mfd/bd7181x.h
new file mode 100644
index 0000000..ab1b45e
--- /dev/null
+++ b/include/linux/mfd/bd7181x.h
@@ -0,0 +1,562 @@
+/**
+ * @file bd7181x.h  ROHM BD71815GW/BD71817GW header file
+ *
+ * Copyright 2014 Embest Technology Co. Ltd. Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under  the terms of the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ * @author yanglsh@embest-tech.com
+ */
+
+#ifndef __LINUX_MFD_BD7181X_H
+#define __LINUX_MFD_BD7181X_H
+
+#include <linux/regmap.h>
+
+// LDO5VSEL_EQ_H
+// define to 1 when LDO5VSEL connect to High
+// define to 0 when LDO5VSEL connect to Low
+#define LDO5VSEL_EQ_H		1
+
+#ifndef LDO5VSEL_EQ_H
+	#error define LDO5VSEL_EQ_H to 1 when connect to High, to 0 when connect to Low
+#else
+	#if LDO5VSEL_EQ_H == 1
+		#define BD7181X_REG_LDO5_VOLT BD7181X_REG_LDO5_VOLT_H
+	#elif LDO5VSEL_EQ_H == 0
+		#define BD7181X_REG_LDO5_VOLT BD7181X_REG_LDO5_VOLT_L
+	#else
+		#error  Define LDO5VSEL_EQ_H only to 0 or 1
+	#endif
+#endif
+
+enum {
+	BD7181X_BUCK1	=	0,
+	BD7181X_BUCK2,
+	BD7181X_BUCK3,
+	BD7181X_BUCK4,
+	BD7181X_BUCK5,
+	// General Purpose
+	BD7181X_LDO1,
+	BD7181X_LDO2,
+	BD7181X_LDO3,
+	// LDOs for SD Card and SD Card Interface
+	BD7181X_LDO4,
+	BD7181X_LDO5,
+	// LDO for DDR Reference Voltage
+	BD7181X_LDODVREF,
+	// LDO for Secure Non-Volatile Storage
+	// BD7181X_LDOSNVS,
+	// LDO for Low-Power State Retention
+	BD7181X_LDOLPSR,
+	BD7181X_WLED,
+	BD7181X_REGULATOR_CNT,
+};
+
+#define BD7181X_SUPPLY_STATE_ENABLED    0x1
+
+enum {
+	BD7181X_REG_DEVICE		=	0,
+	BD7181X_REG_PWRCTRL,
+	BD7181X_REG_BUCK1_MODE,
+	BD7181X_REG_BUCK2_MODE,
+	BD7181X_REG_BUCK3_MODE,
+	BD7181X_REG_BUCK4_MODE,
+	BD7181X_REG_BUCK5_MODE,
+	BD7181X_REG_BUCK1_VOLT_H,
+	// 0x08
+	BD7181X_REG_BUCK1_VOLT_L,
+	BD7181X_REG_BUCK2_VOLT_H,
+	BD7181X_REG_BUCK2_VOLT_L,
+	BD7181X_REG_BUCK3_VOLT,
+	BD7181X_REG_BUCK4_VOLT,
+	BD7181X_REG_BUCK5_VOLT,
+	BD7181X_REG_LED_CTRL,
+	BD7181X_REG_LED_DIMM,
+	// 0x10
+	BD7181X_REG_LDO_MODE1,
+	BD7181X_REG_LDO_MODE2,
+	BD7181X_REG_LDO_MODE3,
+	BD7181X_REG_LDO_MODE4,
+	BD7181X_REG_LDO1_VOLT,
+	BD7181X_REG_LDO2_VOLT,
+	BD7181X_REG_LDO3_VOLT,
+	BD7181X_REG_LDO4_VOLT,
+	// 0x18
+	BD7181X_REG_LDO5_VOLT_H,
+	BD7181X_REG_LDO5_VOLT_L,
+	BD7181X_REG_BUCK_PD_DIS,
+	BD7181X_REG_LDO_PD_DIS,
+	BD7181X_REG_GPO,
+	BD7181X_REG_OUT32K,
+	BD7181X_REG_SEC,
+	BD7181X_REG_MIN,
+	// 0x20
+	BD7181X_REG_HOUR,
+	BD7181X_REG_WEEK,
+	BD7181X_REG_DAY,
+	BD7181X_REG_MONTH,
+	BD7181X_REG_YEAR,
+	BD7181X_REG_ALM0_SEC,
+
+	// 0x2C
+	BD7181X_REG_ALM1_SEC		=	0x2C,
+
+	// 0x33
+	BD7181X_REG_ALM0_MASK		=	0x33,
+	BD7181X_REG_ALM1_MASK,
+	BD7181X_REG_ALM2,
+	BD7181X_REG_TRIM,
+	BD7181X_REG_CONF,
+	// 0x38
+	BD7181X_REG_SYS_INIT,
+	BD7181X_REG_CHG_STATE,
+	BD7181X_REG_CHG_LAST_STATE,
+	BD7181X_REG_BAT_STAT,
+	BD7181X_REG_DCIN_STAT,
+	BD7181X_REG_VSYS_STAT,
+	BD7181X_REG_CHG_STAT,
+	BD7181X_REG_CHG_WDT_STAT,
+	// 0x40
+	BD7181X_REG_BAT_TEMP,
+	BD7181X_REG_IGNORE_0,
+	BD7181X_REG_INHIBIT_0,
+	BD7181X_REG_DCIN_CLPS,
+	BD7181X_REG_VSYS_REG,
+	BD7181X_REG_VSYS_MAX,
+	BD7181X_REG_VSYS_MIN,
+	BD7181X_REG_CHG_SET1,
+	// 0x48
+	BD7181X_REG_CHG_SET2,
+	BD7181X_REG_CHG_WDT_PRE,
+	BD7181X_REG_CHG_WDT_FST,
+	BD7181X_REG_CHG_IPRE,
+	BD7181X_REG_CHG_IFST,
+	BD7181X_REG_CHG_IFST_TERM,
+	BD7181X_REG_CHG_VPRE,
+	BD7181X_REG_CHG_VBAT_1,
+	// 0x50
+	BD7181X_REG_CHG_VBAT_2,
+	BD7181X_REG_CHG_VBAT_3,
+	BD7181X_REG_CHG_LED_1,
+	BD7181X_REG_VF_TH,
+	BD7181X_REG_BAT_SET_1,
+	BD7181X_REG_BAT_SET_2,
+	BD7181X_REG_BAT_SET_3,
+	BD7181X_REG_ALM_VBAT_TH_U,
+	// 0x58
+	BD7181X_REG_ALM_VBAT_TH_L,
+	BD7181X_REG_ALM_DCIN_TH,
+	BD7181X_REG_ALM_VSYS_TH,
+	BD7181X_REG_VM_IBAT_U,
+	BD7181X_REG_VM_IBAT_L,
+	BD7181X_REG_VM_VBAT_U,
+	BD7181X_REG_VM_VBAT_L,
+	BD7181X_REG_VM_BTMP,
+	// 0x60
+	BD7181X_REG_VM_VTH,
+	BD7181X_REG_VM_DCIN_U,
+	BD7181X_REG_VM_DCIN_L,
+	BD7181X_REG_VM_VSYS,
+	BD7181X_REG_VM_VF,
+	BD7181X_REG_VM_OCI_PRE_U,
+	BD7181X_REG_VM_OCI_PRE_L,
+	BD7181X_REG_VM_OCV_PRE_U,
+	// 0x68
+	BD7181X_REG_VM_OCV_PRE_L,
+	BD7181X_REG_VM_OCI_PST_U,
+	BD7181X_REG_VM_OCI_PST_L,
+	BD7181X_REG_VM_OCV_PST_U,
+	BD7181X_REG_VM_OCV_PST_L,
+	BD7181X_REG_VM_SA_VBAT_U,
+	BD7181X_REG_VM_SA_VBAT_L,
+	BD7181X_REG_VM_SA_IBAT_U,
+	// 0x70
+	BD7181X_REG_VM_SA_IBAT_L,
+	BD7181X_REG_CC_CTRL,
+	BD7181X_REG_CC_BATCAP1_TH_U,
+	BD7181X_REG_CC_BATCAP1_TH_L,
+	BD7181X_REG_CC_BATCAP2_TH_U,
+	BD7181X_REG_CC_BATCAP2_TH_L,
+	BD7181X_REG_CC_BATCAP3_TH_U,
+	BD7181X_REG_CC_BATCAP3_TH_L,
+	// 0x78
+	BD7181X_REG_CC_STAT,
+	BD7181X_REG_CC_CCNTD_3,
+	BD7181X_REG_CC_CCNTD_2,
+	BD7181X_REG_CC_CCNTD_1,
+	BD7181X_REG_CC_CCNTD_0,
+	BD7181X_REG_CC_CURCD_U,
+	BD7181X_REG_CC_CURCD_L,
+	BD7181X_REG_VM_OCUR_THR_1,
+	// 0x80
+	BD7181X_REG_VM_OCUR_DUR_1,
+	BD7181X_REG_VM_OCUR_THR_2,
+	BD7181X_REG_VM_OCUR_DUR_2,
+	BD7181X_REG_VM_OCUR_THR_3,
+	BD7181X_REG_VM_OCUR_DUR_3,
+	BD7181X_REG_VM_OCUR_MON,
+	BD7181X_REG_VM_BTMP_OV_THR,
+	BD7181X_REG_VM_BTMP_OV_DUR,
+	// 0x88
+	BD7181X_REG_VM_BTMP_LO_THR,
+	BD7181X_REG_VM_BTMP_LO_DUR,
+	BD7181X_REG_VM_BTMP_MON,
+	BD7181X_REG_INT_EN_01,
+	// 0x95
+	BD7181X_REG_INT_EN_11		=	0x95,
+	// 0x96
+	BD7181X_REG_INT_EN_12		=	0x96,
+	BD7181X_REG_INT_STAT,
+
+	// 0x98
+	BD7181X_REG_INT_STAT_01,
+	BD7181X_REG_INT_STAT_02,
+	BD7181X_REG_INT_STAT_03,
+	BD7181X_REG_INT_STAT_04,
+	BD7181X_REG_INT_STAT_05,
+	BD7181X_REG_INT_STAT_06,
+	BD7181X_REG_INT_STAT_07,
+	BD7181X_REG_INT_STAT_08,
+
+	// 0xA0
+	BD7181X_REG_INT_STAT_09,
+	BD7181X_REG_INT_STAT_10,
+	BD7181X_REG_INT_STAT_11,
+	BD7181X_REG_INT_STAT_12,
+	BD7181X_REG_INT_UPDATE,
+
+	// 0xC0
+	BD7181X_REG_VM_VSYS_U		=	0xC0,
+	BD7181X_REG_VM_VSYS_L,
+	BD7181X_REG_VM_SA_VSYS_U,
+	BD7181X_REG_VM_SA_VSYS_L,
+
+	// 0xD0
+	BD7181X_REG_VM_SA_IBAT_MIN_U	=	0xD0,
+	BD7181X_REG_VM_SA_IBAT_MIN_L,
+	BD7181X_REG_VM_SA_IBAT_MAX_U,
+	BD7181X_REG_VM_SA_IBAT_MAX_L,
+	BD7181X_REG_VM_SA_VBAT_MIN_U,
+	BD7181X_REG_VM_SA_VBAT_MIN_L,
+	BD7181X_REG_VM_SA_VBAT_MAX_U,
+	BD7181X_REG_VM_SA_VBAT_MAX_L,
+	BD7181X_REG_VM_SA_VSYS_MIN_U,
+	BD7181X_REG_VM_SA_VSYS_MIN_L,
+	BD7181X_REG_VM_SA_VSYS_MAX_U,
+	BD7181X_REG_VM_SA_VSYS_MAX_L,
+	BD7181X_REG_VM_SA_MINMAX_CLR,
+
+	// 0xE0
+	BD7181X_REG_REX_CCNTD_3		=	0xE0,
+	BD7181X_REG_REX_CCNTD_2,
+	BD7181X_REG_REX_CCNTD_1,
+	BD7181X_REG_REX_CCNTD_0,
+	BD7181X_REG_REX_SA_VBAT_U,
+	BD7181X_REG_REX_SA_VBAT_L,
+	BD7181X_REG_REX_CTRL_1,
+	BD7181X_REG_REX_CTRL_2,
+	BD7181X_REG_FULL_CCNTD_3,
+	BD7181X_REG_FULL_CCNTD_2,
+	BD7181X_REG_FULL_CCNTD_1,
+	BD7181X_REG_FULL_CCNTD_0,
+	BD7181X_REG_FULL_CTRL,
+
+	// 0xF0
+	BD7181X_REG_CCNTD_CHG_3		=	0xF0,
+	BD7181X_REG_CCNTD_CHG_2,
+
+	// 0xFE
+	BD7181X_REG_TEST_MODE		=	0xFE,
+	BD7181X_MAX_REGISTER,
+};
+
+/* BD7181X_REG_LDO1_CTRL bits */
+#define LDO1_EN					0x01
+#define LDO2_EN					0x02
+#define LDO3_EN					0x04
+#define DVREF_EN				0x08
+#define VOSNVS_SW_EN				0x10
+#define VOLT_MASK				0x3F
+
+/* BD7181X_REG_OUT32K bits */
+#define OUT32K_EN				0x01
+#define OUT32K_MODE				0x02
+
+/* BD7181X_REG_BAT_STAT bits */
+#define BAT_DET					0x20
+#define BAT_DET_OFFSET				5
+#define BAT_DET_DONE				0x10
+#define VBAT_OV					0x08
+#define DBAT_DET				0x01
+
+/* BD7181X_REG_VBUS_STAT bits */
+#define VBUS_DET				0x01
+
+#define BUCK1_RAMPRATE_10MV_US			0x0
+#define BUCK1_RAMPRATE_5MV_US			0x1
+#define BUCK1_RAMPRATE_2P5MV_US			0x2
+#define BUCK1_RAMPRATE_1P25MV_US		0x3a
+
+/* BD7181X_REG_ALM0_MASK bits */
+#define A0_ONESEC				0x80
+
+/* BD7181X_REG_INT_EN_00 bits */
+#define ALMALE					0x1
+
+/* BD7181X_REG_INT_STAT_03 bits */
+#define DCIN_MON_DET				0x02
+#define DCIN_MON_RES				0x01
+
+/* BD71805_REG_INT_STAT_08 bits */
+#define VBAT_MON_DET				0x02
+#define VBAT_MON_RES				0x01
+
+/* BD71805_REG_INT_STAT_11 bits */
+#define	INT_STAT_11_VF_DET			0x80
+#define	INT_STAT_11_VF_RES			0x40
+#define	INT_STAT_11_VF125_DET		0x20
+#define	INT_STAT_11_VF125_RES		0x10
+#define	INT_STAT_11_OVTMP_DET		0x08
+#define	INT_STAT_11_OVTMP_RES		0x04
+#define	INT_STAT_11_LOTMP_DET		0x02
+#define	INT_STAT_11_LOTMP_RES		0x01
+
+#define VBAT_MON_DET				0x02
+#define VBAT_MON_RES				0x01
+
+/* BD7181X_REG_PWRCTRL bits */
+#define RESTARTEN				0x01
+
+/* BD7181X_REG_GPO bits */
+#define READY_FORCE_LOW				0x04
+
+/* BD7181X_REG_CHG_SET1 bits */
+#define CHG_EN					0x01
+
+/* BD7181X interrupt masks */
+enum {
+	BD7181X_INT_EN_01_BUCKAST_MASK	=	0x0F,
+	BD7181X_INT_EN_02_DCINAST_MASK	=	0x3E,
+	BD7181X_INT_EN_03_DCINAST_MASK	=	0x03,
+	BD7181X_INT_EN_04_VSYSAST_MASK	=	0xCF,
+	BD7181X_INT_EN_05_CHGAST_MASK	=	0xFC,
+	BD7181X_INT_EN_06_BATAST_MASK	=	0xF3,
+	BD7181X_INT_EN_07_BMONAST_MASK	=	0xFE,
+	BD7181X_INT_EN_08_BMONAST_MASK	=	0x03,
+	BD7181X_INT_EN_09_BMONAST_MASK	=	0x07,
+	BD7181X_INT_EN_10_BMONAST_MASK	=	0x3F,
+	BD7181X_INT_EN_11_TMPAST_MASK	=	0xFF,
+	BD7181X_INT_EN_12_ALMAST_MASK	=	0x07,
+};
+/* BD7181X interrupt irqs */
+enum {
+	BD7181X_IRQ_BUCK_01		=	0x0,
+	BD7181X_IRQ_DCIN_02,
+	BD7181X_IRQ_DCIN_03,
+	BD7181X_IRQ_VSYS_04,
+	BD7181X_IRQ_CHARGE_05,
+	BD7181X_IRQ_BAT_06,
+	BD7181X_IRQ_BAT_MON_07,
+	BD7181X_IRQ_BAT_MON_08,
+	BD7181X_IRQ_BAT_MON_09,
+	BD7181X_IRQ_BAT_MON_10,
+	BD7181X_IRQ_TEMPERATURE_11,
+	BD7181X_IRQ_ALARM_12,
+};
+
+/* BD7181X_REG_INT_EN_12 bits */
+#define ALM0					0x1
+
+/* BD7181X_REG_HOUR bits */
+#define HOUR_24HOUR				0x80
+
+/* BD7181X_REG_CC_CTRL bits */
+#define CCNTRST					0x80
+#define CCNTENB					0x40
+#define CCCALIB					0x20
+
+/* BD7181X_REG_CHG_SET1 bits */
+#define WDT_AUTO				0x40
+
+/* BD7181X_REG_CC_CURCD */
+#define CURDIR_Discharging			0x8000
+
+/* BD7181X_REG_VM_SA_IBAT */
+#define IBAT_SA_DIR_Discharging			0x8000
+
+/* BD7181X_REG_VM_SA_MINMAX_CLR bits */
+#define VSYS_SA_MIN_CLR				0x10
+#define VBAT_SA_MIN_CLR				0x01
+
+/* BD7181X_REG_REX_CTRL_1 bits */
+#define REX_CLR					0x10
+
+/* BD7181X_REG_REX_CTRL_1 bits */
+#define REX_PMU_STATE_MASK			0x04
+
+/* BD7181X_REG_FULL_CTRL bits */
+#define FULL_CLR				0x10
+
+/* BD7181X_REG_LED_CTRL bits */
+#define CHGDONE_LED_EN				0x10
+
+/** @brief charge state enumuration */
+enum CHG_STATE {
+	CHG_STATE_SUSPEND = 0x0,		/**< suspend state */
+	CHG_STATE_TRICKLE_CHARGE,		/**< trickle charge state */
+	CHG_STATE_PRE_CHARGE,			/**< precharge state */
+	CHG_STATE_FAST_CHARGE,			/**< fast charge state */
+	CHG_STATE_TOP_OFF,			/**< top off state */
+	CHG_STATE_DONE,				/**< charge complete */
+};
+
+/** @brief rtc or alarm registers structure */
+struct bd7181x_rtc_alarm {
+	u8	sec;
+	u8	min;
+	u8	hour;
+	u8	week;
+	u8	day;
+	u8	month;
+	u8	year;
+};
+
+struct bd7181x;
+
+/**
+ * @brief Board platform data may be used to initialize regulators.
+ */
+
+struct bd7181x_board {
+	struct regulator_init_data *init_data[BD7181X_REGULATOR_CNT];
+	/**< regulator initialize data */
+	int	gpio_intr;		/**< gpio connected to bd7181x INTB */
+	int	irq_base;		/**< bd7181x sub irqs base #  */
+};
+
+/**
+ * @brief bd7181x sub-driver chip access routines
+ */
+
+struct bd7181x {
+	struct device *dev;
+	struct i2c_client *i2c_client;
+	struct regmap *regmap;
+	struct mutex io_mutex;
+	unsigned int id;
+
+	/* IRQ Handling */
+	int 	chip_irq;		/**< bd7181x irq to host cpu */
+	struct regmap_irq_chip_data *irq_data;
+
+	/* Client devices */
+	struct bd7181x_pmic *pmic;	/**< client device regulator */
+	struct bd7181x_power *power;	/**< client device battery */
+
+	struct bd7181x_board *of_plat_data;
+	/**< Device node parsed board data */
+};
+
+static inline int bd7181x_chip_id(struct bd7181x *bd7181x)
+{
+	return bd7181x->id;
+}
+
+
+/**
+ * @brief bd7181x_reg_read
+ * read single register's value of bd7181x
+ * @param bd7181x device to read
+ * @param reg register address
+ * @return register value if success
+ *         error number if fail
+ */
+static inline int bd7181x_reg_read(struct bd7181x *bd7181x, u8 reg)
+{
+	int r, val;
+
+	r = regmap_read(bd7181x->regmap, reg, &val);
+	if (r < 0) {
+		return r;
+	}
+	return val;
+}
+
+/**
+ * @brief bd7181x_reg_write
+ * write single register of bd7181x
+ * @param bd7181x device to write
+ * @param reg register address
+ * @param val value to write
+ * @retval 0 if success
+ * @retval negative error number if fail
+ */
+
+static inline int bd7181x_reg_write(struct bd7181x *bd7181x, u8 reg,
+		unsigned int val)
+{
+	return regmap_write(bd7181x->regmap, reg, val);
+}
+
+/**
+ * @brief bd7181x_set_bits
+ * set bits in one register of bd7181x
+ * @param bd7181x device to read
+ * @param reg register address
+ * @param mask mask bits
+ * @retval 0 if success
+ * @retval negative error number if fail
+ */
+static inline int bd7181x_set_bits(struct bd7181x *bd7181x, u8 reg,
+		u8 mask)
+{
+	return regmap_update_bits(bd7181x->regmap, reg, mask, mask);
+}
+
+/**
+ * @brief bd7181x_clear_bits
+ * clear bits in one register of bd7181x
+ * @param bd7181x device to read
+ * @param reg register address
+ * @param mask mask bits
+ * @retval 0 if success
+ * @retval negative error number if fail
+ */
+
+static inline int bd7181x_clear_bits(struct bd7181x *bd7181x, u8 reg,
+		u8 mask)
+{
+	return regmap_update_bits(bd7181x->regmap, reg, mask, 0);
+}
+
+/**
+ * @brief bd7181x_update_bits
+ * update bits in one register of bd7181x
+ * @param bd7181x device to read
+ * @param reg register address
+ * @param mask mask bits
+ * @param val value to update
+ * @retval 0 if success
+ * @retval negative error number if fail
+ */
+
+static inline int bd7181x_update_bits(struct bd7181x *bd7181x, u8 reg,
+					   u8 mask, u8 val)
+{
+	return regmap_update_bits(bd7181x->regmap, reg, mask, val);
+}
+
+/**
+ * @brief bd7181x platform data type
+ */
+struct bd7181x_gpo_plat_data {
+	u32 mode;		///< gpo output mode
+	int gpio_base;		///< base gpio number in system
+};
+
+#endif /* __LINUX_MFD_BD7181X_H */
+
diff --git a/sound/soc/fsl/Kconfig b/sound/soc/fsl/Kconfig
index 63fb12d..9051bcd 100644
--- a/sound/soc/fsl/Kconfig
+++ b/sound/soc/fsl/Kconfig
@@ -264,6 +264,18 @@ config SND_SOC_IMX_SII902X
 	 Say Y if you want to add support for SoC audio on an i.MX board with
 	 a sii902x.
 
+config SND_SOC_IMX_WM8731
+	tristate "SoC Audio support for i.MX boards with wm8731"
+	depends on OF && I2C
+	select SND_SOC_WM8731
+	select SND_SOC_IMX_PCM_DMA
+	select SND_SOC_IMX_AUDMUX
+	select SND_SOC_FSL_SSI
+	select SND_SOC_FSL_UTILS
+	help
+	  Say Y if you want to add support for SoC audio on an i.MX board with
+	  a wm8731 codec.
+
 config SND_SOC_IMX_WM8958
 	tristate "SoC Audio support for i.MX boards with wm8958"
 	depends on OF && I2C
diff --git a/sound/soc/fsl/Makefile b/sound/soc/fsl/Makefile
index e29f6ec..0d4ac2b 100644
--- a/sound/soc/fsl/Makefile
+++ b/sound/soc/fsl/Makefile
@@ -55,6 +55,7 @@ snd-soc-mx27vis-aic32x4-objs := mx27vis-aic32x4.o
 snd-soc-wm1133-ev1-objs := wm1133-ev1.o
 snd-soc-imx-cs42888-objs := imx-cs42888.o
 snd-soc-imx-sgtl5000-objs := imx-sgtl5000.o
+snd-soc-imx-wm8731-objs := imx-wm8731.o
 snd-soc-imx-wm8958-objs := imx-wm8958.o
 snd-soc-imx-wm8960-objs := imx-wm8960.o
 snd-soc-imx-wm8962-objs := imx-wm8962.o
@@ -71,6 +72,7 @@ obj-$(CONFIG_SND_SOC_MX27VIS_AIC32X4) += snd-soc-mx27vis-aic32x4.o
 obj-$(CONFIG_SND_MXC_SOC_WM1133_EV1) += snd-soc-wm1133-ev1.o
 obj-$(CONFIG_SND_SOC_IMX_CS42888) += snd-soc-imx-cs42888.o
 obj-$(CONFIG_SND_SOC_IMX_SGTL5000) += snd-soc-imx-sgtl5000.o
+obj-$(CONFIG_SND_SOC_IMX_WM8731) += snd-soc-imx-wm8731.o
 obj-${CONFIG_SND_SOC_IMX_WM8958} += snd-soc-imx-wm8958.o
 obj-${CONFIG_SND_SOC_IMX_WM8960} += snd-soc-imx-wm8960.o
 obj-$(CONFIG_SND_SOC_IMX_WM8962) += snd-soc-imx-wm8962.o
diff --git a/sound/soc/fsl/imx-wm8731.c b/sound/soc/fsl/imx-wm8731.c
new file mode 100644
index 0000000..0e26127
--- /dev/null
+++ b/sound/soc/fsl/imx-wm8731.c
@@ -0,0 +1,472 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * Based on imx-sgtl5000.c
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2012 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/i2c.h>
+#include <linux/clk.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <linux/mfd/syscon.h>
+
+#include "../codecs/wm8731.h"
+#include "imx-audmux.h"
+#include "imx-ssi.h"
+
+#define DAI_NAME_SIZE	32
+
+struct imx_wm8731_data {
+	struct snd_soc_dai_link dai;
+	struct snd_soc_card card;
+	char codec_dai_name[DAI_NAME_SIZE];
+	char platform_name[DAI_NAME_SIZE];
+	struct i2c_client *codec_dev;
+	struct clk *codec_clk;
+	long sysclk;
+};
+
+static int imx_wm8731_init(struct snd_soc_pcm_runtime *rtd);
+static int imx_hifi_hw_params_slv_mode(struct snd_pcm_substream *substream,
+                                       struct snd_pcm_hw_params *params);
+
+struct imx_priv {
+	struct platform_device *pdev;
+	struct imx_wm8731_data *data;
+};
+
+static struct imx_priv card_priv;
+
+static struct snd_soc_ops imx_hifi_ops = {
+	.hw_params 	= imx_hifi_hw_params_slv_mode,
+};
+
+
+/* imx card dapm widgets */
+static const struct snd_soc_dapm_widget imx_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone Jack",       NULL),
+	SND_SOC_DAPM_SPK("Ext Spk",             NULL),
+	SND_SOC_DAPM_LINE("Line Jack",          NULL),
+	SND_SOC_DAPM_MIC("Mic Jack",            NULL),
+};
+
+/* imx machine connections to the codec pins */
+static const struct snd_soc_dapm_route audio_map[] = {
+	{ "Headphone Jack",     NULL,   "LHPOUT" },
+	{ "Headphone Jack",     NULL,   "RHPOUT" },
+
+	{ "Ext Spk",            NULL,   "LOUT" },
+	{ "Ext Spk",            NULL,   "ROUT" },
+
+	{ "LLINEIN",            NULL,   "Line Jack" },
+	{ "RLINEIN",            NULL,   "Line Jack" },
+
+	{ "MICIN",              NULL,   "Mic Bias" },
+	{ "Mic Bias",           NULL,   "Mic Jack"},
+};
+
+
+static int imx_hifi_hw_params_slv_mode(struct snd_pcm_substream *substream,
+				       struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_card *card = codec_dai->codec->card;
+	struct imx_wm8731_data *data = snd_soc_card_get_drvdata(card);
+	
+	u32 dai_format;
+	snd_pcm_format_t sample_format;
+	unsigned int channels;
+	unsigned int tx_mask, rx_mask;
+	unsigned int sampling_rate;
+	unsigned int div_2, div_psr, div_pm;
+	int ret;
+
+	sampling_rate = params_rate(params);
+	sample_format = params_format(params);
+	
+	channels = params_channels(params);
+/*	printk("%s:%s  sampling rate = %u  channels = %u \n", __FUNCTION__,
+		   (substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? "Playback" : "Capture"),
+		   sampling_rate, channels);*/
+
+	/* set CPU DAI configuration */
+	switch (sampling_rate) {
+		case 8000:
+		case 32000:
+		case 48000:
+		case 96000:
+			data->sysclk = 12288000;
+			break;
+
+		case 44100:
+		case 88200:
+			data->sysclk = 11289600;
+			break;
+
+		default:
+			return -EINVAL;
+	}
+
+	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_IF |
+		SND_SOC_DAIFMT_CBS_CFS;
+
+	ret = snd_soc_dai_set_fmt(cpu_dai, dai_format);
+	if (ret < 0)
+		return ret;
+
+	/* set i.MX active slot mask */
+	/* S[TR]CCR:DC */
+	tx_mask = ~((1 << channels) - 1);
+	rx_mask = tx_mask;
+	snd_soc_dai_set_tdm_slot(cpu_dai, tx_mask, rx_mask, 2, 32);
+
+	/*
+	 * SSI sysclk divider:
+	 * div_2:	/1 or /2
+	 * div_psr:	/1 or /8
+	 * div_pm:	/1 .. /256
+	 */
+	div_2	= 0;
+	div_psr	= 0;
+	switch (sampling_rate) {
+		case 8000:
+			// 1x1x12
+			div_pm	= 11;
+			break;
+		case 32000:
+			// 1x1x3
+			div_pm	= 2;
+			break;
+		case 48000:
+			// 1x1x2
+			div_pm	= 1;
+			break;
+		case 96000:
+			// 1x1x1
+			div_pm	= 0;
+			break;
+		case 44100:
+			// 1x1x2
+			div_pm	= 1;
+			break;
+		case 88200:
+			// 1x1x1
+			div_pm	= 0;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	/* sync mode: a single clock controls both playback and capture */
+	snd_soc_dai_set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_2, (div_2 ? SSI_STCCR_DIV2 : 0));
+	snd_soc_dai_set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_PSR, (div_psr ? SSI_STCCR_PSR : 0));
+	snd_soc_dai_set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_PM, div_pm);
+
+	/* set codec DAI configuration */
+	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		SND_SOC_DAIFMT_CBS_CFS;
+
+	ret = snd_soc_dai_set_fmt(codec_dai, dai_format);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_sysclk(codec_dai,
+				     WM8731_SYSCLK_MCLK,
+				     data->sysclk,
+				     SND_SOC_CLOCK_IN);
+
+	if (ret < 0) {
+		pr_err("Failed to set codec master clock to %lu: %d \n",
+		       data->sysclk, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int imx_wm8731_init(struct snd_soc_pcm_runtime *rtd)
+{
+	int ret = 0;
+	struct snd_soc_codec *codec = rtd->codec;
+
+	/* Add imx specific widgets */
+	ret = snd_soc_dapm_new_controls(&codec->dapm, imx_dapm_widgets,
+									ARRAY_SIZE(imx_dapm_widgets));
+	if (ret)
+			goto out_retcode;
+
+	/* Set up imx specific audio path audio_map */
+	ret = snd_soc_dapm_add_routes(&codec->dapm, audio_map, ARRAY_SIZE(audio_map));
+	if (ret)
+			goto out_retcode;
+
+	ret = snd_soc_dapm_enable_pin(&codec->dapm, "Headphone Jack");
+	if (ret)
+			goto out_retcode;
+
+	ret = snd_soc_dapm_nc_pin(&codec->dapm, "Ext Spk");
+	if (ret)
+			goto out_retcode;
+
+out_retcode:
+
+	if (ret)
+			pr_err("%s: failed with error code: %d \n", __FUNCTION__, ret);
+	else
+			pr_info("%s: success \n", __FUNCTION__);
+
+	return ret;
+}
+
+/**
+ * Configure AUDMUX interconnection between
+ * _slave (CPU side) and _master (codec size)
+ *
+ * When SSI operates in master mode, 5-wire interconnect with
+ * audio codec is required:
+ * TXC  - BCLK
+ * TXD  - DAC data
+ * RXD  - ADC data
+ * TXFS - {DAC|ADC}LRC, i.e. word clock
+ * RXC  - MCLK, i.e. oversampling clock
+ * Audmux is operated in asynchronous mode to enable 6-wire
+ * interface (as opposed to 4-wire interface in sync mode).
+ */
+static int imx_audmux_config_slv_mode(int _slave, int _master)
+{
+	unsigned int ptcr, pdcr;
+	int slave = _slave - 1;
+	int master = _master - 1;
+
+	ptcr = IMX_AUDMUX_V2_PTCR_SYN |
+		IMX_AUDMUX_V2_PTCR_TFSDIR |
+		IMX_AUDMUX_V2_PTCR_TFSEL(slave) |
+		IMX_AUDMUX_V2_PTCR_RCLKDIR |
+		IMX_AUDMUX_V2_PTCR_RCSEL(slave | 0x8) |
+		IMX_AUDMUX_V2_PTCR_TCLKDIR |
+		IMX_AUDMUX_V2_PTCR_TCSEL(slave);
+
+	pdcr = IMX_AUDMUX_V2_PDCR_RXDSEL(slave);
+	imx_audmux_v2_configure_port(master, ptcr, pdcr);
+	ptcr = ptcr & ~IMX_AUDMUX_V2_PTCR_SYN;
+	imx_audmux_v2_configure_port(master, ptcr, pdcr);
+
+	ptcr = IMX_AUDMUX_V2_PTCR_SYN |
+		IMX_AUDMUX_V2_PTCR_RCLKDIR |
+		IMX_AUDMUX_V2_PTCR_RCSEL(master | 0x8) |
+		IMX_AUDMUX_V2_PTCR_TCLKDIR |
+		IMX_AUDMUX_V2_PTCR_TCSEL(master);
+
+	pdcr = IMX_AUDMUX_V2_PDCR_RXDSEL(master);
+	imx_audmux_v2_configure_port(slave, ptcr, pdcr);
+	ptcr = ptcr & ~IMX_AUDMUX_V2_PTCR_SYN;
+	imx_audmux_v2_configure_port(slave, ptcr, pdcr);
+
+	return 0;
+}
+
+
+static int imx_wm8731_probe(struct platform_device *pdev)
+{
+	struct device_node *ssi_np, *codec_np;
+	struct platform_device *ssi_pdev;
+	struct imx_priv *priv = &card_priv;
+	struct i2c_client *codec_dev;
+	struct imx_wm8731_data *data;
+	unsigned int src_port, ext_port;
+
+	int ret;
+	u32 out_val[3];
+	phandle phandle;
+	struct regmap *gpr;
+	struct device_node *node;
+
+	priv->pdev = pdev;
+	
+	ssi_np = of_parse_phandle(pdev->dev.of_node, "ssi-controller", 0);
+	codec_np = of_parse_phandle(pdev->dev.of_node, "audio-codec", 0);
+	if (!ssi_np || !codec_np) {
+		dev_err(&pdev->dev, "phandle missing or invalid\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	ssi_pdev = of_find_device_by_node(ssi_np);
+	if (!ssi_pdev) {
+		dev_err(&pdev->dev, "failed to find SSI platform device\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+        
+	codec_dev = of_find_i2c_device_by_node(codec_np);
+	if (!codec_dev) {
+		dev_err(&pdev->dev, "failed to find codec platform device\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	if (!data) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	do {
+		ret = of_property_read_u32_array(pdev->dev.of_node, "gpr", out_val, 3);
+		if (ret) break;
+
+		phandle = *out_val;
+		node = of_find_node_by_phandle(phandle);
+		if (!node) break;
+
+		gpr = syscon_node_to_regmap(node);
+		if (IS_ERR(gpr)) break;
+
+		of_node_put(node);
+
+		/*
+		 * set SAI2_MCLK_DIR to enable codec MCLK
+		 * out_val[1] is the register offset
+		 * out_val[2] is the bit field
+		 */
+		regmap_update_bits(gpr, out_val[1], (1<<out_val[2]), (1<<out_val[2]));
+
+
+	} while(0);
+
+	card_priv.data = data;
+
+	data->codec_dev = codec_dev;
+
+	data->codec_clk = devm_clk_get(&codec_dev->dev, NULL);
+	if (IS_ERR(data->codec_clk)) {
+		ret = PTR_ERR(data->codec_clk);
+		dev_err(&codec_dev->dev, "failed to get codec clk: %d\n", ret);
+		goto fail;	
+	}
+
+//	data->clk_frequency = clk_get_rate(data->codec_clk);	
+	ret = clk_prepare_enable(data->codec_clk);
+
+	if (ret) {
+		dev_err(&codec_dev->dev, "failed to enable codec clk: %d\n", ret);
+		goto fail;
+	}
+
+	data->dai.name = "HiFi";
+	data->dai.stream_name = "HiFi";
+	data->dai.codec_dai_name = "wm8731-hifi";
+	data->dai.codec_of_node = codec_np;
+	data->dai.cpu_dai_name = dev_name(&ssi_pdev->dev);
+	data->dai.platform_of_node = ssi_np;
+	data->dai.ops = &imx_hifi_ops;
+	data->dai.init = &imx_wm8731_init;
+	
+	ret = of_property_read_u32(pdev->dev.of_node, "src-port", &src_port);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to get \"src-port\" value\n");
+		ret = -EINVAL;
+		goto clk_fail;
+	}
+
+	ret = of_property_read_u32(pdev->dev.of_node, "ext-port", &ext_port);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to get \"ext-port\" value\n");
+		ret = -EINVAL;
+		goto clk_fail;
+	}
+
+	imx_audmux_config_slv_mode(src_port, ext_port);
+
+	
+	data->card.dev = &pdev->dev;
+	ret = snd_soc_of_parse_card_name(&data->card, "model");
+	if (ret)
+		goto clk_fail;
+	
+	ret = snd_soc_of_parse_audio_routing(&data->card, "audio-routing");
+	if (ret)
+		goto clk_fail;
+
+
+	data->card.num_links = 1;
+	data->card.dai_link = &data->dai;
+
+	data->card.dapm_widgets = imx_dapm_widgets;
+	data->card.num_dapm_widgets = ARRAY_SIZE(imx_dapm_widgets);
+
+	platform_set_drvdata(pdev, &data->card);
+	snd_soc_card_set_drvdata(&data->card, data);
+
+	ret = snd_soc_register_card(&data->card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n", ret);
+		goto clk_fail;
+
+	}
+	
+	return 0;
+
+clk_fail:
+	clk_disable_unprepare(data->codec_clk);
+
+fail:
+
+	if (ssi_np)
+		of_node_put(ssi_np);
+
+	if (codec_np)
+		of_node_put(codec_np);
+
+	return ret;
+}
+
+static int imx_wm8731_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	struct imx_wm8731_data *data = snd_soc_card_get_drvdata(card);
+ 
+	if (!IS_ERR(data->codec_clk))
+		clk_disable_unprepare(data->codec_clk);
+
+	snd_soc_unregister_card(card);
+
+	return 0;
+}
+
+static const struct of_device_id imx_wm8731_dt_ids[] = {
+	{ .compatible = "fsl,imx-audio-wm8731", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, imx_wm8731_dt_ids);
+
+static struct platform_driver imx_wm8731_driver = {
+	.driver = {
+		.name = "imx-wm8731",
+		.owner = THIS_MODULE,
+		.of_match_table = imx_wm8731_dt_ids,
+	},
+	.probe = imx_wm8731_probe,
+	.remove = imx_wm8731_remove,
+};
+module_platform_driver(imx_wm8731_driver);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("Freescale i.MX WM8731 ASoC machine driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:imx-wm8731");
+
