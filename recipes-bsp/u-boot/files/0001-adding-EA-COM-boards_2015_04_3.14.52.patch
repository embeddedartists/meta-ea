diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 0c82b17..3ccac3f 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -576,6 +576,31 @@ config TARGET_MX6UL_14X14_LPDDR2_ARM2
         bool "Support mx6ul_14x14_lpddr2_arm2"
         select CPU_V7
 
+config TARGET_MX6SXEA_COM
+        bool "Support mx6sxea-com"
+        select CPU_V7
+        select SUPPORT_SPL
+
+config TARGET_MX6QEA_COM
+        bool "Support mx6qea-com"
+        select CPU_V7
+        select SUPPORT_SPL
+
+config TARGET_MX6ULEA_COM
+        bool "Support mx6ulea-com"
+        select CPU_V7
+	select SUPPORT_SPL
+
+config TARGET_MX7DEA_UCOM
+	bool "Support mx7dea-ucom"
+	select CPU_V7
+	select SUPPORT_SPL
+
+config TARGET_MX7DEA_COM
+        bool "Support mx7dea-com"
+        select CPU_V7
+        select SUPPORT_SPL
+
 config TARGET_GW_VENTANA
 	bool "Support gw_ventana"
 	select CPU_V7
@@ -848,6 +873,11 @@ source "board/creative/xfi3/Kconfig"
 source "board/davedenx/qong/Kconfig"
 source "board/denx/m28evk/Kconfig"
 source "board/denx/m53evk/Kconfig"
+source "board/embeddedartists/mx6sxea-com/Kconfig"
+source "board/embeddedartists/mx6qea-com/Kconfig"
+source "board/embeddedartists/mx6ulea-com/Kconfig"
+source "board/embeddedartists/mx7dea-ucom/Kconfig"
+source "board/embeddedartists/mx7dea-com/Kconfig"
 source "board/embest/mx6boards/Kconfig"
 source "board/esg/ima3-mx53/Kconfig"
 source "board/freescale/ls2085a/Kconfig"
diff --git a/arch/arm/cpu/armv7/mx6/ddr.c b/arch/arm/cpu/armv7/mx6/ddr.c
index fef2231..2357072 100644
--- a/arch/arm/cpu/armv7/mx6/ddr.c
+++ b/arch/arm/cpu/armv7/mx6/ddr.c
@@ -243,7 +243,7 @@ void mx6sdl_dram_iocfg(unsigned width,
  */
 #define MR(val, ba, cmd, cs1) \
 	((val << 16) | (1 << 15) | (cmd << 4) | (cs1 << 3) | ba)
-#ifdef CONFIG_MX6SX
+#if defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL)
 #define MMDC1(entry, value)	do {} while (0)
 #else
 #define MMDC1(entry, value) do { mmdc1->entry = value; } while (0)
@@ -253,7 +253,7 @@ void mx6_dram_cfg(const struct mx6_ddr_sysinfo *sysinfo,
 		  const struct mx6_ddr3_cfg *ddr3_cfg)
 {
 	volatile struct mmdc_p_regs *mmdc0;
-#ifndef CONFIG_MX6SX
+#if !defined(CONFIG_MX6SX) && !defined(CONFIG_MX6UL)
 	volatile struct mmdc_p_regs *mmdc1;
 #endif
 	u32 val;
@@ -269,7 +269,7 @@ void mx6_dram_cfg(const struct mx6_ddr_sysinfo *sysinfo,
 	int cs;
 
 	mmdc0 = (struct mmdc_p_regs *)MMDC_P0_BASE_ADDR;
-#ifndef CONFIG_MX6SX
+#if !defined(CONFIG_MX6SX) && !defined(CONFIG_MX6UL)
 	mmdc1 = (struct mmdc_p_regs *)MMDC_P1_BASE_ADDR;
 #endif
 
diff --git a/arch/arm/imx-common/Makefile b/arch/arm/imx-common/Makefile
index 70f22b2..ee8bd81 100644
--- a/arch/arm/imx-common/Makefile
+++ b/arch/arm/imx-common/Makefile
@@ -19,6 +19,8 @@ obj-y  += timer.o
 endif
 ifeq ($(SOC),$(filter $(SOC),mx7))
 obj-y	+= cpu.o
+obj-$(CONFIG_IMX_VIDEO_SKIP) += video.o
+obj-$(CONFIG_CMD_EADISP) += eadisp.o eatouch.o
 obj-$(CONFIG_SYS_I2C_MXC) += i2c-mxv7.o
 obj-$(CONFIG_GPT_TIMER) += timer.o
 obj-$(CONFIG_SYSCOUNTER_TIMER) += syscounter.o
@@ -30,6 +32,7 @@ endif
 ifeq ($(SOC),$(filter $(SOC),mx6))
 obj-$(CONFIG_CMD_SATA) += sata.o
 obj-$(CONFIG_IMX_VIDEO_SKIP) += video.o
+obj-$(CONFIG_CMD_EADISP) += eadisp.o eatouch.o
 obj-$(CONFIG_MXC_RDC) += rdc-sema.o
 obj-$(CONFIG_GPT_TIMER) += timer.o
 obj-$(CONFIG_SYSCOUNTER_TIMER) += syscounter.o
diff --git a/arch/arm/imx-common/eadisp.c b/arch/arm/imx-common/eadisp.c
new file mode 100644
index 0000000..766c457
--- /dev/null
+++ b/arch/arm/imx-common/eadisp.c
@@ -0,0 +1,934 @@
+/*
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/errno.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/crm_regs.h>
+#if !defined(CONFIG_MX7D)
+  #include <asm/arch/mxc_hdmi.h>
+#endif
+#include <asm/gpio.h>
+#include <asm/imx-common/eadisp.h>
+#include <asm/io.h>
+#include <div64.h>
+#include <i2c.h>
+#include <malloc.h>
+#include <video_fb.h>
+#include <stdlib.h>
+#if defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL) || defined(CONFIG_MX7D)
+  #include <linux/fb.h>
+  #include <mxsfb.h>
+#endif
+
+/*
+ * The board file should call eadisp_setup_display to register a list of
+ * supported configurations for each supported display type.
+ *
+ * The eadisp command:
+ * - Supports enabling/disabling of each supported display type
+ * - Supports selecting one display to use in u-boot (otherwise the first)
+ *   in the list is used
+ * - Supports adding new display configurations (complete including pixclock,
+ *   resolution, and timing information)
+ * - Supports removal of added configurations
+ *
+ * The eadisp command does this by setting environment variables (XX stand for
+ * lcd,hdmi,lvds0,lvds1):
+ * - fb_XX               hold the selected configuration
+ * - eadisp_XX_enabled   set to yes if the XX-type display is enabled
+ * - eadisp_prefer       set to XX if XX is the preferred display type
+ * - cmd_XX              holds fdt commands that will be executed by a bootscript
+ */
+static const char *const fbnames[] = {
+[FB_RGB] = "fb_rgb",
+[FB_LVDS0] = "fb_lvds0",
+[FB_LVDS1] = "fb_lvds1",
+[FB_HDMI] = "fb_hdmi"
+};
+
+static const char *const timings_names[] = {
+[FB_RGB] = "t_rgb",
+[FB_LVDS0] = "t_lvds0",
+[FB_LVDS1] = "t_lvds1",
+[FB_HDMI] = "t_hdmi"
+};
+
+static const char *const ch_names[] = {
+[FB_RGB] = "",
+[FB_LVDS0] = "ldb/lvds-channel@0",
+[FB_LVDS1] = "ldb/lvds-channel@1",
+[FB_HDMI] = ""
+};
+
+static const char *const bl_names[] = {
+[FB_RGB] = "bl_rgb",
+[FB_LVDS0] = "bl_lvds",
+[FB_LVDS1] = "bl_lvds",
+[FB_HDMI] = ""
+};
+
+static const char *const cmd_fbnames[] = {
+[FB_RGB] = "cmd_rgb",
+[FB_LVDS0] = "cmd_lvds0",
+[FB_LVDS1] = "cmd_lvds1",
+[FB_HDMI] = "cmd_hdmi"
+};
+
+static const char *const short_names[] = {
+[FB_RGB] = "rgb",
+[FB_LVDS0] = "lvds0",
+[FB_LVDS1] = "lvds1",
+[FB_HDMI] = "hdmi"
+};
+
+#if defined(CONFIG_MX6SX)
+  #define DISPTYPES  "(rgb|lvds0)"
+  #define NUM_FBS    2  /* Only have 1x RGB and 1x LVDS on SoloX */
+#elif defined(CONFIG_MX6Q)
+  #define DISPTYPES  "(hdmi|rgb|lvds0|lvds1)"
+  #define NUM_FBS    4
+#elif defined(CONFIG_MX6DL)
+  #define DISPTYPES  "(hdmi|rgb|lvds0|lvds1)"
+  #define NUM_FBS    4
+#elif defined(CONFIG_MX6UL)
+  #define DISPTYPES  "rgb"
+  #define NUM_FBS    1  /* Only have 1x RGB on UltraLite */
+#elif defined(CONFIG_MX7D)
+  #define DISPTYPES  "rgb"
+  #define NUM_FBS    1  /* Only have 1x RGB on 7 Dual */
+#else
+  #error Unsupported hardware
+#endif
+
+static const char *const timings_properties[] = {
+"clock-frequency",
+"hactive",
+"vactive",
+"hback-porch",
+"hfront-porch",
+"vback-porch",
+"vfront-porch",
+"hsync-len",
+"vsync-len",
+};
+
+static const int timings_offsets[] = {
+	offsetof(struct fb_videomode, pixclock),
+	offsetof(struct fb_videomode, xres),
+	offsetof(struct fb_videomode, yres),
+	offsetof(struct fb_videomode, left_margin),
+	offsetof(struct fb_videomode, right_margin),
+	offsetof(struct fb_videomode, upper_margin),
+	offsetof(struct fb_videomode, lower_margin),
+	offsetof(struct fb_videomode, hsync_len),
+	offsetof(struct fb_videomode, vsync_len),
+};
+
+#define MAX_OWN_DISPLAYS  5
+static struct display_info_t g_di_own[MAX_OWN_DISPLAYS];
+static char g_di_own_mode_str[MAX_OWN_DISPLAYS][80];
+static int found_own_displays = 0;
+static int loaded_own_configs = 0;
+
+static const struct display_info_t *g_displays;
+static int g_display_cnt;
+static const struct display_info_t *g_di_active;
+static char g_mode_str[4][80];
+static struct display_info_t g_di_temp[FB_COUNT];
+static const char rgb24[] = "RGB24";
+static const char rgb666[] = "RGB666";
+static const char yuyv16[] = "YUYV16";
+
+static void __board_enable_hdmi(const struct display_info_t *di, int enable)
+{
+}
+
+static void __board_enable_rgb(const struct display_info_t *di, int enable)
+{
+}
+
+static void __board_enable_lvds0(const struct display_info_t *di, int enable)
+{
+}
+
+static void __board_enable_lvds1(const struct display_info_t *di, int enable)
+{
+}
+
+void board_enable_hdmi(const struct display_info_t *di, int enable)
+	__attribute__((weak, alias("__board_enable_hdmi")));
+void board_enable_rgb(const struct display_info_t *di, int enable)
+	__attribute__((weak, alias("__board_enable_rgb")));
+void board_enable_lvds0(const struct display_info_t *di, int enable)
+	__attribute__((weak, alias("__board_enable_lvds0")));
+void board_enable_lvds1(const struct display_info_t *di, int enable)
+	__attribute__((weak, alias("__board_enable_lvds1")));
+
+void eadisp_enable_fb(struct display_info_t const *di, int enable)
+{
+	switch (di->fbtype) {
+	case FB_HDMI:
+		board_enable_hdmi(di, enable);
+		break;
+	case FB_RGB:
+		board_enable_rgb(di, enable);
+		break;
+	case FB_LVDS0:
+		board_enable_lvds0(di, enable);
+		break;
+	case FB_LVDS1:
+		board_enable_lvds1(di, enable);
+		break;
+	}
+}
+
+static const struct display_info_t *find_panel(const struct display_info_t *di, int cnt, unsigned fb, const char *name)
+{
+	int i;
+
+	for (i = 0; i < cnt; i++, di++) {
+		if ((fb == di->fbtype) && !strcmp(name, di->mode.name))
+			return di;
+	}
+	return NULL;
+}
+
+static const struct display_info_t * parse_mode(
+		const struct display_info_t *gdi, int cnt, const char *p,
+		unsigned fb)
+{
+	char c;
+	char *endp;
+	unsigned value;
+	int i;
+	struct display_info_t *di;
+	char *mode_str = g_mode_str[fb];
+
+	i = 0;
+	while (i < 80 - 1) {
+		c = *p;
+		if (c)
+			p++;
+		if (!c || (c == ':')) {
+			break;
+		}
+		mode_str[i++] = c;
+	}
+	mode_str[i] = 0;
+	c = *p;
+	if (!c) {
+		// only have a mode_str, no other configuration
+		if (gdi == NULL) {
+			// parsing own configurations - no point in looking for mode_str
+			return NULL;
+		}
+		return find_panel(gdi, cnt, fb, mode_str);
+	}
+	di = &g_di_temp[fb];
+	memset(di, 0, sizeof(*di));
+
+	di->fbtype = fb;
+	di->mode.name = mode_str;
+	di->enable = eadisp_enable_fb;
+
+	if (c == 'm') {
+		di->fbflags |= FBF_MODESTR;
+		p++;
+		c = *p;
+	}
+	if (c == 'j') {
+		di->fbflags |= FBF_JEIDA;
+		p++;
+		c = *p;
+	}
+	if (c == 's') {
+		di->fbflags |= FBF_SPLITMODE;
+		p++;
+		c = *p;
+	}
+	value = simple_strtoul(p, &endp, 10);
+	if (endp <= p) {
+		printf("expecting 18|24\n");
+		return NULL;
+	}
+	if ((value != 18) && (value != 24)) {
+		printf("expecting 18|24, found %d\n", value);
+		return NULL;
+	}
+	p = endp;
+	di->pixfmt = (value == 24) ? IPU_PIX_FMT_RGB24 : IPU_PIX_FMT_RGB666;
+	c = *p;
+	if (*p != ':') {
+		printf("expected ':', %s\n", p);
+		return NULL;
+	}
+	p++;
+
+	for (i = 0; i < ARRAY_SIZE(timings_properties); i++) {
+		u32 *dest = (u32 *)((char *)&di->mode + timings_offsets[i]);
+		u32 val;
+
+		val = simple_strtoul(p, &endp, 10);
+		if (endp <= p) {
+			printf("expecting integer:%s\n", p);
+			return NULL;
+		}
+		if (i == 0) {
+			u64 lval = 1000000000000ULL;
+
+			do_div(lval, val);
+			val = (u32)lval;
+		}
+		*dest = val;
+		p = endp;
+		if (*p == ',')
+			p++;
+		if (*p == ' ')
+			p++;
+	}
+
+	di->misc = 0;
+	for (i = 0; i < 4; i++)
+	{
+		u32 val;
+		val = simple_strtoul(p, &endp, 10);
+                if (endp <= p) {
+                        printf("expecting integer:%s\n", p);
+                        return NULL;
+                }
+                if (!(val==0 || val==1)) {
+                        printf("expecting 0 or 1:%s\n", p);
+                        return NULL;
+                }
+		if (val == 1) {
+			switch (i) {
+			case 0: di->misc |= MISC_HSYNC_ACTIVE_HIGH; break;
+			case 1: di->misc |= MISC_VSYNC_ACTIVE_HIGH; break;
+			case 2: di->misc |= MISC_DE_ACTIVE_HIGH; break;
+			case 3: di->misc |= MISC_PIXELCLK_ACTIVE_HIGH; break;
+			}
+		}
+		p = endp;
+		if (*p == ',')
+			p++;
+		if (*p == ' ')
+			p++;
+	}
+
+	if (*p) {
+		printf("extra parameters found:%s\n", p);
+		return NULL;
+	}
+	return di;
+}
+
+#if defined(CONFIG_MX6Q)
+static int is_fb_enabled(int fb)
+{
+	char buf[40];
+	if (getenv(fbnames[FB_LVDS0])) {
+		sprintf(buf, "eadisp_%s_enabled", short_names[fb]);
+		if (!strcmp("yes", getenv(buf))) {
+			return 1;
+		}
+	}
+	return 0;
+}
+#endif
+
+static void setup_cmd_fb(unsigned fb, const struct display_info_t *di, char *buf, int size)
+{
+	const char *mode_str = NULL;
+	int i;
+	int sz;
+	const char *buf_start = buf;
+	const struct fb_videomode *mode;
+	const char * fmt;
+
+	if (!di) {
+		sz = snprintf(buf, size, "fdt set %s status disabled", fbnames[fb]);
+		buf += sz;
+		size -= sz;
+		if (fb == FB_RGB) {
+			snprintf(buf, size, ";fdt set %s status disabled", bl_names[fb]);
+#if defined(CONFIG_MX6SX)
+		} else if (fb == FB_LVDS0) {
+			snprintf(buf, size, ";fdt set %s status disabled", bl_names[fb]);
+#elif defined(CONFIG_MX6Q)
+		} else if (fb == FB_LVDS1) {
+			// Enough to do this check for FB_LVDS1 as it will test FB_LVDS0 as well
+			if (!is_fb_enabled(FB_LVDS0)) {
+				// neither LVDS interface is enabled so no need for backlight
+				snprintf(buf, size, ";fdt set %s status disabled", bl_names[fb]);
+			}
+#endif
+		}
+		setenv(cmd_fbnames[fb], buf_start);
+		//printf("Disabling %s\n", short_names[fb]);
+		return;
+	} else {
+		if (di->fbflags & FBF_MODESTR) {
+			mode_str = di->mode.name;
+		}
+	}
+
+	sz = snprintf(buf, size, "fdt set %s status okay;", fbnames[fb]);
+	buf += sz;
+	size -= sz;
+
+	if (di->pixfmt == IPU_PIX_FMT_RGB24)
+		fmt = rgb24;
+	else if (di->pixfmt == IPU_PIX_FMT_YUYV)
+		fmt = yuyv16;
+	else
+		fmt = rgb666;
+
+	if (di && ((fb == FB_RGB) || (fb == FB_LVDS0) || (fb == FB_LVDS1))) {
+#if defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL) || defined(CONFIG_MX7D)
+		sz = snprintf(buf, size, "fdt set %s bus-width <%u>;", short_names[fb],
+				(di->pixfmt == IPU_PIX_FMT_RGB24) ? 24 : 18);
+
+#else
+		sz = snprintf(buf, size, "fdt set %s interface_pix_fmt %s;",
+				fbnames[fb], fmt);
+#endif
+		buf += sz;
+		size -= sz;
+	}
+
+	if (di && (fb == FB_RGB)) {
+		sz = snprintf(buf, size, "fdt set rgb default_ifmt %s;", fmt);
+		buf += sz;
+		size -= sz;
+	}
+
+	if (di && ((fb == FB_LVDS0) || (fb == FB_LVDS1))) {
+
+		sz = snprintf(buf, size, "fdt set %s fsl,data-width <%u>;",
+				ch_names[fb],
+				(di->pixfmt == IPU_PIX_FMT_RGB24) ? 24 : 18);
+		buf += sz;
+		size -= sz;
+
+		sz = snprintf(buf, size, "fdt set %s fsl,data-mapping %s;",
+				ch_names[fb],
+				(di->fbflags & FBF_JEIDA) ? "jeida" : "spwg");
+		buf += sz;
+		size -= sz;
+
+		if (di->fbflags & FBF_SPLITMODE) {
+			sz = snprintf(buf, size, "fdt set ldb split-mode 1;");
+			buf += sz;
+			size -= sz;
+		}
+	}
+
+	if (mode_str) {
+		snprintf(buf, size, "fdt set %s mode_str %s;", fbnames[fb], mode_str);
+		setenv(cmd_fbnames[fb], buf_start);
+		return;
+#ifdef CONFIG_MX6Q
+	} else if (fb == FB_RGB) {
+		sz = snprintf(buf, size, "fdt set %s mode_str eadisp_special;", fbnames[fb]);
+		buf += sz;
+		size -= sz;
+#endif
+	}
+
+	mode = &di->mode;
+	for (i = 0; i < ARRAY_SIZE(timings_properties); i++) {
+		u32 *p = (u32 *)((char *)mode + timings_offsets[i]);
+		u32 val;
+
+		if (i == 0) {
+			u64 lval = 1000000000000ULL;
+
+			do_div(lval, mode->pixclock);
+			val = (u32)lval;
+		} else {
+			val = *p;
+		}
+		sz = snprintf(buf, size, "fdt set %s %s <%u>;", timings_names[fb], timings_properties[i], val);
+		buf += sz;
+		size -= sz;
+	}
+
+	sz = snprintf(buf, size, "fdt set %s hsync-active <%u>;", timings_names[fb], (di->misc & MISC_HSYNC_ACTIVE_HIGH)?1:0);
+	buf += sz;
+	size -= sz;
+	sz = snprintf(buf, size, "fdt set %s vsync-active <%u>;", timings_names[fb], (di->misc & MISC_VSYNC_ACTIVE_HIGH)?1:0);
+	buf += sz;
+	size -= sz;
+	sz = snprintf(buf, size, "fdt set %s de-active <%u>;", timings_names[fb], (di->misc & MISC_DE_ACTIVE_HIGH)?1:0);
+	buf += sz;
+	size -= sz;
+	sz = snprintf(buf, size, "fdt set %s pixelclk-active <%u>;", timings_names[fb], (di->misc & MISC_PIXELCLK_ACTIVE_HIGH)?1:0);
+	buf += sz;
+	size -= sz;
+
+	setenv(cmd_fbnames[fb], buf_start);
+}
+
+static const struct display_info_t *select_display(
+		const struct display_info_t *gdi, int cnt)
+{
+	const char* tmp = getenv("eadisp_prefer");
+	const char* enabled;
+	const struct display_info_t* di = NULL;
+	const struct display_info_t* first = NULL;
+	char *buf = malloc(4096);
+	int preferred_idx = -1;
+	int i;
+	uint32_t enmask = 0;
+
+	/* See if a preferred display is selected */
+	if (tmp) {
+		for (i = 0; i < FB_COUNT; i++) {
+			if (!strcmp(tmp, short_names[i])) {
+				preferred_idx = i;
+				break;
+			}
+		}
+	}
+
+	/* Enable/disable displays */
+	for (i = 0; i < NUM_FBS; i++) {
+		sprintf(buf, "eadisp_%s_enabled", short_names[i]);
+		enabled = getenv(buf);
+		tmp = getenv(fbnames[i]);
+		if (tmp) {
+			di = parse_mode(g_displays, g_display_cnt, tmp, i);
+			if (di) {
+				if (enabled && !strcmp(enabled, "yes")) {
+					setup_cmd_fb(i, di, buf, 4096);
+					enmask |= (1<<i);
+					if (!first || i==preferred_idx) {
+						first = di;
+					}
+					continue;
+				}
+			}
+		}
+		// disable
+		setup_cmd_fb(i, NULL, buf, 4096);
+	}
+
+#if defined(CONFIG_MX6Q)
+	// DTS has LVDS1 as primary, change that unless LVDS1 is preferred
+	if (enmask & (1<<FB_LVDS0)) {
+		if (preferred_idx!=FB_LVDS1 || !(enmask & (1<<FB_LVDS1))) {
+			// LVDS0 is preferred over the default LVDS1
+			tmp = getenv(cmd_fbnames[FB_LVDS0]);
+			snprintf(buf, 4096, "fdt rm %s primary;fdt set %s primary;%s",
+					 ch_names[FB_LVDS1], ch_names[FB_LVDS0], tmp);
+			setenv(cmd_fbnames[FB_LVDS0], buf);
+		}
+	}
+#endif
+
+	free(buf);
+	return first;
+}
+
+static void str_mode(char *p, int size, const struct display_info_t *di)
+{
+	int count;
+	int i;
+
+	if (!di) {
+		count = snprintf(p, size, "off");
+		if (size > count) {
+			p += count;
+			size -= count;
+		}
+		*p = 0;
+		return;
+	}
+	count = snprintf(p, size, "%s:", di->mode.name);
+	if (size > count) {
+		p += count;
+		size -= count;
+	}
+	if (di->fbflags & FBF_MODESTR) {
+		*p++ = 'm';
+		size--;
+	}
+	if (di->fbflags & FBF_JEIDA) {
+		*p++ = 'j';
+		size--;
+	}
+	if (di->fbflags & FBF_SPLITMODE) {
+		*p++ = 's';
+		size--;
+	}
+	count = snprintf(p, size, "%d:", (di->pixfmt == IPU_PIX_FMT_RGB24) ? 24 : 18);
+	if (size > count) {
+		p += count;
+		size -= count;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(timings_properties); i++) {
+		u32 *src = (u32 *)((char *)&di->mode + timings_offsets[i]);
+		u32 val;
+
+		if (i == 0) {
+			u64 lval = 1000000000000ULL;
+
+			do_div(lval, di->mode.pixclock);
+			val = (u32)lval;
+		} else {
+			val = *src;
+			if (size > 1) {
+				*p++ = ',';
+				size--;
+			}
+		}
+		count = snprintf(p, size, "%d", val);
+		if (size > count) {
+			p += count;
+			size -= count;
+		}
+	}
+
+	count = snprintf(p, size, ",%d,%d,%d,%d",
+		((di->misc & MISC_HSYNC_ACTIVE_HIGH) ? 1 : 0),
+		((di->misc & MISC_VSYNC_ACTIVE_HIGH) ? 1 : 0),
+		((di->misc & MISC_DE_ACTIVE_HIGH) ? 1 : 0),
+		((di->misc & MISC_PIXELCLK_ACTIVE_HIGH) ? 1 : 0));
+	if (size > count) {
+		p += count;
+		size -= count;
+	}
+
+	*p = 0;
+}
+
+static void add_own_config(const struct display_info_t* di)
+{
+	if (di && found_own_displays < MAX_OWN_DISPLAYS) {
+		memcpy(&g_di_own[found_own_displays], di, sizeof(struct display_info_t));
+		memcpy(g_di_own_mode_str[found_own_displays], di->mode.name, strlen(di->mode.name)+1);
+		g_di_own[found_own_displays].mode.name = g_di_own_mode_str[found_own_displays];
+		found_own_displays++;
+	}
+}
+
+static void load_own_configs(void)
+{
+	int i, j;
+	char key[40];
+	char val[40];
+	const char* existing;
+	const struct display_info_t* di = NULL;
+	if (loaded_own_configs) {
+		return;
+	}
+	found_own_displays = 0;
+	for (i = 0; i < MAX_OWN_DISPLAYS; i++) {
+		sprintf(key, "eadisp_own_%d", i);
+		existing = getenv(key);
+		if (existing) {
+			for (j = 0; j < NUM_FBS; j++) {
+				sprintf(val, "%s:", short_names[j]);
+				if (!strncmp(val, existing, strlen(val))) {
+					di = parse_mode(g_displays, g_display_cnt, existing+strlen(val), j);
+					add_own_config(di);
+					break;
+				}
+			}
+		}
+	}
+	loaded_own_configs = 1;
+}
+
+static void store_own_configs(void)
+{
+	int i;
+	int saved = 0;
+	char key[40];
+	char *buf = malloc(4096);
+	for (i = 0; i < found_own_displays; i++) {
+		if (g_di_own[i].fbtype != FB_COUNT) {
+			sprintf(buf, "%s:", short_names[g_di_own[i].fbtype]);
+			str_mode(buf+strlen(buf), 256, &g_di_own[i]);
+			sprintf(key, "eadisp_own_%d", saved);
+			saved++;
+			setenv(key, buf);
+		}
+	}
+	for (i = saved; i < MAX_OWN_DISPLAYS; i++) {
+		sprintf(key, "eadisp_own_%d", i);
+		setenv(key, NULL);
+	}
+	free(buf);
+}
+
+static void print_current_config(void)
+{
+	int i;
+	char buf[50];
+	const char* msg;
+	int preferred = -1;
+
+	msg = getenv("eadisp_prefer");
+	if (msg) {
+		for (i = 0; i < NUM_FBS; i++) {
+			if (!strcmp(msg, short_names[i])) {
+				preferred = i;
+				break;
+			}
+		}
+	}
+	printf("\nCurrent Selection:\n");
+	printf("\t\tenabled\tprefer\tconfiguration\n");
+	for (i = 0; i < NUM_FBS; i++) {
+		int enabled = 0;
+		sprintf(buf, "eadisp_%s_enabled", short_names[i]);
+		msg = getenv(buf);
+		if (msg && !strcmp(msg, "yes")) {
+			enabled = 1;
+		}
+		msg = getenv(fbnames[i]);
+		printf("\t%s:\t  %s\t  %s\t%s\n", short_names[i], enabled?"yes":"no ", preferred==i?"yes":"no ", msg?msg:"Not Configured");
+	}
+}
+
+static void print_modes(const struct display_info_t *di, int cnt)
+{
+	int i;
+	char buf[256];
+
+	printf("\nAvailable display configurations:\n");
+	for (i = 0; i < cnt; i++) {
+		str_mode(buf, sizeof(buf), di+i);
+		printf("   %2d) %5s  %s\n", i, short_names[(di+i)->fbtype], buf);
+	}
+	for (i = 0; i < found_own_displays; i++) {
+		str_mode(buf, sizeof(buf), &g_di_own[i]);
+		printf("   %2d) %5s  %s\n", i+cnt, short_names[g_di_own[i].fbtype], buf);
+	}
+
+	print_current_config();
+}
+
+void board_video_enable(void)
+{
+	const struct display_info_t *di = g_di_active;
+	if (di && di->enable)
+		di->enable(di, 1);
+}
+
+static int init_display(const struct display_info_t *di)
+{
+#if defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL) || defined(CONFIG_MX7D)
+    #if defined(CONFIG_MX7D)
+	uint32_t lcdif_base_addr =  ELCDIF1_IPS_BASE_ADDR;
+    #else
+	uint32_t lcdif_base_addr = (di->fbtype==FB_RGB) ? LCDIF1_BASE_ADDR : LCDIF2_BASE_ADDR;
+    #endif
+	int bpp;
+	switch(di->pixfmt) {
+	case IPU_PIX_FMT_RGB666:
+	case IPU_PIX_FMT_BGR666:
+	case IPU_PIX_FMT_LVDS666:
+		bpp = 18;
+		break;
+	case IPU_PIX_FMT_RGB565:
+		bpp = 16;
+		break;
+	case IPU_PIX_FMT_LVDS888:
+	case IPU_PIX_FMT_BGR24:
+	case IPU_PIX_FMT_RGB24:
+		bpp = 24;
+		break;
+	default:
+		printf("LCD %s cannot be configured, invalid pixfmt 0x%08x\n",  di->mode.name, di->pixfmt);
+		return -EINVAL;
+	}
+	int ret = mxs_lcd_panel_setup(di->mode, bpp, lcdif_base_addr);
+#else
+	int ret = ipuv3_fb_init(&di->mode, 0, di->pixfmt);
+#endif
+	if (ret) {
+		printf("LCD %s cannot be configured: %d\n", di->mode.name, ret);
+		return -EINVAL;
+	}
+	printf("Display: %s:%s (%ux%u)\n", short_names[di->fbtype],
+			di->mode.name, di->mode.xres, di->mode.yres);
+	g_di_active = di;
+	board_video_enable();
+	return 0;
+}
+
+static void set_defaults(void)
+{
+	char buf[256];
+	int i, j;
+	for (i = 0; i < NUM_FBS; i++) {
+		if (!getenv(fbnames[i])) {
+			for (j = 0; j < g_display_cnt; j++) {
+				if (g_displays[j].fbtype == i) {
+					str_mode(buf, 256, &g_displays[j]);
+					setenv(fbnames[i], buf);
+					break;
+				}
+			}
+		}
+	}
+}
+
+static int do_eadisp(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int i;
+	int fb = -1;
+	int ret = CMD_RET_SUCCESS;
+	const char *cmd;
+	const char *fbname;
+	const struct display_info_t* di = g_displays;
+	int cnt = g_display_cnt;
+	char* buf;
+	load_own_configs();
+	if (argc < 2) {
+		print_modes(di, cnt);
+		return CMD_RET_SUCCESS;
+	}
+	if (argc < 3) {
+		return CMD_RET_USAGE;
+	}
+
+	cmd = argv[1];
+
+	if (!strcmp("rm", cmd)) {
+		if (argc == 3) {
+			int idx = simple_strtoul(argv[2], NULL, 10);
+			if (idx >= 0 && idx < cnt) {
+				printf("cannot remove builtin configs\n");
+				return CMD_RET_FAILURE;
+			}
+			idx = idx - cnt;
+			if (idx >= 0 && idx < found_own_displays) {
+				printf("removing %d - %s\n", idx+cnt, g_di_own[idx].mode.name);
+				g_di_own[idx].fbtype = FB_COUNT;
+				store_own_configs();
+				loaded_own_configs = 0;
+				load_own_configs();
+				return CMD_RET_SUCCESS;
+			}
+		}
+		return CMD_RET_USAGE;
+	}
+
+
+	fbname = argv[2];
+	for (i = 0; i < NUM_FBS; i++) {
+		if (!strcmp(short_names[i], fbname)) {
+			fb = i;
+			break;
+		}
+	}
+	if (fb < 0) {
+		return CMD_RET_USAGE;
+	}
+
+	buf = malloc(4096);
+	if (!buf) {
+		return -ENOMEM;
+	}
+	do {
+		if (!strcmp("prefer", cmd)) {
+			setenv("eadisp_prefer", fbname);
+			break;
+		} else if (!strcmp("enable", cmd)) {
+			sprintf(buf, "eadisp_%s_enabled", fbname);
+			setenv(buf, "yes");
+			break;
+		} else if (!strcmp("disable", cmd)) {
+			sprintf(buf, "eadisp_%s_enabled", fbname);
+			setenv(buf, "no");
+			break;
+		} else if (!strcmp("conf", cmd)) {
+			if (argc == 4) {
+				int idx = simple_strtoul(argv[3], NULL, 10);
+				if (idx >= 0 && idx < cnt) {
+					di = &g_displays[idx];
+				} else if (idx < (cnt+found_own_displays)) {
+					di = &g_di_own[idx-cnt];
+				} else {
+					printf("invalid index (%d) for %s\n", idx, fbname);
+					ret = CMD_RET_FAILURE;
+					break;
+				}
+				if (di->fbtype == fb) {
+					printf("selecting %s=%s\n", fbname, di->mode.name);
+					str_mode(buf, 256, di);
+					setenv(fbnames[fb], buf);
+					break;
+				} else {
+					printf("invalid index (%d) for %s (wrong type)\n", idx, fbname);
+					ret = CMD_RET_FAILURE;
+					break;
+				}
+			}
+		} else if (!strcmp("add", cmd)) {
+			if (argc == 4) {
+				const char *p = argv[3];
+				di = parse_mode(di, cnt, p, fb);
+				if (!di) {
+					printf("invalid format string\n");
+					ret = CMD_RET_FAILURE;
+					break;
+				}
+				if (found_own_displays < MAX_OWN_DISPLAYS) {
+					add_own_config(di);
+					store_own_configs();
+					loaded_own_configs = 0;
+					load_own_configs();
+					break;
+				} else {
+					printf("too many own configurations already - remove one and try again\n");
+					ret = CMD_RET_FAILURE;
+					break;
+				}
+			}
+		}
+		ret = CMD_RET_USAGE;
+
+	} while(0);
+	if (ret == CMD_RET_SUCCESS) {
+		// Update all variables
+		select_display(g_displays, g_display_cnt);
+		print_current_config();
+	}
+	free(buf);
+	return ret;
+}
+
+U_BOOT_CMD(eadisp, 4, 0, do_eadisp,
+		   "Configure Display Support",
+		   " - Show current configuration for all displays\n"
+		   "eadisp prefer "DISPTYPES" - Set preferred display\n"
+		   "eadisp enable "DISPTYPES" - Enable selected display\n"
+		   "eadisp disable "DISPTYPES" - Disable selected display\n"
+		   "eadisp conf "DISPTYPES" num - Select configuration for display\n"
+		   "eadisp add "DISPTYPES" [\"mode_str[:[m][j][s][18|24]:pixclkfreq,xres,yres,hback-porch,hfront-porch,vback-porch,vfront-porch,hsync,vsync,hsact,vsact,deact,clkact]\"]\n"
+		   "eadisp rm num - Remove added configuration\n");
+
+int board_video_skip(void)
+{
+	set_defaults();
+	const struct display_info_t *di = select_display(g_displays, g_display_cnt);
+
+	if (!di) {
+		return -EINVAL;
+	}
+	int ret = init_display(di);
+	return ret;
+}
+
+void eadisp_setup_display(const struct display_info_t *displays, int cnt)
+{
+	g_displays = displays;
+	g_display_cnt = cnt;
+}
diff --git a/arch/arm/imx-common/eatouch.c b/arch/arm/imx-common/eatouch.c
new file mode 100644
index 0000000..bb727f2
--- /dev/null
+++ b/arch/arm/imx-common/eatouch.c
@@ -0,0 +1,299 @@
+/*
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/eatouch.h>
+#include <asm/io.h>
+#include <div64.h>
+#include <i2c.h>
+#include <malloc.h>
+#include <stdlib.h>
+
+/*
+ * The board file should call eatouch_init() to
+ * load the selected touch controller information.
+ *
+ * The eatouch command supports enabling/disabling each available touch
+ * controller for each of the display interface connectors on the board.
+ *
+ * The eatouch command does this by setting environment variables (XX stand for
+ * rgb,lvds0,lvds1):
+ * - cmd_ts_rgb          used by cmd_ts to modify device tree for the rgb connector
+ * - cmd_ts_lvds0        used by cmd_ts to modify device tree for the lvds0 connector
+ * - cmd_ts_lvds1        used by cmd_ts to modify device tree for the lvds1 connector
+ * - cmd_ts              main command, will be executed by bootscript prior to boot
+ */
+
+#define CONNECTOR_RGB    0
+#define CONNECTOR_LVDS0  1
+#define CONNECTOR_LVDS1  2
+
+#if defined(CONFIG_MX6SX)
+  #define CONNECTORS        "(rgb|lvds0)"
+  #define NUM_CONNECTORS    2  /* Only have 1x RGB and 1x LVDS on SoloX */
+#elif defined(CONFIG_MX6Q)
+  #define CONNECTORS        "(rgb|lvds0|lvds1)"
+  #define NUM_CONNECTORS    3
+#elif defined(CONFIG_MX6DL)
+  #define CONNECTORS        "(rgb|lvds0|lvds1)"
+  #define NUM_CONNECTORS    3
+#elif defined(CONFIG_MX6UL)
+  #define CONNECTORS        "rgb"
+  #define NUM_CONNECTORS    1  /* Only have 1x RGB on UltraLite */
+#elif defined(CONFIG_MX7D)
+  #define CONNECTORS        "rgb"
+  #define NUM_CONNECTORS    1  /* Only have 1x RGB on 7 Dual */
+#else
+  #error Unsupported hardware
+#endif
+
+static const char *const cmd_names[] = {
+[CONNECTOR_RGB] = "cmd_ts_rgb",
+[CONNECTOR_LVDS0] = "cmd_ts_lvds0",
+[CONNECTOR_LVDS1] = "cmd_ts_lvds1",
+};
+
+static const char *const connector_names[] = {
+[CONNECTOR_RGB] = "rgb",
+[CONNECTOR_LVDS0] = "lvds0",
+[CONNECTOR_LVDS1] = "lvds1",
+};
+
+static const char *const short_names[] = {
+[TOUCH_AR1021] = "ar1021",
+[TOUCH_EGALAX] = "egalax",
+[TOUCH_FT5X06] = "ft5x06",
+[TOUCH_ILITEK] = "ilitek",
+[TOUCH_SITRONIX] = "sitronix",
+};
+
+static struct touch_info_t controllers[NUM_CONNECTORS][TOUCH_COUNT] = {
+	{ EATOUCH_ALL_CONTROLLERS(rgb)   },
+#if NUM_CONNECTORS > 1
+	{ EATOUCH_ALL_CONTROLLERS(lvds0) },
+#if NUM_CONNECTORS > 2
+	{ EATOUCH_ALL_CONTROLLERS(lvds1) },
+#endif
+#endif
+};
+
+#define TOUCH_DISABLED  (-1)
+#define TOUCH_ENV_CMD   "cmd_ts"
+#define TOUCH_ENV_SEL   "eatouch_selected"
+
+
+static void print_current_config(void)
+{
+	int i, j;
+
+	printf("\nCurrent Setup:\n");
+	printf("\t%10s\t", "");
+	for (i = 0; i < NUM_CONNECTORS; i++) {
+		printf("  %s conn.\t", connector_names[i]);
+	}
+	printf("\n");
+
+	for (i = 0; i < TOUCH_COUNT; i++) {
+		printf("\t%10s", short_names[i]);
+		for (j = 0; j < NUM_CONNECTORS; j++) {
+			if (controllers[j][i].enabled) {
+				printf("\tEnabled 0x%02x", controllers[j][i].addr);
+			} else {
+				printf("\t  Disabled");
+			}
+		}
+		printf("\n");
+	}
+}
+
+static void print_status(void)
+{
+	int i;
+
+	printf("\nAvailable Touch Controllers:\n");
+	for (i = 0; i < TOUCH_COUNT; i++) {
+		printf("   %2d) %s\n", i+1, short_names[i]);
+	}
+
+	print_current_config();
+}
+
+static void load_selection(void)
+{
+	int i, j;
+	int valid = 0;
+	const char* env = getenv(TOUCH_ENV_SEL);
+	if (env) {
+		valid = 1;
+		for (i = 0; i < NUM_CONNECTORS; i++) {
+			for (j = 0; j < TOUCH_COUNT; j++) {
+				if (*env == 'E') {
+					controllers[i][j].enabled = 1;
+					env++;
+				} else if (*env == '-') {
+					controllers[i][j].enabled = 0;
+					env++;
+				} else {
+					printf("Illegal touch configuration, turning all off\n");
+					setenv(TOUCH_ENV_SEL, NULL);
+					valid = 0;
+					break;
+				}
+			}
+			if (!valid) {
+				break;
+			}
+		}
+	}
+
+	if (!valid) {
+		for (i = 0; i < NUM_CONNECTORS; i++) {
+			for (j = 0; j < TOUCH_COUNT; j++) {
+				controllers[i][j].enabled = 0;
+			}
+		}
+	}
+}
+
+static void save_selection(void)
+{
+	char buf[NUM_CONNECTORS * TOUCH_COUNT + 1];
+	int i, j;
+	char* p = &buf[0];
+
+	for (i = 0; i < NUM_CONNECTORS; i++) {
+		for (j = 0; j < TOUCH_COUNT; j++) {
+			if (controllers[i][j].enabled) {
+				*p++ = 'E';
+			} else {
+				*p++ = '-';
+			}
+		}
+	}
+	*p = '\0';
+	setenv(TOUCH_ENV_SEL, buf);
+}
+
+static void update_commands(void)
+{
+	char* buf = malloc(4096);
+	char* p;
+	int i, j, count;
+	int size;
+
+	if (!buf) {
+		printf("Failed to allocate memory for eatouch command\n");
+	}
+
+	for (i = 0; i < NUM_CONNECTORS; i++) {
+		p = buf;
+		size = 4096;
+		for (j = 0; j < TOUCH_COUNT; j++) {
+			if (controllers[i][j].enabled) {
+				count = snprintf(p, size, "fdt set %s status okay; fdt set %s reg <0x%x>; ", controllers[i][j].alias, controllers[i][j].alias, controllers[i][j].addr);
+			} else {
+				count = snprintf(p, size, "fdt set %s status disabled; ", controllers[i][j].alias);
+			}
+			p += count;
+			size -= count;
+		}
+		setenv(cmd_names[i], buf);
+	}
+	p = buf;
+	size = 4096;
+	for (i = 0; i < NUM_CONNECTORS; i++) {
+		count = snprintf(p, size, "run %s; ", cmd_names[i]);
+		p += count;
+		size -= count;
+	}
+	setenv(TOUCH_ENV_CMD, buf);
+
+	free(buf);
+}
+
+static int do_eatouch(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int i;
+	const char *cmd;
+
+	if (argc == 1) {
+		print_status();
+		return CMD_RET_SUCCESS;
+	}
+	if (argc < 3) {
+		return CMD_RET_USAGE;
+	}
+
+	cmd = argv[1];
+
+	if (!strcmp("enable", cmd) || !strcmp("disable", cmd)) {
+		int enable = !strcmp("enable", cmd);
+		if (argc == 4) {
+			for (i = 0; i < NUM_CONNECTORS; i++) {
+				if (!strcmp(argv[2], connector_names[i])) {
+					int idx = simple_strtoul(argv[3], NULL, 10);
+					//printf("'%s', '%s', '%s', '%s' (%d)\n", argv[0], argv[1], argv[2], argv[3], idx);
+					if (idx >= 1 && idx <= TOUCH_COUNT) {
+						controllers[i][idx-1].enabled = enable;
+					} else {
+						printf("Invalid controller number '%s', should be 1<=num<=%d\n", argv[3], TOUCH_COUNT);
+					}
+					save_selection();
+					update_commands();
+					print_current_config();
+					return CMD_RET_SUCCESS;
+				}
+			}
+			printf("Invalid display interface connector name '%s'\n", argv[2]);
+		}
+		return CMD_RET_USAGE;
+	}
+
+	// Hidden command to change i2c address for a controller. Will not survive a reboot/reset
+	// so the mod command must be followed by a 'boot' command to take effect.
+	if (!strcmp("mod", cmd)) {
+		if (argc == 4) {
+			int ctrl = simple_strtoul(argv[2], NULL, 10);
+			if (ctrl >= 1 && ctrl <= TOUCH_COUNT) {
+				ctrl--;
+				int addr = simple_strtoul(argv[3], NULL, 10);
+				if (addr >= 0x01 && addr <= 0xff) {
+					int conn;
+					printf("Changing I2C address of %s to 0x%x\n", short_names[ctrl], addr);
+					for (conn = 0; conn < NUM_CONNECTORS; conn++) {
+						controllers[conn][ctrl].addr = addr;
+					}
+					save_selection();
+					update_commands();
+					print_current_config();
+					return CMD_RET_SUCCESS;
+				} else {
+					printf("Invalid i2c addr '%s', should be 0x01<=num<=0xff\n", argv[3]);
+				}
+			} else {
+				printf("Invalid controller number '%s', should be 1<=num<=%d\n", argv[2], TOUCH_COUNT);
+			}
+		}
+		printf("usage:\n\teatouch mod num newaddr\n");
+		return CMD_RET_FAILURE;
+	}
+
+	return CMD_RET_USAGE;
+}
+
+
+U_BOOT_CMD(eatouch, 4, 0, do_eatouch,
+		   "Configure Touch Controller Support for each display interface connector",
+		   " - Show current configuration\n"
+		   "eatouch disable "CONNECTORS" num - Disable touch controller from list for connector\n"
+		   "eatouch enable "CONNECTORS" num - Enable touch controller from list for connector\n");
+
+
+void eatouch_init(void)
+{
+	load_selection();
+	update_commands();
+}
diff --git a/arch/arm/imx-common/spl.c b/arch/arm/imx-common/spl.c
index ac6e40e..83e34e9 100644
--- a/arch/arm/imx-common/spl.c
+++ b/arch/arm/imx-common/spl.c
@@ -58,6 +58,51 @@ u32 spl_boot_device(void)
 	}
 	return BOOT_DEVICE_NONE;
 }
+#elif defined(CONFIG_MX7)
+
+/* determine boot device from SRC_SBMR1 (BOOT_CFG[4:1]) or SRC_GPR9 register */
+u32 spl_boot_device(void)
+{
+        struct src *psrc = (struct src *)SRC_BASE_ADDR;
+        unsigned int gpr10_boot = readl(&psrc->gpr10) & (1 << 28);
+        unsigned reg = gpr10_boot ? readl(&psrc->gpr9) : readl(&psrc->sbmr1);
+
+        /* BOOT_CFG[15:12] - see IMX7DRM Table 6-33 */
+        switch ((reg & 0x0000F000) >> 12) {
+	/* SD/eSD/SDXC: */
+	case 0x1:
+		return BOOT_DEVICE_MMC1;
+
+	/* MMC/eMMC */
+	case 0x2:
+		return BOOT_DEVICE_MMC1;
+
+	/* NAND Flash */
+	case 0x3:
+		return BOOT_DEVICE_NAND;
+
+	/* QSPI */
+	case 0x4:
+		// TODO
+		break;
+
+	/* NOR/OneNAND (EIM) */
+	case 0x5:
+		// BOOT_CFG[11]: NOR/OneNAND selection */
+		if ((reg & 0x00000800) >> 11)
+			return BOOT_DEVICE_ONENAND;
+		else
+			return BOOT_DEVICE_NOR; 
+		break;
+
+	/* Serial ROM (SPI) */
+	case 0x6:
+		return BOOT_DEVICE_SPI;
+
+        }
+        return BOOT_DEVICE_NONE;
+}
+
 #endif
 
 #if defined(CONFIG_SPL_MMC_SUPPORT)
diff --git a/arch/arm/include/asm/imx-common/eadisp.h b/arch/arm/include/asm/imx-common/eadisp.h
new file mode 100644
index 0000000..2e284a1
--- /dev/null
+++ b/arch/arm/include/asm/imx-common/eadisp.h
@@ -0,0 +1,398 @@
+/*
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __EADISP_H_
+#define __EADISP_H_
+
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+
+struct display_info_t {
+	int	bus;	/* (bus >> 8) is gpio to enable bus if <>0 */
+	int	addr;
+	int	pixfmt;
+	int	(*detect)(struct display_info_t const *dev);
+	void	(*enable)(struct display_info_t const *dev, int enable);
+
+#define FB_RGB		0
+#define FB_LVDS0	1
+#define FB_LVDS1	2
+#define FB_HDMI		3
+#define FB_COUNT	4
+	int	fbtype;
+
+#define FBF_MODESTR		1
+#define FBF_JEIDA		2
+#define FBF_SPLITMODE	4
+	int	fbflags;
+
+#define MISC_HSYNC_ACTIVE_HIGH     1
+#define MISC_VSYNC_ACTIVE_HIGH     2
+#define MISC_DE_ACTIVE_HIGH        4
+#define MISC_PIXELCLK_ACTIVE_HIGH  8
+	int 	misc;
+
+	struct	fb_videomode mode;
+};
+
+void board_enable_hdmi(const struct display_info_t *di, int enable);
+void board_enable_lcd(const struct display_info_t *di, int enable);
+void board_enable_lvds0(const struct display_info_t *di, int enable);
+void board_enable_lvds1(const struct display_info_t *di, int enable);
+
+void eadisp_enable_fb(struct display_info_t const *di, int enable);
+int eadisp_detect_i2c(struct display_info_t const *di);
+void eadisp_setup_display(const struct display_info_t *displays, int cnt);
+
+/* LVDS settings */
+#define EADISP_HANNSTAR10(_mode, _detect, _bus) \
+{\
+	.bus	= _bus,\
+	.addr	= 0x4,\
+	.pixfmt	= IPU_PIX_FMT_RGB666,\
+	.detect	= _detect ? eadisp_detect_i2c : NULL,\
+	.enable	= eadisp_enable_fb,\
+	.fbtype = FB_##_mode,\
+	.mode	= {\
+		.name           = "hannstar",\
+		.refresh        = 60,\
+		.xres           = 1024,\
+		.yres           = 768,\
+		.pixclock       = 1000000000000ULL/((1024+220+40+60)*(768+21+7+10)*60),\
+		.left_margin    = 220,\
+		.right_margin   = 40,\
+		.upper_margin   = 21,\
+		.lower_margin   = 7,\
+		.hsync_len      = 60,\
+		.vsync_len      = 10,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+/* RGB settings */
+#define EADISP_INNOLUX_AT070TN(_mode, _detect, _bus) \
+{\
+	.bus	= _bus,\
+	.addr	= 0,\
+	.pixfmt	= IPU_PIX_FMT_RGB24,\
+	.detect	= _detect ? eadisp_detect_i2c : NULL,\
+	.enable	= eadisp_enable_fb,\
+	.fbtype = FB_##_mode,\
+	.fbflags = 0,\
+	.misc   = MISC_DE_ACTIVE_HIGH,\
+	.mode	= {\
+		.name           = "Innolux-AT070TN",\
+		.refresh        = 49,\
+		.xres           = 800,\
+		.yres           = 480,\
+		.pixclock       = 1000000000000ULL/((800+89+164+10)*(480+75+75+10)*49),\
+		.left_margin    = 89,\
+		.right_margin   = 164,\
+		.upper_margin   = 75,\
+		.lower_margin   = 75,\
+		.hsync_len      = 10,\
+		.vsync_len      = 10,\
+		.sync           = 0,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define EADISP_NHD_43480272EF(_mode, _detect, _bus) \
+{\
+	.bus	= _bus,\
+	.addr	= 0,\
+	.pixfmt	= IPU_PIX_FMT_RGB24,\
+	.detect	= _detect ? eadisp_detect_i2c : NULL,\
+	.enable	= eadisp_enable_fb,\
+	.fbtype = FB_##_mode,\
+	.fbflags = 0,\
+	.misc   = MISC_DE_ACTIVE_HIGH,\
+	.mode	= {\
+		.name           = "nhd-4.3-480272ef",\
+		.refresh        = 60,\
+		.xres           = 480,\
+		.yres           = 272,\
+		.pixclock       = 1000000000000ULL/((480+2+2+41)*(272+2+2+10)*60),\
+		.left_margin    = 2,\
+		.right_margin   = 2,\
+		.upper_margin   = 2,\
+		.lower_margin   = 2,\
+		.hsync_len      = 41,\
+		.vsync_len      = 10,\
+		.sync           = 0,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define EADISP_NHD_50800480TF(_mode, _detect, _bus) \
+{\
+	.bus	= _bus,\
+	.addr	= 0,\
+	.pixfmt	= IPU_PIX_FMT_RGB24,\
+	.detect	= _detect ? eadisp_detect_i2c : NULL,\
+	.enable	= eadisp_enable_fb,\
+	.fbtype = FB_##_mode,\
+	.fbflags = 0,\
+	.misc   = MISC_DE_ACTIVE_HIGH,\
+	.mode	= {\
+		.name           = "nhd-5.0-800480tf",\
+		.refresh        = 62,\
+		.xres           = 800,\
+		.yres           = 480,\
+		.pixclock       = 1000000000000ULL/((800+40+40+48)*(480+29+13+3)*60),\
+		.left_margin    = 40,\
+		.right_margin   = 40,\
+		.upper_margin   = 29,\
+		.lower_margin   = 13,\
+		.hsync_len      = 48,\
+		.vsync_len      = 3,\
+		.sync           = 0,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define EADISP_NHD_70800480EF(_mode, _detect, _bus) \
+{\
+	.bus	= _bus,\
+	.addr	= 0,\
+	.pixfmt	= IPU_PIX_FMT_RGB24,\
+	.detect	= _detect ? eadisp_detect_i2c : NULL,\
+	.enable	= eadisp_enable_fb,\
+	.fbtype = FB_##_mode,\
+	.fbflags = 0,\
+	.misc   = MISC_DE_ACTIVE_HIGH,\
+	.mode	= {\
+		.name           = "nhd-7.0-800480ef",\
+		.refresh        = 62,\
+		.xres           = 800,\
+		.yres           = 480,\
+		.pixclock       = 1000000000000ULL/((800+40+40+48)*(480+29+13+3)*60),\
+		.left_margin    = 40,\
+		.right_margin   = 40,\
+		.upper_margin   = 29,\
+		.lower_margin   = 13,\
+		.hsync_len      = 48,\
+		.vsync_len      = 3,\
+		.sync           = 0,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define EADISP_UMSH_8864(_mode, _detect, _bus) \
+{\
+	.bus	= _bus,\
+	.addr	= 0,\
+	.pixfmt	= IPU_PIX_FMT_RGB24,\
+	.detect	= _detect ? eadisp_detect_i2c : NULL,\
+	.enable	= eadisp_enable_fb,\
+	.fbtype = FB_##_mode,\
+	.fbflags = 0,\
+	.misc   = MISC_DE_ACTIVE_HIGH,\
+	.mode	= {\
+		.name           = "umsh-8864",\
+		.refresh        = 55,\
+		.xres           = 480,\
+		.yres           = 272,\
+		.pixclock       = 1000000000000ULL/((480+20+20+3)*(272+20+20+3)*55),\
+		.left_margin    = 20,\
+		.right_margin   = 20,\
+		.upper_margin   = 20,\
+		.lower_margin   = 20,\
+		.hsync_len      = 3,\
+		.vsync_len      = 3,\
+		.sync           = 0,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define EADISP_UMSH_8596_30T(_mode, _detect, _bus) \
+{\
+	.bus	= _bus,\
+	.addr	= 0,\
+	.pixfmt	= IPU_PIX_FMT_RGB24,\
+	.detect	= _detect ? eadisp_detect_i2c : NULL,\
+	.enable	= eadisp_enable_fb,\
+	.fbtype = FB_##_mode,\
+	.fbflags = 0,\
+	.misc   = MISC_DE_ACTIVE_HIGH + MISC_PIXELCLK_ACTIVE_HIGH,\
+	.mode	= {\
+		.name           = "umsh-8596-30t",\
+		.refresh        = 60,\
+		.xres           = 800,\
+		.yres           = 480,\
+		.pixclock       = 1000000000000ULL/((800+128+120+8)*(480+20+20+5)*60),\
+		.left_margin    = 128,\
+		.right_margin   = 120,\
+		.upper_margin   = 20,\
+		.lower_margin   = 20,\
+		.hsync_len      = 8,\
+		.vsync_len      = 5,\
+		.sync           = 0,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define EADISP_UMSH_8596_33T(_mode, _detect, _bus) \
+{\
+	.bus	= _bus,\
+	.addr	= 0,\
+	.pixfmt	= IPU_PIX_FMT_RGB24,\
+	.detect	= _detect ? eadisp_detect_i2c : NULL,\
+	.enable	= eadisp_enable_fb,\
+	.fbtype = FB_##_mode,\
+	.fbflags = 0,\
+	.misc   = MISC_DE_ACTIVE_HIGH + MISC_PIXELCLK_ACTIVE_HIGH,\
+	.mode	= {\
+		.name           = "umsh-8596-33t",\
+		.refresh        = 48,\
+		.xres           = 800,\
+		.yres           = 480,\
+		.pixclock       = 1000000000000ULL/((800+200+200+1)*(480+45+45+1)*48),\
+		.left_margin    = 200,\
+		.right_margin   = 200,\
+		.upper_margin   = 45,\
+		.lower_margin   = 45,\
+		.hsync_len      = 1,\
+		.vsync_len      = 1,\
+		.sync           = 0,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define EADISP_ROGIN_RX050A(_mode, _detect, _bus) \
+{\
+	.bus	= _bus,\
+	.addr	= 0,\
+	.pixfmt	= IPU_PIX_FMT_RGB24,\
+	.detect	= _detect ? eadisp_detect_i2c : NULL,\
+	.enable	= eadisp_enable_fb,\
+	.fbtype = FB_##_mode,\
+	.fbflags = 0,\
+	.misc   = MISC_DE_ACTIVE_HIGH,\
+	.mode	= {\
+		.name           = "rogin-rx050a",\
+		.refresh        = 48,\
+		.xres           = 800,\
+		.yres           = 480,\
+		.pixclock       = 1000000000000ULL/((800+200+200+1)*(480+45+45+1)*48),\
+		.left_margin    = 200,\
+		.right_margin   = 200,\
+		.upper_margin   = 45,\
+		.lower_margin   = 45,\
+		.hsync_len      = 1,\
+		.vsync_len      = 1,\
+		.sync           = 0,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+/* hdmi settings */
+#define EADISP_HDMI_1280_720M_60(_mode, _detect, _bus) \
+{\
+	.bus	= _bus,\
+	.addr	= 0x50,\
+	.pixfmt	= IPU_PIX_FMT_RGB24,\
+	.detect	= _detect ? eadisp_detect_i2c : NULL,\
+	.enable	= eadisp_enable_fb,\
+	.fbtype = FB_##_mode,\
+	.fbflags = FBF_MODESTR,\
+	.mode	= {\
+		.name           = "1280x720M@60",\
+		.refresh        = 60,\
+		.xres           = 1280,\
+		.yres           = 720,\
+		.pixclock       = 1000000000000ULL/((1280+216+72+80)*(720+22+3+5)*60),\
+		.left_margin    = 220,\
+		.right_margin   = 110,\
+		.upper_margin   = 20,\
+		.lower_margin   = 5,\
+		.hsync_len      = 40,\
+		.vsync_len      = 5,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+
+#define EADISP_HDMI_1920_1080M_60(_mode, _detect, _bus) \
+{\
+	.bus	= _bus,\
+	.addr	= 0x50,\
+	.pixfmt	= IPU_PIX_FMT_RGB24,\
+	.detect	= _detect ? eadisp_detect_i2c : NULL,\
+	.enable	= eadisp_enable_fb,\
+	.fbtype = FB_##_mode,\
+	.fbflags = FBF_MODESTR,\
+	.mode	= {\
+		.name           = "1920x1080M@60",\
+		.refresh        = 60,\
+		.xres           = 1920,\
+		.yres           = 1080,\
+		.pixclock       = 1000000000000ULL/((1920+148+88+44)*(1080+36+4+5)*60),\
+		.left_margin    = 148,\
+		.right_margin   = 88,\
+		.upper_margin   = 36,\
+		.lower_margin   = 4,\
+		.hsync_len      = 44,\
+		.vsync_len      = 5,\
+		.sync           = 0,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define EADISP_HDMI_640_480M_60(_mode, _detect, _bus) \
+{\
+	.bus	= _bus,\
+	.addr	= 0x50,\
+	.pixfmt	= IPU_PIX_FMT_RGB24,\
+	.detect	= _detect ? eadisp_detect_i2c : NULL,\
+	.enable	= eadisp_enable_fb,\
+	.fbtype = FB_##_mode,\
+	.fbflags = FBF_MODESTR,\
+	.mode	= {\
+		.name           = "640x480M@60",\
+		.refresh        = 60,\
+		.xres           = 640,\
+		.yres           = 480,\
+		.pixclock       = 1000000000000ULL/((640+48+16+96)*(480+33+10+2)*60),\
+		.left_margin    = 48,\
+		.right_margin   = 16,\
+		.upper_margin   = 33,\
+		.lower_margin   = 10,\
+		.hsync_len      = 96,\
+		.vsync_len      = 2,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define EADISP_HDMI_720_480M_60(_mode, _detect, _bus) \
+{\
+	.bus	= _bus,\
+	.addr	= 0x50,\
+	.pixfmt	= IPU_PIX_FMT_RGB24,\
+	.detect	= _detect ? eadisp_detect_i2c : NULL,\
+	.enable	= eadisp_enable_fb,\
+	.fbtype = FB_##_mode,\
+	.fbflags = FBF_MODESTR,\
+	.mode	= {\
+		.name           = "720x480M@60",\
+		.refresh        = 60,\
+		.xres           = 720,\
+		.yres           = 480,\
+		.pixclock       = 1000000000000ULL/((720+60+16+62)*(480+30+9+6)*60),\
+		.left_margin    = 60,\
+		.right_margin   = 16,\
+		.upper_margin   = 30,\
+		.lower_margin   = 9,\
+		.hsync_len      = 62,\
+		.vsync_len      = 6,\
+		.sync           = 0,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+
+#endif /* __EADISP_H_ */
diff --git a/arch/arm/include/asm/imx-common/eatouch.h b/arch/arm/include/asm/imx-common/eatouch.h
new file mode 100644
index 0000000..63d8c67
--- /dev/null
+++ b/arch/arm/include/asm/imx-common/eatouch.h
@@ -0,0 +1,41 @@
+/*
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __EATOUCH_H_
+#define __EATOUCH_H_
+
+
+struct touch_info_t {
+	int     enabled;
+	int	    addr;
+
+#define TOUCH_AR1021    0
+#define TOUCH_ILITEK    1
+#define TOUCH_SITRONIX  2
+#define TOUCH_EGALAX    3
+#define TOUCH_FT5X06    4
+#define TOUCH_COUNT     5
+	int	    type;
+
+	const char* alias;
+};
+
+void eatouch_init(void);
+
+#define EATOUCH_CONTROLLER(_conn, _addr, _type, _tname) \
+{ \
+	.enabled = 0, \
+	.addr	 = _addr, \
+	.type	 = _type,\
+	.alias	 = "ts_con_" #_conn "/" #_tname "_" #_conn \
+}
+
+#define EATOUCH_ALL_CONTROLLERS(_conn) \
+	EATOUCH_CONTROLLER(_conn, 0x4d, TOUCH_AR1021,   ar1021),\
+	EATOUCH_CONTROLLER(_conn, 0x41, TOUCH_ILITEK,   ilitek_aim),\
+	EATOUCH_CONTROLLER(_conn, 0x55, TOUCH_SITRONIX, sitronix),\
+	EATOUCH_CONTROLLER(_conn, 0x04, TOUCH_EGALAX,   egalax_ts),\
+	EATOUCH_CONTROLLER(_conn, 0x38, TOUCH_FT5X06,   edt-ft5x06)
+
+#endif /* __EATOUCH_H_ */
diff --git a/board/embeddedartists/common/Makefile b/board/embeddedartists/common/Makefile
new file mode 100644
index 0000000..f703052
--- /dev/null
+++ b/board/embeddedartists/common/Makefile
@@ -0,0 +1,15 @@
+#
+# Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
+#
+# (C) Copyright 2011 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+
+obj-y  += mx6ea_eeprom.o
+obj-y  += mx6ea-com_spl.o
+ifdef CONFIG_FSL_FASTBOOT
+obj-${CONFIG_ANDROID_RECOVERY} += recovery.o
+endif
+
diff --git a/board/embeddedartists/common/bootscript.txt b/board/embeddedartists/common/bootscript.txt
new file mode 100644
index 0000000..704da53
--- /dev/null
+++ b/board/embeddedartists/common/bootscript.txt
@@ -0,0 +1,70 @@
+setenv args_from_script ''
+
+#if load ${dtype} ${disk}:1 ${a_script} uEnv.txt ; then
+#    env import -t ${a_script} ${filesize}
+#fi
+
+
+if run loadfdt ; then
+	fdt addr ${fdt_addr}
+	setenv fdt_high 0xffffffff
+else
+	echo "!!!! Error loading ${fdt_file}";
+	exit;
+fi
+	
+
+fdt resize
+if itest.s "x" != "x${cmd_custom}" ; then
+	run cmd_custom
+fi
+
+if itest.s "x" != "x${cmd_hdmi}" ; then
+	run cmd_hdmi
+	if itest.s x == x${allow_noncea} ; then
+		setenv args_from_script ${args_from_script} mxc_hdmi.only_cea=1;
+		echo "only CEA modes allowed on HDMI port";
+	else
+		setenv args_from_script ${args_from_script} mxc_hdmi.only_cea=0;
+		echo "non-CEA modes allowed on HDMI, audio may be affected";
+	fi
+fi
+
+if itest.s "x" != "x${cmd_rgb}" ; then
+	run cmd_rgb
+fi
+if itest.s "x" != "x${cmd_lvds0}" ; then
+	run cmd_lvds0
+fi
+if itest.s "x" != "x${cmd_lvds1}" ; then
+	run cmd_lvds1
+fi
+
+if itest.s "x" != "x${cmd_ts}" ; then
+	run cmd_ts
+fi
+
+if itest.s "x" != "x${extra_bootargs}" ; then
+	setenv args_from_script "${args_from_script} ${extra_bootargs}"
+fi
+
+if itest.s "x" != "x${show_fdt}" ; then
+	fdt print /
+fi
+
+if itest.s "x" != "x${show_env}" ; then
+	printenv
+fi
+
+if itest.s "x" != "x${skip_booting}" ; then
+	echo "!!!! Selected to skip booting !!!!";
+	echo "!!!! Unset skip_booting variable to enable booting again !!!!";
+	exit;
+fi
+
+if run loadimage; then
+	run mmcargs;
+	bootz ${loadaddr} - ${fdt_addr}
+fi
+
+echo "Error loading kernel image"
diff --git a/board/embeddedartists/common/mx6ea-com_spl.c b/board/embeddedartists/common/mx6ea-com_spl.c
new file mode 100644
index 0000000..6ae8f6c
--- /dev/null
+++ b/board/embeddedartists/common/mx6ea-com_spl.c
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2015 Embedded Artists AB
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/sys_proto.h>
+
+#include <spl.h>
+
+
+#if defined(CONFIG_SPL_BUILD)
+
+#include "mx6ea_eeprom.h"
+
+
+void spl_board_init(void)
+{
+
+	// must be called to get correct clock for MMC/SD
+	get_clocks();
+
+	// called to setup I2C mux
+	board_early_init_f();
+
+	preloader_console_init();
+
+	// initialize dram based on data from eeprom
+	if (ea_eeprom_dram_init() != 0) {
+		hang();
+	}
+
+}
+
+
+
+#endif
diff --git a/board/embeddedartists/common/mx6ea_eeprom.c b/board/embeddedartists/common/mx6ea_eeprom.c
new file mode 100644
index 0000000..a742cdc
--- /dev/null
+++ b/board/embeddedartists/common/mx6ea_eeprom.c
@@ -0,0 +1,571 @@
+/*
+ * Copyright (C) 2015 Embedded Artists AB
+ *
+ * Configuration parameters stored in EEPROM for the Embedded Artists 
+ * i.MX COM Board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/sys_proto.h>
+#include <i2c.h>
+
+#include "mx6ea_eeprom.h"
+struct ea_ddr_cfg
+{
+	u32 addr;
+	u32 val;
+};
+
+#define EA_DDR_LIST_BUF_SZ (16)
+static struct ea_ddr_cfg ddr_list_buf[EA_DDR_LIST_BUF_SZ];
+
+/*
+ * Default values for DDR initialization in case eeprom data 
+ * couldn't be read
+ */
+static struct ea_ddr_cfg ddr_init_default[] = {
+#if defined(CONFIG_MX6SX)
+	{0x020e0618, 0x000c0000},
+	{0x020e05fc, 0x00000000},
+
+	{0x020e032c, 0x00000030},
+
+	{0x020e0300, 0x00000020},
+	{0x020e02fc, 0x00000020},
+	{0x020e05f4, 0x00000020},
+
+	{0x020e0340, 0x00000020},
+
+	{0x020e0320, 0x00000000},
+	{0x020e0310, 0x00000020},
+	{0x020e0314, 0x00000020},
+	{0x020e0614, 0x00000020},
+
+	{0x020e05f8, 0x00020000},
+	{0x020e0330, 0x00000028},
+	{0x020e0334, 0x00000028},
+	{0x020e0338, 0x00000028},
+	{0x020e033c, 0x00000028},
+
+	{0x020e0608, 0x00020000},
+	{0x020e060c, 0x00000028},
+	{0x020e0610, 0x00000028},
+	{0x020e061c, 0x00000028},
+	{0x020e0620, 0x00000028},
+	{0x020e02ec, 0x00000028},
+	{0x020e02f0, 0x00000028},
+	{0x020e02f4, 0x00000028},
+	{0x020e02f8, 0x00000028},
+
+	{0x021b0800, 0xa1390003},
+
+	{0x021b080c, 0x002b0025},
+	{0x021b0810, 0x00290024},
+
+	{0x021b083c, 0x4153014B},
+	{0x021b0840, 0x013E0132},
+
+	{0x021b0848, 0x43434549},
+	{0x021b0850, 0x36363A35},
+
+	{0x021b081c, 0x33333333},
+	{0x021b0820, 0x33333333},
+	{0x021b0824, 0x33333333},
+	{0x021b0828, 0x33333333},
+
+	{0x021b08b8, 0x00000800},
+
+	{0x021b0004, 0x0002002d},
+	{0x021b0008, 0x00333030},
+	{0x021b000c, 0x676b52f3},
+	{0x021b0010, 0xb66d8b63},
+	{0x021b0014, 0x01ff00db},
+	{0x021b0018, 0x00011740},
+	{0x021b001c, 0x00008000},
+	{0x021b002c, 0x000026d2},
+	{0x021b0030, 0x006b1023},
+	{0x021b0040, 0x0000005f},
+	{0x021b0000, 0x84190000},
+
+	{0x021b001c, 0x04008032},
+	{0x021b001c, 0x00008033},
+	{0x021b001c, 0x00048031},
+	{0x021b001c, 0x05208030},
+	{0x021b001c, 0x04008040},
+
+	{0x021b0020, 0x00000800},
+	{0x021b0818, 0x00011117},
+	{0x021b001c, 0x00000000},
+
+#elif defined(CONFIG_MX6Q)
+	{0x020e0798, 0x000C0000},
+	{0x020e0758, 0x00000000},
+	{0x020e0588, 0x00000030},
+	{0x020e0594, 0x00000030},
+	{0x020e056c, 0x00000030},
+	{0x020e0578, 0x00000030},
+	{0x020e074c, 0x00000030},
+	{0x020e057c, 0x00000030},
+	{0x020e058c, 0x00000000},
+	{0x020e059c, 0x00000030},
+	{0x020e05a0, 0x00000030},
+	{0x020e078c, 0x00000030},
+	{0x020e0750, 0x00020000},
+	{0x020e05a8, 0x00000028},
+	{0x020e05b0, 0x00000028},
+	{0x020e0524, 0x00000028},
+	{0x020e051c, 0x00000028},
+	{0x020e0518, 0x00000028},
+	{0x020e050c, 0x00000028},
+	{0x020e05b8, 0x00000028},
+	{0x020e05c0, 0x00000028},
+	{0x020e0774, 0x00020000},
+	{0x020e0784, 0x00000028},
+	{0x020e0788, 0x00000028},
+	{0x020e0794, 0x00000028},
+	{0x020e079c, 0x00000028},
+	{0x020e07a0, 0x00000028},
+	{0x020e07a4, 0x00000028},
+	{0x020e07a8, 0x00000028},
+	{0x020e0748, 0x00000028},
+	{0x020e05ac, 0x00000028},
+	{0x020e05b4, 0x00000028},
+	{0x020e0528, 0x00000028},
+	{0x020e0520, 0x00000028},
+	{0x020e0514, 0x00000028},
+	{0x020e0510, 0x00000028},
+	{0x020e05bc, 0x00000028},
+	{0x020e05c4, 0x00000028},
+	{0x021b0800, 0xa1390003},
+	{0x021b080c, 0x001F0018},
+	{0x021b0810, 0x0023001F},
+	{0x021b480c, 0x000F001F},
+	{0x021b4810, 0x0006001D},
+	{0x021b083c, 0x43340344},
+	{0x021b0840, 0x03300328},
+	{0x021b483c, 0x432C0340},
+	{0x021b4840, 0x03300274},
+	{0x021b0848, 0x3A303232},
+	{0x021b4848, 0x36362E3E},
+	{0x021b0850, 0x32343E3C},
+	{0x021b4850, 0x4032463E},
+	{0x021b081c, 0x33333333},
+	{0x021b0820, 0x33333333},
+	{0x021b0824, 0x33333333},
+	{0x021b0828, 0x33333333},
+	{0x021b481c, 0x33333333},
+	{0x021b4820, 0x33333333},
+	{0x021b4824, 0x33333333},
+	{0x021b4828, 0x33333333},
+	{0x021b08b8, 0x00000800},
+	{0x021b48b8, 0x00000800},
+	{0x021b0004, 0x00020036},
+	{0x021b0008, 0x09444040},
+	{0x021b000c, 0x8A8F7955},
+	{0x021b0010, 0xFF328F64},
+	{0x021b0014, 0x01FF00DB},
+	{0x021b0018, 0x00001740},
+	{0x021b001c, 0x00008000},
+	{0x021b002c, 0x000026d2},
+	{0x021b0030, 0x008F1023},
+	{0x021b0040, 0x00000047},
+	{0x021b0000, 0x841A0000},
+// ---------------------------------->
+	/*{0x021b001c, 0x04088032},
+	{0x021b001c, 0x00008033},
+	{0x021b001c, 0x00048031},
+	{0x021b001c, 0x09408030},
+	{0x021b001c, 0x04008040},*/
+// <----------------------------------
+	{0x021b0020, 0x00005800},
+	{0x021b0818, 0x00011117},
+	{0x021b4818, 0x00011117},
+	{0x021b0004, 0x00025576},
+	{0x021b0404, 0x00011006},
+	{0x021b001c, 0x00000000},
+	{0x020c4068, 0x00C03F3F},
+	{0x020c406c, 0x0030FC03},
+	{0x020c4070, 0x0FFFC000},
+	{0x020c4074, 0x3FF00000},
+	{0x020c4078, 0x00FFF300},
+	{0x020c407c, 0x0F0000F3},
+	{0x020c4080, 0x000003FF},
+	{0x020e0010, 0xF00000CF},
+	{0x020e0018, 0x007F007F},
+	{0x020e001c, 0x007F007F},
+	{0x020c4060, 0x000000fb},
+
+#elif defined(CONFIG_MX6DL)
+        {0x020e0774, 0x000C0000},
+        {0x020e0754, 0x00000000},
+        {0x020e04ac, 0x00000030},
+        {0x020e04b0, 0x00000030},
+        {0x020e0464, 0x00000030},
+        {0x020e0490, 0x00000030},
+        {0x020e074c, 0x00000030},
+        {0x020e0494, 0x00000030},
+        {0x020e04a0, 0x00000000},
+        {0x020e04b4, 0x00000030},
+        {0x020e04b8, 0x00000030},
+        {0x020e076c, 0x00000030},
+        {0x020e0750, 0x00020000},
+        {0x020e04bc, 0x00000030},
+        {0x020e04c0, 0x00000030},
+        {0x020e04c4, 0x00000030},
+        {0x020e04c8, 0x00000030},
+        {0x020e04cc, 0x00000030},
+        {0x020e04d0, 0x00000030},
+        {0x020e04d4, 0x00000030},
+        {0x020e04d8, 0x00000030},
+        {0x020e0760, 0x00020000},
+        {0x020e0764, 0x00000030},
+        {0x020e0770, 0x00000030},
+        {0x020e0778, 0x00000030},
+        {0x020e077c, 0x00000030},
+        {0x020e0780, 0x00000030},
+        {0x020e0784, 0x00000030},
+        {0x020e078c, 0x00000030},
+        {0x020e0748, 0x00000030},
+        {0x020e0470, 0x00000030},
+        {0x020e0474, 0x00000030},
+        {0x020e0478, 0x00000030},
+        {0x020e047c, 0x00000030},
+        {0x020e0480, 0x00000030},
+        {0x020e0484, 0x00000030},
+        {0x020e0488, 0x00000030},
+        {0x020e048c, 0x00000030},
+        {0x021b0800, 0xa1390003},
+        {0x021b080c, 0x004E004E},
+        {0x021b0810, 0x0042004A},
+        {0x021b480c, 0x002D0030},
+        {0x021b4810, 0x002C0045},
+        {0x021b083c, 0x42460244},
+        {0x021b0840, 0x02300230},
+        {0x021b483c, 0x422C0238},
+        {0x021b4840, 0x021E0222},
+        {0x021b0848, 0x44464848},
+        {0x021b4848, 0x42484842},
+        {0x021b0850, 0x342E2A32},
+        {0x021b4850, 0x362E322A},
+        {0x021b081c, 0x33333333},
+        {0x021b0820, 0x33333333},
+        {0x021b0824, 0x33333333},
+        {0x021b0828, 0x33333333},
+        {0x021b481c, 0x33333333},
+        {0x021b4820, 0x33333333},
+        {0x021b4824, 0x33333333},
+        {0x021b4828, 0x33333333},
+        {0x021b08b8, 0x00000800},
+        {0x021b48b8, 0x00000800},
+        {0x021b0004, 0x0002002D},
+        {0x021b0008, 0x00333030},
+        {0x021b000c, 0x3F435313},
+        {0x021b0010, 0xB66E8B63},
+        {0x021b0014, 0x01FF00DB},
+        {0x021b0018, 0x00011740},
+        {0x021b001c, 0x00008000},
+        {0x021b002c, 0x000026d2},
+        {0x021b0030, 0x00431023},
+        {0x021b0040, 0x00000027},
+        {0x021b0000, 0x831A0000},
+/*
+        {0x021b001c, 0x04008032},
+        {0x021b001c, 0x00008033},
+        {0x021b001c, 0x00048031},
+        {0x021b001c, 0x05208030},
+*/
+        {0x021b0020, 0x00005800},
+        {0x021b0818, 0x00011117},
+        {0x021b4818, 0x00011117},
+        {0x021b0004, 0x0002556D},
+        {0x021b0404, 0x00011006},
+        {0x021b001c, 0x00000000},
+        {0x020c4068, 0x00C03F3F},
+        {0x020c406c, 0x0030FC03},
+        {0x020c4070, 0x0FFFC000},
+        {0x020c4074, 0x3FF00000},
+        {0x020c4078, 0x00FFF300},
+        {0x020c407c, 0x0F0000C3},
+        {0x020c4080, 0x000003FF},
+        {0x020e0010, 0xF00000CF},
+        {0x020e0018, 0x007F007F},
+        {0x020e001c, 0x007F007F},
+
+#elif defined(CONFIG_MX6UL)
+
+	{0x020c4068, 0xffffffff},
+	{0x020c406c, 0xffffffff},
+	{0x020c4070, 0xffffffff},
+	{0x020c4074, 0xffffffff},
+	{0x020c4078, 0xffffffff},
+	{0x020c407c, 0xffffffff},
+	{0x020c4080, 0xffffffff},
+	{0x020c4084, 0xffffffff},
+	{0x020E04B4, 0x000C0000},
+	{0x020E04AC, 0x00000000},
+	{0x020E027C, 0x00000008},
+	{0x020E0250, 0x00000030},
+	{0x020E024C, 0x00000030},
+	{0x020E0490, 0x00000030},
+	{0x020E0288, 0x00000030},
+	{0x020E0270, 0x00000000},
+	{0x020E0260, 0x00000030},
+	{0x020E0264, 0x00000030},
+	{0x020E04A0, 0x00000030},
+	{0x020E0494, 0x00020000},
+	{0x020E0280, 0x00000038},
+	{0x020E0284, 0x00000030},
+	{0x020E04B0, 0x00020000},
+	{0x020E0498, 0x00000030},
+	{0x020E04A4, 0x00000030},
+	{0x020E0244, 0x00000030},
+	{0x020E0248, 0x00000030},
+	{0x021B001C, 0x00008000},
+	{0x021B0800, 0xA1390003},
+	{0x021B080C, 0x00090000},
+	{0x021B083C, 0x41540154},
+	{0x021B0848, 0x40404442},
+	{0x021B0850, 0x40405450},
+	{0x021B081C, 0x33333333},
+	{0x021B0820, 0x33333333},
+	{0x021B082C, 0xf3333333},
+	{0x021B0830, 0xf3333333},
+	{0x021B08C0, 0x00922012},
+	{0x021B0858, 0x00000F00},
+	{0x021B08b8, 0x00000800},
+	{0x021B0004, 0x0002002D},
+	{0x021B0008, 0x1B333000},
+
+	{0x021B000C, 0x676B54F3},
+	{0x021B0010, 0xB68E0A83},
+	{0x021B0014, 0x01FF00DB},
+	{0x021B0018, 0x00211740},
+	{0x021B001C, 0x00008000},
+	{0x021B002C, 0x000026D2},
+	{0x021B0030, 0x006B1023},
+	{0x021B0040, 0x0000004F},
+	{0x021B0000, 0x84180000},
+// ------> NOK
+/*	{0x021B001C, 0x02008032},
+	{0x021B001C, 0x00008033},
+	{0x021B001C, 0x00048031},
+	{0x021B001C, 0x15208030},
+	{0x021B001C, 0x04008040},*/
+// <----- NOK
+	{0x021B0020, 0x00000800},
+	{0x021B0818, 0x00000227},
+	{0x021B0004, 0x0002552D},
+	{0x021B0404, 0x00011006},
+	{0x021B001C, 0x00000000},
+
+#elif defined(CONFIG_MX7D) && defined(CONFIG_TARGET_MX7DEA_UCOM)
+        {0x30340004, 0x4F400005},
+        {0x30391000, 0x00000002},
+        {0x307a0000, 0x01040008},
+        {0x307A0064, 0x00200038},
+        {0x307a0490, 0x00000001},
+        {0x307A00D0, 0x00350001},
+        {0x307A00DC, 0x00C3000A},
+        {0x307A00E0, 0x00010000},
+        {0x307A00E4, 0x00110006},
+        {0x307A00F4, 0x0000033F},
+        {0x307A0100, 0x0A0E110B},
+        {0x307A0104, 0x00020211},
+        {0x307A0108, 0x03060708},
+        {0x307A010C, 0x00A0500C},
+        {0x307A0110, 0x05020307},
+        {0x307A0114, 0x02020404},
+        {0x307A0118, 0x02020003},
+        {0x307A011C, 0x00000202},
+        {0x307A0120, 0x00000202},
+        {0x307A0180, 0x00600018},
+        {0x307A0184, 0x00E00100},
+        {0x307A0190, 0x02098205},
+        {0x307A0194, 0x00060303},
+        {0x307A01A0, 0x80400003},
+        {0x307A01A4, 0x00100020},
+        {0x307A01A8, 0x80100004},
+        {0x307A0200, 0x00000016},
+        {0x307A0204, 0x00171717},
+        {0x307A0210, 0x00000F0F},
+        {0x307A0214, 0x04040404},
+        {0x307A0218, 0x0F040404},
+        {0x307A0240, 0x06000600},
+        {0x307A0244, 0x00000000},
+        {0x30391000, 0x00000000},
+        {0x30790000, 0x17421e40},
+        {0x30790004, 0x10210100},
+        {0x30790008, 0x00010000},
+        {0x30790010, 0x0007080C},
+        {0x307900b0, 0x1010007e},
+        {0x3079001C, 0x01010000},
+        {0x3079009c, 0x00000b24},
+        {0x30790020, 0x0A0A0A0A},
+        {0x30790030, 0x06060606},
+        {0x30790050, 0x01000008},
+        {0x30790050, 0x00000008},
+        {0x30790018, 0x0000000F},
+        {0x307900c0, 0x0C487304},
+        {0x307900c0, 0x0C4C7304},
+        {0x307900c0, 0x0C4C7306},
+        {0x307900C0, 0x0C4C7304},
+        {0x30384130, 0x00000000},
+        {0x30340020, 0x00000178},
+        {0x30384130, 0x00000002},
+
+#elif defined(CONFIG_MX7D) && defined(CONFIG_TARGET_MX7DEA_COM)
+
+	{0x30340004, 0x4F400005},
+	{0x30391000, 0x00000002},
+	{0x307a0000, 0x01040001},
+	{0x307a01a0, 0x80400003},
+	{0x307a01a4, 0x00100020},
+	{0x307a01a8, 0x80100004},
+	{0x307a0064, 0x0040005e},
+	{0x307a0490, 0x00000001},
+	{0x307a00d0, 0x00020001},
+	{0x307a00d4, 0x00010000},
+	{0x307a00dc, 0x09300004},
+	{0x307a00e0, 0x04080000},
+	{0x307a00e4, 0x00090004},
+	{0x307a00f4, 0x0000033f},
+	{0x307a0100, 0x0908120a},
+	{0x307a0104, 0x0002020e},
+	{0x307a0108, 0x03040407},
+	{0x307a010c, 0x00002006},
+	{0x307a0110, 0x04020204},
+	{0x307a0114, 0x03030202},
+	{0x307a0120, 0x03030803},
+	{0x307a0180, 0x00800020},
+	{0x307a0190, 0x02098204},
+	{0x307a0194, 0x00030303},
+	{0x307a0200, 0x00000016},
+	{0x307a0204, 0x00171717},
+	{0x307a0214, 0x04040404},
+	{0x307a0218, 0x00040404},
+	{0x307a0240, 0x06000601},
+	{0x307a0244, 0x00001323},
+	{0x30391000, 0x00000000},
+	{0x30790000, 0x17420f40},
+	{0x30790004, 0x10210100},
+	{0x30790010, 0x00060807},
+	{0x307900b0, 0x1010007e},
+	{0x3079009c, 0x00000d6e},
+	{0x30790020, 0x08080808},
+	{0x30790030, 0x08080808},
+	{0x30790050, 0x01000010},
+	{0x30790050, 0x00000010},
+	{0x307900c0, 0x0e407304},
+	{0x307900c0, 0x0e447304},
+	{0x307900c0, 0x0e447306},
+	{0x307900c0, 0x0e447304},
+	{0x307900c0, 0x0e407304},
+	{0x30384130, 0x00000000},
+	{0x30340020, 0x00000178},
+	{0x30384130, 0x00000002},
+	{0x30790018, 0x0000000f},
+
+#else
+
+#error "Unknown SOC"
+
+#endif
+};
+
+
+
+int ea_eeprom_init(void)
+{
+	i2c_set_bus_num(EA_EEPROM_I2C_BUS);
+	i2c_init(CONFIG_SYS_I2C_SPEED, EA_EEPROM_I2C_SLAVE);
+
+	return 0;
+}
+
+
+int ea_eeprom_get_config(ea_eeprom_config_t* config)
+{
+
+	if (i2c_probe(EA_EEPROM_I2C_SLAVE)) {
+		return -1;
+	}
+
+	
+	if (i2c_read(EA_EEPROM_I2C_SLAVE, 
+		0, 
+		2, 
+		(uint8_t *)config, 
+		sizeof(ea_eeprom_config_t))) 
+	{
+		return -2;
+	}
+
+	if (config->magic != EA_EEPROM_MAGIC) {
+		return -3;
+	}
+
+	return 0;
+}
+
+static int intern_dram_init(void)
+{
+	ea_eeprom_config_t config;
+	int toRead = 0;
+	int haveRead = 0;
+	int i;
+	volatile u32 *reg_ptr;	
+
+	if (ea_eeprom_get_config(&config) != 0) {
+		return -1;
+	}
+
+	do {
+		toRead = config.num_reg_value_pairs;
+		if (toRead > EA_DDR_LIST_BUF_SZ)
+			toRead = EA_DDR_LIST_BUF_SZ;
+
+		if (i2c_read(EA_EEPROM_I2C_SLAVE, 
+			sizeof(ea_eeprom_config_t)+haveRead*sizeof(struct ea_ddr_cfg), 
+			2, 
+			(uint8_t *)ddr_list_buf, 
+			toRead*sizeof(struct ea_ddr_cfg))) 
+		{
+			return -2;
+		}	
+
+		config.num_reg_value_pairs -= toRead;
+		haveRead += toRead;
+
+		for (i = 0; i < toRead; i++) {
+			reg_ptr = (volatile u32 *)ddr_list_buf[i].addr;
+			*reg_ptr = ddr_list_buf[i].val;
+		}
+
+
+
+	} while(config.num_reg_value_pairs > 0);
+
+	return 0;
+}
+
+
+int ea_eeprom_dram_init(void)
+{
+	int i = 0;
+	volatile u32 *reg_ptr;
+
+	if (intern_dram_init() != 0) {
+
+		// try with default values if we failed with eeprom data
+		for(i = 0; i < sizeof(ddr_init_default)/sizeof(struct ea_ddr_cfg); i++)
+		{
+			reg_ptr = (volatile u32 *)ddr_init_default[i].addr;
+			*reg_ptr = ddr_init_default[i].val;
+		}
+	}
+
+	return 0;
+}
diff --git a/board/embeddedartists/common/mx6ea_eeprom.h b/board/embeddedartists/common/mx6ea_eeprom.h
new file mode 100644
index 0000000..c0936aa
--- /dev/null
+++ b/board/embeddedartists/common/mx6ea_eeprom.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2015 Embedded Artists AB
+ *
+ * Configuration parameters stored in EEPROM for the Embedded Artists 
+ * i.MX 6 COM Board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX6SXEA_EEPROM_H
+#define __MX6SXEA_EEPROM_H
+
+
+#define EA_EEPROM_I2C_BUS   0
+#define EA_EEPROM_I2C_SLAVE 0x55
+
+#define EA_EEPROM_MAGIC 0xEA434F4D
+
+typedef struct {
+	uint32_t magic;
+	uint8_t  config_version;
+	uint32_t board_part_nr;
+	uint8_t  board_rev[4];
+	uint32_t batch;
+	uint8_t  name[32];
+	uint8_t  mac1[6];
+	uint8_t  mac2[6];
+	uint8_t  mac3[6];
+	uint8_t  mac4[6];
+	uint32_t ddr_size;
+	uint32_t num_reg_value_pairs;	
+	uint8_t  reserved[3];
+} __attribute__((__packed__)) ea_eeprom_config_t;
+
+int ea_eeprom_init(void);
+int ea_eeprom_get_config(ea_eeprom_config_t* config);
+int ea_eeprom_dram_init(void);
+
+#endif
+
diff --git a/board/embeddedartists/common/recovery.c b/board/embeddedartists/common/recovery.c
new file mode 100644
index 0000000..e6f2137
--- /dev/null
+++ b/board/embeddedartists/common/recovery.c
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2010-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <malloc.h>
+#include <recovery.h>
+#ifdef CONFIG_MXC_KPD
+#include <mxc_keyb.h>
+#endif
+#include <asm/imx-common/boot_mode.h>
+
+#ifdef CONFIG_MXC_KPD
+#define PRESSED_VOL_DOWN	0x01
+#define PRESSED_POWER	    0x02
+#define RECOVERY_KEY_MASK (PRESSED_VOL_DOWN | PRESSED_POWER)
+
+inline int test_key(int value, struct kpp_key_info *ki)
+{
+	return (ki->val == value) && (ki->evt == KDepress);
+}
+
+int check_key_pressing(void)
+{
+	struct kpp_key_info *key_info = NULL;
+	int state = 0, keys, i;
+
+	int ret = 0;
+
+	mxc_kpp_init();
+	/* due to glitch suppression circuit,
+	   wait sometime to let all keys scanned. */
+	udelay(1000);
+	keys = mxc_kpp_getc(&key_info);
+
+	printf("Detecting VOL_DOWN+POWER key for recovery(%d:%d) ...\n",
+		keys, keys ? key_info->val : 0);
+	if (keys > 1) {
+		for (i = 0; i < keys; i++) {
+			if (test_key(CONFIG_POWER_KEY, &key_info[i]))
+				state |= PRESSED_POWER;
+			else if (test_key(CONFIG_VOL_DOWN_KEY, &key_info[i]))
+				state |= PRESSED_VOL_DOWN;
+		}
+	}
+	if ((state & RECOVERY_KEY_MASK) == RECOVERY_KEY_MASK)
+		ret = 1;
+	if (key_info)
+		free(key_info);
+	return ret;
+}
+#else
+/* If not using mxc keypad, currently we will detect power key on board */
+int check_key_pressing(void)
+{
+	return 0;
+}
+#endif
+
+void setup_recovery_env(void)
+{
+	board_recovery_setup();
+}
+
+/* export to lib_arm/board.c */
+void check_recovery_mode(void)
+{
+	if (check_key_pressing()) {
+		puts("Fastboot: Recovery key pressing got!\n");
+		setup_recovery_env();
+	} else if (check_recovery_cmd_file()) {
+		puts("Fastboot: Recovery command file found!\n");
+		setup_recovery_env();
+	} else {
+		puts("Fastboot: Normal\n");
+	}
+}
diff --git a/board/embeddedartists/mx6qea-com/Kconfig b/board/embeddedartists/mx6qea-com/Kconfig
new file mode 100644
index 0000000..d22e2e0
--- /dev/null
+++ b/board/embeddedartists/mx6qea-com/Kconfig
@@ -0,0 +1,15 @@
+if TARGET_MX6QEA_COM
+
+config SYS_BOARD
+	default "mx6qea-com"
+
+config SYS_VENDOR
+	default "embeddedartists"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "mx6qea-com"
+
+endif
diff --git a/board/embeddedartists/mx6qea-com/MAINTAINERS b/board/embeddedartists/mx6qea-com/MAINTAINERS
new file mode 100644
index 0000000..e95ad2e
--- /dev/null
+++ b/board/embeddedartists/mx6qea-com/MAINTAINERS
@@ -0,0 +1,6 @@
+MX6ULEA-COM BOARD
+M:	Andreas Rebert <imx@embeddedartists.com>
+S:	Maintained
+F:	board/embeddedartists/mx6qea-com/
+F:	include/configs/mx6qea-com.h
+F:	configs/mx6qea-com_defconfig
diff --git a/board/embeddedartists/mx6qea-com/Makefile b/board/embeddedartists/mx6qea-com/Makefile
new file mode 100644
index 0000000..280c3ab
--- /dev/null
+++ b/board/embeddedartists/mx6qea-com/Makefile
@@ -0,0 +1,13 @@
+#
+# Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
+#
+# (C) Copyright 2011 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx6qea-com.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff --git a/board/embeddedartists/mx6qea-com/imximage.cfg b/board/embeddedartists/mx6qea-com/imximage.cfg
new file mode 100644
index 0000000..707cbd0
--- /dev/null
+++ b/board/embeddedartists/mx6qea-com/imximage.cfg
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2011-2014 Freescale Semiconductor, Inc.
+ * Jason Liu <r64343@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of spi, sd, sata
+ * the board has no nand and eimnor
+ * spinor: flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ */
+
+/* the same flash_offset as sd */
+BOOT_FROM      sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sabresd/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF 0x2000
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+DATA 4, 0x020e0798, 0x000C0000
+DATA 4, 0x020e0758, 0x00000000
+DATA 4, 0x020e0588, 0x00000030
+DATA 4, 0x020e0594, 0x00000030
+DATA 4, 0x020e056c, 0x00000030
+DATA 4, 0x020e0578, 0x00000030
+DATA 4, 0x020e074c, 0x00000030
+DATA 4, 0x020e057c, 0x00000030
+DATA 4, 0x020e058c, 0x00000000
+DATA 4, 0x020e059c, 0x00000030
+DATA 4, 0x020e05a0, 0x00000030
+DATA 4, 0x020e078c, 0x00000030
+DATA 4, 0x020e0750, 0x00020000
+DATA 4, 0x020e05a8, 0x00000028
+DATA 4, 0x020e05b0, 0x00000028
+DATA 4, 0x020e0524, 0x00000028
+DATA 4, 0x020e051c, 0x00000028
+DATA 4, 0x020e0518, 0x00000028
+DATA 4, 0x020e050c, 0x00000028
+DATA 4, 0x020e05b8, 0x00000028
+DATA 4, 0x020e05c0, 0x00000028
+DATA 4, 0x020e0774, 0x00020000
+DATA 4, 0x020e0784, 0x00000028
+DATA 4, 0x020e0788, 0x00000028
+DATA 4, 0x020e0794, 0x00000028
+DATA 4, 0x020e079c, 0x00000028
+DATA 4, 0x020e07a0, 0x00000028
+DATA 4, 0x020e07a4, 0x00000028
+DATA 4, 0x020e07a8, 0x00000028
+DATA 4, 0x020e0748, 0x00000028
+DATA 4, 0x020e05ac, 0x00000028
+DATA 4, 0x020e05b4, 0x00000028
+DATA 4, 0x020e0528, 0x00000028
+DATA 4, 0x020e0520, 0x00000028
+DATA 4, 0x020e0514, 0x00000028
+DATA 4, 0x020e0510, 0x00000028
+DATA 4, 0x020e05bc, 0x00000028
+DATA 4, 0x020e05c4, 0x00000028
+DATA 4, 0x021b0800, 0xa1390003
+DATA 4, 0x021b080c, 0x001F001F
+DATA 4, 0x021b0810, 0x001F001F
+DATA 4, 0x021b480c, 0x001F001F
+DATA 4, 0x021b4810, 0x001F001F
+DATA 4, 0x021b083c, 0x43340344
+DATA 4, 0x021b0840, 0x03300328
+DATA 4, 0x021b483c, 0x432C0340
+DATA 4, 0x021b4840, 0x03300274
+DATA 4, 0x021b0848, 0x3A303232
+DATA 4, 0x021b4848, 0x36362E3E
+DATA 4, 0x021b0850, 0x32343E3C
+DATA 4, 0x021b4850, 0x4032463E
+DATA 4, 0x021b081c, 0x33333333
+DATA 4, 0x021b0820, 0x33333333
+DATA 4, 0x021b0824, 0x33333333
+DATA 4, 0x021b0828, 0x33333333
+DATA 4, 0x021b481c, 0x33333333
+DATA 4, 0x021b4820, 0x33333333
+DATA 4, 0x021b4824, 0x33333333
+DATA 4, 0x021b4828, 0x33333333
+DATA 4, 0x021b08b8, 0x00000800
+DATA 4, 0x021b48b8, 0x00000800
+DATA 4, 0x021b0004, 0x00020036
+DATA 4, 0x021b0008, 0x09444040
+DATA 4, 0x021b000c, 0x8A8F7955
+DATA 4, 0x021b0010, 0xFF328F64
+DATA 4, 0x021b0014, 0x01FF00DB
+DATA 4, 0x021b0018, 0x00001740
+DATA 4, 0x021b001c, 0x00008000
+DATA 4, 0x021b002c, 0x000026d2
+DATA 4, 0x021b0030, 0x008F1023
+DATA 4, 0x021b0040, 0x00000047
+DATA 4, 0x021b0000, 0x841A0000
+
+DATA 4, 0x021b001c, 0x04088032
+DATA 4, 0x021b001c, 0x00008033
+DATA 4, 0x021b001c, 0x00048031
+DATA 4, 0x021b001c, 0x09408030
+DATA 4, 0x021b001c, 0x04008040
+
+DATA 4, 0x021b0020, 0x00005800
+DATA 4, 0x021b0818, 0x00011117
+DATA 4, 0x021b4818, 0x00011117
+DATA 4, 0x021b0004, 0x00025576
+DATA 4, 0x021b0404, 0x00011006
+DATA 4, 0x021b001c, 0x00000000
+
+/* set the default clock gate to save power */
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0x00FFF300
+DATA 4, 0x020c407c, 0x0F0000F3
+DATA 4, 0x020c4080, 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+
+/*
+ * Setup CCM_CCOSR register as follows:
+ *
+ * cko1_en  = 1	   --> CKO1 enabled
+ * cko1_div = 111  --> divide by 8
+ * cko1_sel = 1011 --> ahb_clk_root
+ *
+ * This sets CKO1 at ahb_clk_root/8 = 132/8 = 16.5 MHz
+ */
+DATA 4, 0x020c4060, 0x000000fb
+#endif
diff --git a/board/embeddedartists/mx6qea-com/imximage_mx6dl.cfg b/board/embeddedartists/mx6qea-com/imximage_mx6dl.cfg
new file mode 100644
index 0000000..103dd3f
--- /dev/null
+++ b/board/embeddedartists/mx6qea-com/imximage_mx6dl.cfg
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+
+BOOT_FROM	sd
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN board/freescale/mx6sabresd/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+DATA 4	0x020e0774 0x000C0000
+DATA 4	0x020e0754 0x00000000
+DATA 4	0x020e04ac 0x00000030
+DATA 4	0x020e04b0 0x00000030
+DATA 4	0x020e0464 0x00000030
+DATA 4	0x020e0490 0x00000030
+DATA 4	0x020e074c 0x00000030
+DATA 4	0x020e0494 0x00000030
+DATA 4	0x020e04a0 0x00000000
+DATA 4	0x020e04b4 0x00000030
+DATA 4	0x020e04b8 0x00000030
+DATA 4	0x020e076c 0x00000030
+DATA 4	0x020e0750 0x00020000
+DATA 4	0x020e04bc 0x00000030
+DATA 4	0x020e04c0 0x00000030
+DATA 4	0x020e04c4 0x00000030
+DATA 4	0x020e04c8 0x00000030
+DATA 4	0x020e04cc 0x00000030
+DATA 4	0x020e04d0 0x00000030
+DATA 4	0x020e04d4 0x00000030
+DATA 4	0x020e04d8 0x00000030
+DATA 4	0x020e0760 0x00020000
+DATA 4	0x020e0764 0x00000030
+DATA 4	0x020e0770 0x00000030
+DATA 4	0x020e0778 0x00000030
+DATA 4	0x020e077c 0x00000030
+DATA 4	0x020e0780 0x00000030
+DATA 4	0x020e0784 0x00000030
+DATA 4	0x020e078c 0x00000030
+DATA 4	0x020e0748 0x00000030
+DATA 4	0x020e0470 0x00000030
+DATA 4	0x020e0474 0x00000030
+DATA 4	0x020e0478 0x00000030
+DATA 4	0x020e047c 0x00000030
+DATA 4	0x020e0480 0x00000030
+DATA 4	0x020e0484 0x00000030
+DATA 4	0x020e0488 0x00000030
+DATA 4	0x020e048c 0x00000030
+DATA 4	0x021b0800 0xa1390003
+/* ANDLI: modded according to DDR Stress test */
+DATA 4	0x021b080c 0x004E004E
+DATA 4	0x021b0810 0x0042004A
+DATA 4	0x021b480c 0x002D0030
+DATA 4	0x021b4810 0x002C0045
+DATA 4	0x021b083c 0x42460244
+DATA 4	0x021b0840 0x02300230
+DATA 4	0x021b483c 0x422C0238
+DATA 4	0x021b4840 0x021E0222
+DATA 4	0x021b0848 0x44464848
+DATA 4	0x021b4848 0x42484842
+DATA 4	0x021b0850 0x342E2A32
+DATA 4	0x021b4850 0x362E322A
+/* ANDLI: end of mod */
+DATA 4	0x021b081c 0x33333333
+DATA 4	0x021b0820 0x33333333
+DATA 4	0x021b0824 0x33333333
+DATA 4	0x021b0828 0x33333333
+DATA 4	0x021b481c 0x33333333
+DATA 4	0x021b4820 0x33333333
+DATA 4	0x021b4824 0x33333333
+DATA 4	0x021b4828 0x33333333
+DATA 4	0x021b08b8 0x00000800
+DATA 4	0x021b48b8 0x00000800
+DATA 4	0x021b0004 0x0002002D
+DATA 4	0x021b0008 0x00333030
+DATA 4	0x021b000c 0x3F435313
+DATA 4	0x021b0010 0xB66E8B63
+DATA 4	0x021b0014 0x01FF00DB
+/* ANDLI: modded according to DDR Stress test */
+DATA 4	0x021b0018 0x00011740
+/* ANDLI: end of mod */
+DATA 4	0x021b001c 0x00008000
+DATA 4	0x021b002c 0x000026d2
+DATA 4	0x021b0030 0x00431023
+DATA 4	0x021b0040 0x00000027
+DATA 4	0x021b0000 0x831A0000
+DATA 4	0x021b001c 0x04008032
+DATA 4	0x021b001c 0x00008033
+DATA 4	0x021b001c 0x00048031
+DATA 4	0x021b001c 0x05208030
+DATA 4 0x021b001c 0x04008040
+DATA 4	0x021b0020 0x00005800
+DATA 4	0x021b0818 0x00011117
+DATA 4	0x021b4818 0x00011117
+DATA 4	0x021b0004 0x0002556D
+DATA 4	0x021b0404 0x00011006
+DATA 4	0x021b001c 0x00000000
+
+/* set the default clock gate to save power */
+DATA 4 0x020c4068 0x00C03F3F
+DATA 4 0x020c406c 0x0030FC03
+DATA 4 0x020c4070 0x0FFFC000
+DATA 4 0x020c4074 0x3FF00000
+DATA 4 0x020c4078 0x00FFF300
+DATA 4 0x020c407c 0x0F0000C3
+DATA 4 0x020c4080 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4 0x020e0010 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4 0x020e0018 0x007F007F
+DATA 4 0x020e001c 0x007F007F
+#endif
diff --git a/board/embeddedartists/mx6qea-com/mx6qea-com.c b/board/embeddedartists/mx6qea-com/mx6qea-com.c
new file mode 100644
index 0000000..64e4ada
--- /dev/null
+++ b/board/embeddedartists/mx6qea-com/mx6qea-com.c
@@ -0,0 +1,1779 @@
+/*
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
+ *
+ * Author: Fabio Estevam <fabio.estevam@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#if defined(CONFIG_CMD_EADISP)
+#include <asm/imx-common/eadisp.h>
+#include <asm/imx-common/eatouch.h>
+#endif
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <miiphy.h>
+#include <netdev.h>
+
+#if defined(CONFIG_MX6DL) && defined(CONFIG_MXC_EPDC)
+#include <lcd.h>
+#include <mxc_epdc_fb.h>
+#endif
+#include <asm/arch/mxc_hdmi.h>
+#include <asm/arch/crm_regs.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/io.h>
+#include <asm/arch/sys_proto.h>
+#ifdef CONFIG_SYS_I2C_MXC
+#include <i2c.h>
+#include <asm/imx-common/mxc_i2c.h>
+#endif
+#include <usb.h>
+#ifdef CONFIG_CMD_SATA
+#include <asm/imx-common/sata.h>
+#endif
+#ifdef CONFIG_FSL_FASTBOOT
+#include <fsl_fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FSL_FASTBOOT*/
+
+#include "../common/mx6ea_eeprom.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED | \
+		      PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define EPDC_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+
+iomux_v3_cfg_t const peri_pwr_pads[] = {
+	(MX6_PAD_GPIO_17__GPIO7_IO12 | MUX_PAD_CTRL(NO_PAD_CTRL)),
+	/* enable USB Host 5V. Doesn't seem to get this to work in Linux/DTS */
+	(MX6_PAD_GPIO_0__GPIO1_IO00 | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 PMIC, EEPROM */
+
+struct i2c_pads_info i2c_pad_info0 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_CSI0_DAT9__I2C1_SCL | PC,
+		.gpio_mode = MX6_PAD_CSI0_DAT9__GPIO5_IO27 | PC,
+		.gp = IMX_GPIO_NR(5, 27)
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_CSI0_DAT8__I2C1_SDA | PC,
+		.gpio_mode = MX6_PAD_CSI0_DAT8__GPIO5_IO26 | PC,
+		.gp = IMX_GPIO_NR(5, 26)
+	}
+};
+
+
+#endif
+
+int dram_init(void)
+{
+	ea_eeprom_config_t config;
+
+	// default size from configuration file
+	gd->ram_size = PHYS_SDRAM_SIZE;
+
+	// getting actual size from eeprom configuration
+
+	if (ea_eeprom_get_config(&config) == 0) {
+		/* ddr_size is given in MB */
+		gd->ram_size = (config.ddr_size << 20);
+	}
+
+	return 0;
+}
+
+iomux_v3_cfg_t const uart1_pads[] = {
+	MX6_PAD_CSI0_DAT10__UART1_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_CSI0_DAT11__UART1_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+iomux_v3_cfg_t const enet_pads[] = {
+	MX6_PAD_ENET_MDIO__ENET_MDIO		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET_MDC__ENET_MDC		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TXC__RGMII_TXC	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD0__RGMII_TD0	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD1__RGMII_TD1	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD2__RGMII_TD2	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD3__RGMII_TD3	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TX_CTL__RGMII_TX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET_REF_CLK__ENET_TX_CLK	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RXC__RGMII_RXC	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD0__RGMII_RD0	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD1__RGMII_RD1	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD2__RGMII_RD2	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD3__RGMII_RD3	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RX_CTL__RGMII_RX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	/* AR8031 PHY Reset */
+	MX6_PAD_ENET_CRS_DV__GPIO1_IO25		| MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* enet pwr en */
+	MX6_PAD_GPIO_18__GPIO7_IO13		| MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_iomux_enet(void)
+{
+	imx_iomux_v3_setup_multiple_pads(enet_pads, ARRAY_SIZE(enet_pads));
+
+	/* enet pwr en */
+	gpio_direction_output(IMX_GPIO_NR(7, 13) , 0);
+	udelay(1000);
+
+	/* Reset AR8031 PHY */
+	gpio_direction_output(IMX_GPIO_NR(1, 25) , 0);
+	udelay(500);
+	gpio_set_value(IMX_GPIO_NR(1, 25), 1);
+}
+
+iomux_v3_cfg_t const usdhc2_pads[] = {
+	MX6_PAD_SD2_CLK__SD2_CLK	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_CMD__SD2_CMD	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DAT0__SD2_DATA0	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DAT1__SD2_DATA1	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DAT2__SD2_DATA2	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DAT3__SD2_DATA3	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* CD pin */
+	MX6_PAD_NANDF_WP_B__GPIO6_IO09	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* SD PWR Reset */
+	MX6_PAD_SD3_RST__GPIO7_IO08     | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+iomux_v3_cfg_t const usdhc3_pads[] = {
+	MX6_PAD_SD3_CLK__SD3_CLK   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_CMD__SD3_CMD   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT0__SD3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT1__SD3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT2__SD3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT3__SD3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT4__SD3_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT5__SD3_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT6__SD3_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT7__SD3_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+iomux_v3_cfg_t const usdhc4_pads[] = {
+	MX6_PAD_SD4_CLK__SD4_CLK   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_CMD__SD4_CMD   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT0__SD4_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT1__SD4_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT2__SD4_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT3__SD4_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT4__SD4_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT5__SD4_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT6__SD4_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT7__SD4_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+#ifdef CONFIG_SYS_USE_SPINOR
+iomux_v3_cfg_t const ecspi1_pads[] = {
+	MX6_PAD_EIM_D16__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_EIM_D17__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_EIM_D18__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_EIM_EN2__GPIO2_IO30 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_spinor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ecspi1_pads, ARRAY_SIZE(ecspi1_pads));
+	gpio_direction_output(IMX_GPIO_NR(2, 30), 0);
+}
+#endif
+
+iomux_v3_cfg_t const pcie_pads[] = {
+	MX6_PAD_GPIO_1__GPIO1_IO01 | MUX_PAD_CTRL(NO_PAD_CTRL),	/* RESET */
+};
+
+static void setup_pcie(void)
+{
+	imx_iomux_v3_setup_multiple_pads(pcie_pads, ARRAY_SIZE(pcie_pads));
+}
+
+iomux_v3_cfg_t const rgb_pads[] = {
+	MX6_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK,	/* DISP0_CLK */
+	MX6_PAD_DI0_PIN15__IPU1_DI0_PIN15,
+	MX6_PAD_DI0_PIN2__IPU1_DI0_PIN02,		/* DISP0_HSYNC */
+	MX6_PAD_DI0_PIN3__IPU1_DI0_PIN03,		/* DISP0_VSYNC */
+	MX6_PAD_DI0_PIN4__IPU1_DI0_PIN04,
+	MX6_PAD_DISP0_DAT0__IPU1_DISP0_DATA00,
+	MX6_PAD_DISP0_DAT1__IPU1_DISP0_DATA01,
+	MX6_PAD_DISP0_DAT2__IPU1_DISP0_DATA02,
+	MX6_PAD_DISP0_DAT3__IPU1_DISP0_DATA03,
+	MX6_PAD_DISP0_DAT4__IPU1_DISP0_DATA04,
+	MX6_PAD_DISP0_DAT5__IPU1_DISP0_DATA05,
+	MX6_PAD_DISP0_DAT6__IPU1_DISP0_DATA06,
+	MX6_PAD_DISP0_DAT7__IPU1_DISP0_DATA07,
+	MX6_PAD_DISP0_DAT8__IPU1_DISP0_DATA08,
+	MX6_PAD_DISP0_DAT9__IPU1_DISP0_DATA09,
+	MX6_PAD_DISP0_DAT10__IPU1_DISP0_DATA10,
+	MX6_PAD_DISP0_DAT11__IPU1_DISP0_DATA11,
+	MX6_PAD_DISP0_DAT12__IPU1_DISP0_DATA12,
+	MX6_PAD_DISP0_DAT13__IPU1_DISP0_DATA13,
+	MX6_PAD_DISP0_DAT14__IPU1_DISP0_DATA14,
+	MX6_PAD_DISP0_DAT15__IPU1_DISP0_DATA15,
+	MX6_PAD_DISP0_DAT16__IPU1_DISP0_DATA16,
+	MX6_PAD_DISP0_DAT17__IPU1_DISP0_DATA17,
+	MX6_PAD_DISP0_DAT18__IPU1_DISP0_DATA18,
+	MX6_PAD_DISP0_DAT19__IPU1_DISP0_DATA19,
+	MX6_PAD_DISP0_DAT20__IPU1_DISP0_DATA20,
+	MX6_PAD_DISP0_DAT21__IPU1_DISP0_DATA21,
+	MX6_PAD_DISP0_DAT22__IPU1_DISP0_DATA22,
+	MX6_PAD_DISP0_DAT23__IPU1_DISP0_DATA23,
+};
+
+#if defined(CONFIG_MX6DL) && defined(CONFIG_MXC_EPDC)
+static iomux_v3_cfg_t const epdc_enable_pads[] = {
+	MX6_PAD_EIM_A16__EPDC_DATA00	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA10__EPDC_DATA01	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA12__EPDC_DATA02	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA11__EPDC_DATA03	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_LBA__EPDC_DATA04	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_EB2__EPDC_DATA05	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_CS0__EPDC_DATA06	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_RW__EPDC_DATA07	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_A21__EPDC_GDCLK	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_A22__EPDC_GDSP	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_A23__EPDC_GDOE	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_A24__EPDC_GDRL	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_D31__EPDC_SDCLK_P	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_D27__EPDC_SDOE	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA1__EPDC_SDLE	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_EB1__EPDC_SDSHR	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA2__EPDC_BDR0	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA4__EPDC_SDCE0	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA5__EPDC_SDCE1	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA6__EPDC_SDCE2	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const epdc_disable_pads[] = {
+	MX6_PAD_EIM_A16__GPIO2_IO22,
+	MX6_PAD_EIM_DA10__GPIO3_IO10,
+	MX6_PAD_EIM_DA12__GPIO3_IO12,
+	MX6_PAD_EIM_DA11__GPIO3_IO11,
+	MX6_PAD_EIM_LBA__GPIO2_IO27,
+	MX6_PAD_EIM_EB2__GPIO2_IO30,
+	MX6_PAD_EIM_CS0__GPIO2_IO23,
+	MX6_PAD_EIM_RW__GPIO2_IO26,
+	MX6_PAD_EIM_A21__GPIO2_IO17,
+	MX6_PAD_EIM_A22__GPIO2_IO16,
+	MX6_PAD_EIM_A23__GPIO6_IO06,
+	MX6_PAD_EIM_A24__GPIO5_IO04,
+	MX6_PAD_EIM_D31__GPIO3_IO31,
+	MX6_PAD_EIM_D27__GPIO3_IO27,
+	MX6_PAD_EIM_DA1__GPIO3_IO01,
+	MX6_PAD_EIM_EB1__GPIO2_IO29,
+	MX6_PAD_EIM_DA2__GPIO3_IO02,
+	MX6_PAD_EIM_DA4__GPIO3_IO04,
+	MX6_PAD_EIM_DA5__GPIO3_IO05,
+	MX6_PAD_EIM_DA6__GPIO3_IO06,
+};
+#endif
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_SYS_I2C_MXC
+
+static int disable_ar1021(void)
+{
+        unsigned char cmd[] = { 0x55, 0x01, 0x13 };
+
+        i2c_set_bus_num(0);
+        if (!i2c_probe(0x4d)) {
+
+                if (i2c_write(0x4d, 0x00, 1, cmd, 3)) {
+                        printf("Failed to disable AR1021!\n");
+                        return -1;
+                }
+	}
+	return 0;
+}
+
+/* set all switches APS in normal and PFM mode in standby */
+static int setup_pmic_mode(int chip)
+{
+	unsigned char offset, i, switch_num, value;
+
+	if (!chip) {
+		/* pfuze100 */
+		switch_num = 6;
+		offset = 0x31;
+	} else {
+		/* pfuze200 */
+		switch_num = 4;
+		offset = 0x38;
+	}
+
+	value = 0xc;
+	if (i2c_write(0x8, 0x23, 1, &value, 1)) {
+		printf("Set SW1AB mode error!\n");
+		return -1;
+	}
+
+	for (i = 0; i < switch_num - 1; i++) {
+		if (i2c_write(0x8, offset + i * 7, 1, &value, 1)) {
+			printf("Set switch%x mode error!\n", offset);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int setup_pmic_voltages(void)
+{
+	unsigned char value, rev_id = 0 ;
+
+	i2c_set_bus_num(0);
+	if (!i2c_probe(0x8)) {
+
+		if (i2c_read(0x8, 0, 1, &value, 1)) {
+			printf("Read device ID error!\n");
+			return -1;
+		}
+		if (i2c_read(0x8, 3, 1, &rev_id, 1)) {
+			printf("Read Rev ID error!\n");
+			return -1;
+		}
+		printf("Found PFUZE%s deviceid=%x,revid=%x\n",
+			((value & 0xf) == 0) ? "100" : "200", value, rev_id);
+
+		if (setup_pmic_mode(value & 0xf)) {
+			printf("setup pmic mode error!\n");
+			return -1;
+		}
+
+		/*increase VGEN5 from 2.8 to 3V*/
+		if (i2c_read(0x8, 0x70, 1, &value, 1)) {
+			printf("Read VGEN5 error!\n");
+			return -1;
+		}
+		value &= ~0xf;
+		value |= 0xc;
+		if (i2c_write(0x8, 0x70, 1, &value, 1)) {
+			printf("Set VGEN5 error!\n");
+			return -1;
+		}
+		/* set SW1AB staby volatage 0.975V*/
+		if (i2c_read(0x8, 0x21, 1, &value, 1)) {
+			printf("Read SW1ABSTBY error!\n");
+			return -1;
+		}
+		value &= ~0x3f;
+		value |= 0x1b;
+		if (i2c_write(0x8, 0x21, 1, &value, 1)) {
+			printf("Set SW1ABSTBY error!\n");
+			return -1;
+		}
+		/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+		if (i2c_read(0x8, 0x24, 1, &value, 1)) {
+			printf("Read SW1ABSTBY error!\n");
+			return -1;
+		}
+		value &= ~0xc0;
+		value |= 0x40;
+		if (i2c_write(0x8, 0x24, 1, &value, 1)) {
+			printf("Set SW1ABSTBY error!\n");
+			return -1;
+		}
+
+		/* set SW1C staby volatage 0.975V*/
+		if (i2c_read(0x8, 0x2f, 1, &value, 1)) {
+			printf("Read SW1CSTBY error!\n");
+			return -1;
+		}
+		value &= ~0x3f;
+		value |= 0x1b;
+		if (i2c_write(0x8, 0x2f, 1, &value, 1)) {
+			printf("Set SW1CSTBY error!\n");
+			return -1;
+		}
+
+		/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+		if (i2c_read(0x8, 0x32, 1, &value, 1)) {
+			printf("Read SW1ABSTBY error!\n");
+			return -1;
+		}
+		value &= ~0xc0;
+		value |= 0x40;
+		if (i2c_write(0x8, 0x32, 1, &value, 1)) {
+			printf("Set SW1ABSTBY error!\n");
+			return -1;
+		}
+
+		/*set SW3AB to 1.35V*/
+		if (i2c_read(0x8, 0x3C, 1, &value, 1)) {
+			printf("Read SW3AB error!\n");
+			return -1;
+		}
+		if (value & 0x40)
+			value = 0x4B;
+		else
+			value = 0x26;
+		if (i2c_write(0x8, 0x3C, 1, &value, 1)) {
+			printf("Set SW3AB error (w:0x3c)!\n");
+			return -1;
+		}
+		if (i2c_write(0x8, 0x43, 1, &value, 1)) {
+			printf("Set SW3AB error (w:0x43)!\n");
+			return -1;
+		}
+		if (i2c_write(0x8, 0x3D, 1, &value, 1)) {
+			printf("Set SW3AB error (w:0x3d)!\n");
+			return -1;
+		}
+		if (i2c_write(0x8, 0x44, 1, &value, 1)) {
+			printf("Set SW3AB error (w:0x44)!\n");
+			return -1;
+		}
+	}
+
+
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned char value;
+	int is_400M;
+	unsigned char vddarm;
+
+	/* increase VDDARM/VDDSOC to support 1.2G chip */
+	if (check_1_2G()) {
+		ldo_bypass = 0;	/* ldo_enable on 1.2G chip */
+		printf("1.2G chip, increase VDDARM_IN/VDDSOC_IN\n");
+		/* increase VDDARM to 1.425V */
+		if (i2c_read(0x8, 0x20, 1, &value, 1)) {
+			printf("Read SW1AB error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= 0x2d;
+		if (i2c_write(0x8, 0x20, 1, &value, 1)) {
+			printf("Set SW1AB error!\n");
+			return;
+		}
+		/* increase VDDSOC to 1.425V */
+		if (i2c_read(0x8, 0x2e, 1, &value, 1)) {
+			printf("Read SW1C error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= 0x2d;
+		if (i2c_write(0x8, 0x2e, 1, &value, 1)) {
+			printf("Set SW1C error!\n");
+			return;
+		}
+	}
+	/* switch to ldo_bypass mode , boot on 800Mhz */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+
+		/* decrease VDDARM for 400Mhz DQ:1.1V, DL:1.275V */
+		if (i2c_read(0x8, 0x20, 1, &value, 1)) {
+			printf("Read SW1AB error!\n");
+			return;
+		}
+		value &= ~0x3f;
+#if defined(CONFIG_MX6DL)
+		value |= 0x27;
+#else
+		value |= 0x20;
+#endif
+		if (i2c_write(0x8, 0x20, 1, &value, 1)) {
+			printf("Set SW1AB error!\n");
+			return;
+		}
+		/* increase VDDSOC to 1.3V */
+		if (i2c_read(0x8, 0x2e, 1, &value, 1)) {
+			printf("Read SW1C error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= 0x28;
+		if (i2c_write(0x8, 0x2e, 1, &value, 1)) {
+			printf("Set SW1C error!\n");
+			return;
+		}
+
+		/*
+		 * MX6Q:
+		 * VDDARM:1.15V@800M; VDDSOC:1.175V@800M
+		 * VDDARM:0.975V@400M; VDDSOC:1.175V@400M
+		 * MX6DL:
+		 * VDDARM:1.175V@800M; VDDSOC:1.175V@800M
+		 * VDDARM:1.075V@400M; VDDSOC:1.175V@400M
+		 */
+		is_400M = set_anatop_bypass(2);
+		if (is_400M)
+#if defined(CONFIG_MX6DL)
+			vddarm = 0x1f;
+#else
+			vddarm = 0x1b;
+#endif
+		else
+#if defined(CONFIG_MX6DL)
+			vddarm = 0x23;
+#else
+			vddarm = 0x22;
+#endif
+		if (i2c_read(0x8, 0x20, 1, &value, 1)) {
+			printf("Read SW1AB error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= vddarm;
+		if (i2c_write(0x8, 0x20, 1, &value, 1)) {
+			printf("Set SW1AB error!\n");
+			return;
+		}
+
+		/* decrease VDDSOC to 1.175V */
+		if (i2c_read(0x8, 0x2e, 1, &value, 1)) {
+			printf("Read SW1C error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= 0x23;
+		if (i2c_write(0x8, 0x2e, 1, &value, 1)) {
+			printf("Set SW1C error!\n");
+			return;
+		}
+
+		finish_anatop_bypass();
+		printf("switch to ldo_bypass mode!\n");
+	}
+}
+#endif
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg usdhc_cfg[3] = {
+	{USDHC2_BASE_ADDR},
+	{USDHC3_BASE_ADDR},
+	{USDHC4_BASE_ADDR},
+};
+
+int mmc_get_env_devno(void)
+{
+	u32 soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	u32 dev_no;
+	u32 bootsel;
+
+	bootsel = (soc_sbmr & 0x000000FF) >> 6 ;
+
+	/* If not boot from sd/mmc, use default value */
+	if (bootsel != 1)
+		return CONFIG_SYS_MMC_ENV_DEV;
+
+	/* BOOT_CFG2[3] and BOOT_CFG2[4] */
+	dev_no = (soc_sbmr & 0x00001800) >> 11;
+
+	/* need ubstract 1 to map to the mmc device id
+	 * see the comments in board_mmc_init function
+	 */
+
+	dev_no--;
+
+	return dev_no;
+}
+
+int mmc_map_to_kernel_blk(int dev_no)
+{
+	return dev_no + 1;
+}
+
+#define USDHC2_CD_GPIO	IMX_GPIO_NR(6, 9)
+#define USDHC2_PWR_GPIO	IMX_GPIO_NR(7, 8)
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC2_BASE_ADDR:
+		ret = !gpio_get_value(USDHC2_CD_GPIO);
+		break;
+	case USDHC3_BASE_ADDR:
+		ret = 1;
+		break;
+	case USDHC4_BASE_ADDR:
+		ret = 1; /* eMMC/uSDHC4 is always present */
+		break;
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	s32 status = 0;
+	int i;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    SD2
+	 * mmc1                    SD3
+	 * mmc2                    eMMC
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+
+#if defined(CONFIG_SPL_BUILD)
+
+		// The SPL framework expects there to be only one MMC device
+		// and we always loads u-boot from eMMC which is mapped to mmc2
+		if (i != 2) continue;
+#endif
+
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+			gpio_direction_input(USDHC2_CD_GPIO);
+			gpio_direction_output(USDHC2_PWR_GPIO, 1);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			break;
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		case 2:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc4_pads, ARRAY_SIZE(usdhc4_pads));
+			usdhc_cfg[2].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+			       "(%d) then supported by the board (%d)\n",
+			       i + 1, CONFIG_SYS_FSL_USDHC_NUM);
+			return status;
+		}
+
+		status |= fsl_esdhc_initialize(bis, &usdhc_cfg[i]);
+	}
+
+	return status;
+}
+
+int check_mmc_autodetect(void)
+{
+	char *autodetect_str = getenv("mmcautodetect");
+
+	if ((autodetect_str != NULL) &&
+		(strcmp(autodetect_str, "yes") == 0)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+void board_late_mmc_env_init(void)
+{
+	char cmd[32];
+	char mmcblk[32];
+	u32 dev_no = mmc_get_env_devno();
+
+	if (!check_mmc_autodetect())
+		return;
+
+	setenv_ulong("mmcdev", dev_no);
+
+	/* Set mmcblk env */
+	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
+		mmc_map_to_kernel_blk(dev_no));
+	setenv("mmcroot", mmcblk);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
+}
+#endif
+
+#if defined(CONFIG_MX6DL) && defined(CONFIG_MXC_EPDC)
+#ifdef CONFIG_SPLASH_SCREEN
+extern int mmc_get_env_devno(void);
+int setup_splash_img(void)
+{
+#ifdef CONFIG_SPLASH_IS_IN_MMC
+	int mmc_dev = mmc_get_env_devno();
+	ulong offset = CONFIG_SPLASH_IMG_OFFSET;
+	ulong size = CONFIG_SPLASH_IMG_SIZE;
+	ulong addr = 0;
+	char *s = NULL;
+	struct mmc *mmc = find_mmc_device(mmc_dev);
+	uint blk_start, blk_cnt, n;
+
+	s = getenv("splashimage");
+
+	if (NULL == s) {
+		puts("env splashimage not found!\n");
+		return -1;
+	}
+	addr = simple_strtoul(s, NULL, 16);
+
+	if (!mmc) {
+		printf("MMC Device %d not found\n", mmc_dev);
+		return -1;
+	}
+
+	if (mmc_init(mmc)) {
+		puts("MMC init failed\n");
+		return -1;
+	}
+
+	blk_start = ALIGN(offset, mmc->read_bl_len) / mmc->read_bl_len;
+	blk_cnt   = ALIGN(size, mmc->read_bl_len) / mmc->read_bl_len;
+	n = mmc->block_dev.block_read(mmc_dev, blk_start,
+					blk_cnt, (u_char *)addr);
+	flush_cache((ulong)addr, blk_cnt * mmc->read_bl_len);
+
+	return (n == blk_cnt) ? 0 : -1;
+#endif
+
+	return 0;
+}
+#endif
+
+vidinfo_t panel_info = {
+	.vl_refresh = 85,
+	.vl_col = 800,
+	.vl_row = 600,
+	.vl_pixclock = 26666667,
+	.vl_left_margin = 8,
+	.vl_right_margin = 100,
+	.vl_upper_margin = 4,
+	.vl_lower_margin = 8,
+	.vl_hsync = 4,
+	.vl_vsync = 1,
+	.vl_sync = 0,
+	.vl_mode = 0,
+	.vl_flag = 0,
+	.vl_bpix = 3,
+	.cmap = 0,
+};
+
+struct epdc_timing_params panel_timings = {
+	.vscan_holdoff = 4,
+	.sdoed_width = 10,
+	.sdoed_delay = 20,
+	.sdoez_width = 10,
+	.sdoez_delay = 20,
+	.gdclk_hp_offs = 419,
+	.gdsp_offs = 20,
+	.gdoe_offs = 0,
+	.gdclk_offs = 5,
+	.num_ce = 1,
+};
+
+static void setup_epdc_power(void)
+{
+	/* Setup epdc voltage */
+
+	/* EIM_A17 - GPIO2[21] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_A17__GPIO2_IO21 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as input */
+	gpio_direction_input(IMX_GPIO_NR(2, 21));
+
+	/* EIM_D17 - GPIO3[17] for VCOM control */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_D17__GPIO3_IO17 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(3, 17), 1);
+
+	/* EIM_D20 - GPIO3[20] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_D20__GPIO3_IO20 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(3, 20), 1);
+
+	/* EIM_A18 - GPIO2[20] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_A18__GPIO2_IO20 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(2, 20), 1);
+}
+
+int setup_waveform_file(void)
+{
+#ifdef CONFIG_WAVEFORM_FILE_IN_MMC
+	int mmc_dev = mmc_get_env_devno();
+	ulong offset = CONFIG_WAVEFORM_FILE_OFFSET;
+	ulong size = CONFIG_WAVEFORM_FILE_SIZE;
+	ulong addr = CONFIG_WAVEFORM_BUF_ADDR;
+	struct mmc *mmc = find_mmc_device(mmc_dev);
+	uint blk_start, blk_cnt, n;
+
+	if (!mmc) {
+		printf("MMC Device %d not found\n", mmc_dev);
+		return -1;
+	}
+
+	if (mmc_init(mmc)) {
+		puts("MMC init failed\n");
+		return -1;
+	}
+
+	blk_start = ALIGN(offset, mmc->read_bl_len) / mmc->read_bl_len;
+	blk_cnt   = ALIGN(size, mmc->read_bl_len) / mmc->read_bl_len;
+	n = mmc->block_dev.block_read(mmc_dev, blk_start,
+				      blk_cnt, (u_char *)addr);
+	flush_cache((ulong)addr, blk_cnt * mmc->read_bl_len);
+
+	return (n == blk_cnt) ? 0 : -1;
+#else
+	return -1;
+#endif
+}
+
+static void epdc_enable_pins(void)
+{
+	/* epdc iomux settings */
+	imx_iomux_v3_setup_multiple_pads(epdc_enable_pads,
+				ARRAY_SIZE(epdc_enable_pads));
+}
+
+static void epdc_disable_pins(void)
+{
+	/* Configure MUX settings for EPDC pins to GPIO */
+	imx_iomux_v3_setup_multiple_pads(epdc_disable_pads,
+				ARRAY_SIZE(epdc_disable_pads));
+}
+
+static void setup_epdc(void)
+{
+	unsigned int reg;
+	struct mxc_ccm_reg *ccm_regs = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	/*** epdc Maxim PMIC settings ***/
+
+	/* EPDC PWRSTAT - GPIO2[21] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_A17__GPIO2_IO21 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC VCOM0 - GPIO3[17] for VCOM control */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_D17__GPIO3_IO17 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* UART4 TXD - GPIO3[20] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_D20__GPIO3_IO20 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EIM_A18 - GPIO2[20] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_A18__GPIO2_IO20 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/*** Set pixel clock rates for EPDC ***/
+
+	/* EPDC AXI clk (IPU2_CLK) from PFD_400M, set to 396/2 = 198MHz */
+	reg = readl(&ccm_regs->cscdr3);
+	reg &= ~0x7C000;
+	reg |= (1 << 16) | (1 << 14);
+	writel(reg, &ccm_regs->cscdr3);
+
+	/* EPDC AXI clk enable */
+	reg = readl(&ccm_regs->CCGR3);
+	reg |= 0x00C0;
+	writel(reg, &ccm_regs->CCGR3);
+
+	/* EPDC PIX clk (IPU2_DI1_CLK) from PLL5, set to 650/4/6 = ~27MHz */
+	reg = readl(&ccm_regs->cscdr2);
+	reg &= ~0x3FE00;
+	reg |= (2 << 15) | (5 << 12);
+	writel(reg, &ccm_regs->cscdr2);
+
+	/* PLL5 enable (defaults to 650) */
+	reg = readl(&ccm_regs->analog_pll_video);
+	reg &= ~((1 << 16) | (1 << 12));
+	reg |= (1 << 13);
+	writel(reg, &ccm_regs->analog_pll_video);
+
+	/* EPDC PIX clk enable */
+	reg = readl(&ccm_regs->CCGR3);
+	reg |= 0x0C00;
+	writel(reg, &ccm_regs->CCGR3);
+
+	panel_info.epdc_data.working_buf_addr = CONFIG_WORKING_BUF_ADDR;
+	panel_info.epdc_data.waveform_buf_addr = CONFIG_WAVEFORM_BUF_ADDR;
+
+	panel_info.epdc_data.wv_modes.mode_init = 0;
+	panel_info.epdc_data.wv_modes.mode_du = 1;
+	panel_info.epdc_data.wv_modes.mode_gc4 = 3;
+	panel_info.epdc_data.wv_modes.mode_gc8 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc16 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc32 = 2;
+
+	panel_info.epdc_data.epdc_timings = panel_timings;
+
+	setup_epdc_power();
+
+	/* Assign fb_base */
+	gd->fb_base = CONFIG_FB_BASE;
+}
+
+void epdc_power_on(void)
+{
+	unsigned int reg;
+	struct gpio_regs *gpio_regs = (struct gpio_regs *)GPIO2_BASE_ADDR;
+
+	/* Set EPD_PWR_CTL0 to high - enable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(2, 20), 1);
+	udelay(1000);
+
+	/* Enable epdc signal pin */
+	epdc_enable_pins();
+
+	/* Set PMIC Wakeup to high - enable Display power */
+	gpio_set_value(IMX_GPIO_NR(3, 20), 1);
+
+	/* Wait for PWRGOOD == 1 */
+	while (1) {
+		reg = readl(&gpio_regs->gpio_psr);
+		if (!(reg & (1 << 21)))
+			break;
+
+		udelay(100);
+	}
+
+	/* Enable VCOM */
+	gpio_set_value(IMX_GPIO_NR(3, 17), 1);
+
+	udelay(500);
+}
+
+void epdc_power_off(void)
+{
+	/* Set PMIC Wakeup to low - disable Display power */
+	gpio_set_value(IMX_GPIO_NR(3, 20), 0);
+
+	/* Disable VCOM */
+	gpio_set_value(IMX_GPIO_NR(3, 17), 0);
+
+	epdc_disable_pins();
+
+	/* Set EPD_PWR_CTL0 to low - disable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(2, 20), 0);
+}
+#endif
+
+int mx6_rgmii_rework(struct phy_device *phydev)
+{
+	unsigned short val;
+
+	/* To enable AR8031 ouput a 125MHz clk from CLK_25M */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x7);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, 0x8016);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x4007);
+
+	val = phy_read(phydev, MDIO_DEVAD_NONE, 0xe);
+	val &= 0xffe3;
+	val |= 0x18;
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, val);
+
+	/* introduce tx clock delay */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x5);
+	val = phy_read(phydev, MDIO_DEVAD_NONE, 0x1e);
+	val |= 0x0100;
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, val);
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	mx6_rgmii_rework(phydev);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+
+void board_get_hwaddr(int dev_id, unsigned char *mac)
+{
+	ea_eeprom_config_t config;
+
+	if (ea_eeprom_get_config(&config) == 0) {
+		if (dev_id == 0) {
+			memcpy(mac, config.mac1, 6);
+		}
+		else {
+			memcpy(mac, config.mac2, 6);
+		}
+	}
+
+}
+
+#if defined(CONFIG_VIDEO_IPUV3)
+
+static iomux_v3_cfg_t const display_ctrl_pads[] = {
+	/* Display enable for LVDS0 and Parallel RGB */
+	MX6_PAD_EIM_BCLK__GPIO6_IO31 | MUX_PAD_CTRL(NO_PAD_CTRL),
+#define DISPENABLE_GP_LVDS0_RGB  IMX_GPIO_NR(6, 31)
+
+	/* Display enable for LVDS1 */
+	MX6_PAD_EIM_D20__GPIO3_IO20 | MUX_PAD_CTRL(NO_PAD_CTRL),
+#define DISPENABLE_GP_LVDS1  IMX_GPIO_NR(3, 20)
+
+
+	/* LVDS0 and LVDS1 Brightness (gpio instead of PWM1, duty cycle = period) */
+	MX6_PAD_SD1_DAT3__GPIO1_IO21 | MUX_PAD_CTRL(NO_PAD_CTRL),
+#define BRIGHTNESS_GP_LVDSx  IMX_GPIO_NR(1, 21)
+
+	/* Parallel RGB Brightness (gpio instead of PWM2, duty cycle = period) */
+	MX6_PAD_SD1_DAT2__GPIO1_IO19 | MUX_PAD_CTRL(NO_PAD_CTRL),
+#define BRIGHTNESS_GP_RGB  IMX_GPIO_NR(1, 19)
+
+
+	/* Backlight Power Enable for LVDS0 and Parallel RGB */
+	MX6_PAD_EIM_WAIT__GPIO5_IO00 | MUX_PAD_CTRL(NO_PAD_CTRL),
+#define BACKLIGHT_GP_LVDS0_RGB  IMX_GPIO_NR(5, 0)
+
+	/* Backlight Power Enable for LVDS1 */
+	MX6_PAD_EIM_LBA__GPIO2_IO27 | MUX_PAD_CTRL(NO_PAD_CTRL),
+#define BACKLIGHT_GP_LVDS1  IMX_GPIO_NR(2, 27)
+};
+
+#ifdef CONFIG_CMD_EADISP
+
+void board_enable_rgb(const struct display_info_t *di, int enable)
+{
+	if (enable) {
+		/* Setup pads for RGB */
+		imx_iomux_v3_setup_multiple_pads(rgb_pads, ARRAY_SIZE(rgb_pads));
+
+		/* Default interface is LVDS1 so pinning must be changed */
+		gpio_direction_output(DISPENABLE_GP_LVDS0_RGB, 1);
+		gpio_direction_output(BRIGHTNESS_GP_LVDSx, 0);
+		gpio_direction_output(BRIGHTNESS_GP_RGB, 1);
+		gpio_direction_output(BACKLIGHT_GP_LVDS0_RGB, 1);
+	}
+}
+void board_enable_lvds0(const struct display_info_t *di, int enable)
+{
+	if (enable) {
+		/* Default is lvds1 so change that to lvds0 */
+		struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+
+		int reg = readl(&iomux->gpr[2]);
+
+		reg &= ~(IOMUXC_GPR2_LVDS_CH0_MODE_MASK |
+			 IOMUXC_GPR2_LVDS_CH1_MODE_MASK);
+		reg |= (IOMUXC_GPR2_LVDS_CH0_MODE_ENABLED_DI0 |
+			IOMUXC_GPR2_LVDS_CH1_MODE_DISABLED);
+
+		writel(reg, &iomux->gpr[2]);
+
+		reg = readl(&iomux->gpr[3]);
+		reg &= ~(IOMUXC_GPR3_LVDS0_MUX_CTL_MASK |
+			 IOMUXC_GPR3_LVDS1_MUX_CTL_MASK |
+			 IOMUXC_GPR3_HDMI_MUX_CTL_MASK);
+		reg |= (IOMUXC_GPR3_MUX_SRC_IPU1_DI0
+			   << IOMUXC_GPR3_LVDS0_MUX_CTL_OFFSET);
+
+		writel(reg, &iomux->gpr[3]);
+
+		/* Now change pinning as well */
+		gpio_direction_output(DISPENABLE_GP_LVDS0_RGB, 1);
+		gpio_direction_output(BRIGHTNESS_GP_LVDSx, 1);
+		gpio_direction_output(BRIGHTNESS_GP_RGB, 0);
+		gpio_direction_output(BACKLIGHT_GP_LVDS0_RGB, 1);
+	}
+}
+
+void board_enable_lvds1(const struct display_info_t *di, int enable)
+{
+	if (enable) {
+		/* Default interface so only pinning is needed */
+		gpio_direction_output(DISPENABLE_GP_LVDS1, 1);
+		gpio_direction_output(BRIGHTNESS_GP_LVDSx, 1);
+		gpio_direction_output(BACKLIGHT_GP_LVDS1, 1);
+	}
+}
+
+void board_enable_hdmi(const struct display_info_t *di, int enable)
+{
+	if (enable) {
+		/* Default is lvds1 so disable it */
+		struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+
+		int reg = readl(&iomux->gpr[2]);
+
+		reg &= ~(IOMUXC_GPR2_LVDS_CH0_MODE_MASK |
+			 IOMUXC_GPR2_LVDS_CH1_MODE_MASK);
+
+		writel(reg, &iomux->gpr[2]);
+
+		/* Now enable HDMI */
+		imx_enable_hdmi_phy();
+	}
+}
+
+static const struct display_info_t displays[] = {
+	/* LVDS */
+	EADISP_HANNSTAR10(LVDS0, 0, 0),
+	EADISP_HANNSTAR10(LVDS1, 0, 0),
+
+	/* RGB */
+	EADISP_INNOLUX_AT070TN(RGB, 0, 0),
+	EADISP_NHD_43480272EF(RGB, 0, 0),
+	EADISP_NHD_50800480TF(RGB, 0, 0),
+	EADISP_NHD_70800480EF(RGB, 0, 0),
+	EADISP_UMSH_8864(RGB, 0, 0),
+	EADISP_UMSH_8596_30T(RGB, 0, 0),
+	EADISP_UMSH_8596_33T(RGB, 0, 0),
+	EADISP_ROGIN_RX050A(RGB, 0, 0),
+
+	/* HDMI */
+	EADISP_HDMI_1280_720M_60(HDMI, 0, 0),
+	EADISP_HDMI_1920_1080M_60(HDMI, 0, 0),
+	EADISP_HDMI_640_480M_60(HDMI, 0, 0),
+	EADISP_HDMI_720_480M_60(HDMI, 0, 0),
+};
+
+#else  /* CONFIG_CMD_EADISP */
+struct display_info_t {
+	int	bus;
+	int	addr;
+	int	pixfmt;
+	int	(*detect)(struct display_info_t const *dev);
+	void	(*enable)(struct display_info_t const *dev);
+	struct	fb_videomode mode;
+};
+
+static void disable_lvds(struct display_info_t const *dev)
+{
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+
+	int reg = readl(&iomux->gpr[2]);
+
+	reg &= ~(IOMUXC_GPR2_LVDS_CH0_MODE_MASK |
+		 IOMUXC_GPR2_LVDS_CH1_MODE_MASK);
+
+	writel(reg, &iomux->gpr[2]);
+}
+
+static void do_enable_lvds0(struct display_info_t const *dev)
+{
+	/* Default is lvds1 so change that to lvds0 */
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+
+	int reg = readl(&iomux->gpr[2]);
+
+	reg &= ~(IOMUXC_GPR2_LVDS_CH0_MODE_MASK |
+		 IOMUXC_GPR2_LVDS_CH1_MODE_MASK);
+	reg |= (IOMUXC_GPR2_LVDS_CH0_MODE_ENABLED_DI0 |
+		IOMUXC_GPR2_LVDS_CH1_MODE_DISABLED);
+
+	writel(reg, &iomux->gpr[2]);
+
+	reg = readl(&iomux->gpr[3]);
+	reg &= ~(IOMUXC_GPR3_LVDS0_MUX_CTL_MASK |
+		 IOMUXC_GPR3_LVDS1_MUX_CTL_MASK |
+		 IOMUXC_GPR3_HDMI_MUX_CTL_MASK);
+	reg |= (IOMUXC_GPR3_MUX_SRC_IPU1_DI0
+	       << IOMUXC_GPR3_LVDS0_MUX_CTL_OFFSET);
+
+	writel(reg, &iomux->gpr[3]);
+
+	/* Now change pinning as well */
+	gpio_direction_output(DISPENABLE_GP_LVDS0_RGB, 1);
+	gpio_direction_output(BRIGHTNESS_GP_LVDSx, 1);
+	gpio_direction_output(BRIGHTNESS_GP_RGB, 0);
+	gpio_direction_output(BACKLIGHT_GP_LVDS0_RGB, 1);
+}
+
+static void do_enable_lvds1(struct display_info_t const *dev)
+{
+	/* Default interface so only pinning is needed */
+	gpio_direction_output(DISPENABLE_GP_LVDS1, 1);
+	gpio_direction_output(BRIGHTNESS_GP_LVDSx, 1);
+	gpio_direction_output(BACKLIGHT_GP_LVDS1, 1);
+}
+
+static void do_enable_hdmi(struct display_info_t const *dev)
+{
+	/* Default is lvds1 so disable it */
+	disable_lvds(dev);
+	imx_enable_hdmi_phy();
+}
+
+static void do_enable_parallel_rgb(struct display_info_t const *dev)
+{
+	/* Setup pads for RGB */
+	imx_iomux_v3_setup_multiple_pads(rgb_pads, ARRAY_SIZE(rgb_pads));
+
+	/* Default interface is LVDS1 so pinning must be changed */
+	gpio_direction_output(DISPENABLE_GP_LVDS0_RGB, 1);
+	gpio_direction_output(BRIGHTNESS_GP_LVDSx, 0);
+	gpio_direction_output(BRIGHTNESS_GP_RGB, 1);
+	gpio_direction_output(BACKLIGHT_GP_LVDS0_RGB, 1);
+}
+
+static struct display_info_t const displays[] = {{
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB666,
+	.detect	= NULL,
+	.enable	= do_enable_lvds1,
+	.mode	= {
+		.name           = "Hannstar-XGA-LVDS1",
+		.refresh        = 60,
+		.xres           = 1024,
+		.yres           = 768,
+		.pixclock       = 15385,
+		.left_margin    = 220,
+		.right_margin   = 40,
+		.upper_margin   = 21,
+		.lower_margin   = 7,
+		.hsync_len      = 60,
+		.vsync_len      = 10,
+		.sync           = FB_SYNC_EXT,
+		.vmode          = FB_VMODE_NONINTERLACED
+} }, {
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB666,
+	.detect	= NULL,
+	.enable	= do_enable_lvds0,
+	.mode	= {
+		.name           = "Hannstar-XGA-LVDS0",
+		.refresh        = 60,
+		.xres           = 1024,
+		.yres           = 768,
+		.pixclock       = 15385,
+		.left_margin    = 220,
+		.right_margin   = 40,
+		.upper_margin   = 21,
+		.lower_margin   = 7,
+		.hsync_len      = 60,
+		.vsync_len      = 10,
+		.sync           = FB_SYNC_EXT,
+		.vmode          = FB_VMODE_NONINTERLACED
+} }, {
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB24,
+	.detect	= NULL,
+	.enable	= do_enable_hdmi,
+	.mode	= {
+		.name           = "HDMI",
+		.refresh        = 60,
+		.xres           = 640,
+		.yres           = 480,
+		.pixclock       = 39721,
+		.left_margin    = 48,
+		.right_margin   = 16,
+		.upper_margin   = 33,
+		.lower_margin   = 10,
+		.hsync_len      = 96,
+		.vsync_len      = 2,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} }, {
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB24,
+	.detect	= NULL,
+	.enable	= do_enable_parallel_rgb,
+	.mode	= {
+		.name           = "Innolux-AT070TN",
+		.refresh        = 60,
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 29850,
+		.left_margin    = 89,
+		.right_margin   = 164,
+		.upper_margin   = 75,
+		.lower_margin   = 75,
+		.hsync_len      = 10,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+
+int board_video_skip(void)
+{
+	int i;
+	int ret;
+	char const *panel = getenv("panel");
+	if (!panel) {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			struct display_info_t const *dev = displays+i;
+			if (dev->detect && dev->detect(dev)) {
+				panel = dev->mode.name;
+				printf("auto-detected panel %s\n", panel);
+				break;
+			}
+		}
+		if (!panel) {
+			panel = displays[0].mode.name;
+			printf("No panel detected: default to %s\n", panel);
+			i = 0;
+		}
+	} else {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			if (!strcmp(panel, displays[i].mode.name))
+				break;
+		}
+	}
+	if (i < ARRAY_SIZE(displays)) {
+		ret = ipuv3_fb_init(&displays[i].mode, 0,
+				    displays[i].pixfmt);
+		if (!ret) {
+			if (displays[i].enable)
+				displays[i].enable(displays+i);
+			printf("Display: %s (%ux%u)\n",
+			       displays[i].mode.name,
+			       displays[i].mode.xres,
+			       displays[i].mode.yres);
+		} else
+			printf("LCD %s cannot be configured: %d\n",
+			       displays[i].mode.name, ret);
+	} else {
+		printf("unsupported panel %s\n", panel);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#endif  /* CONFIG_CMD_EADISP */
+
+static void setup_display(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+	int reg;
+
+	enable_ipu_clock();
+	imx_setup_hdmi();
+
+	/* Turn on LDB0, LDB1, IPU,IPU DI0 clocks */
+	reg = readl(&mxc_ccm->CCGR3);
+	reg |=  MXC_CCM_CCGR3_LDB_DI0_MASK | MXC_CCM_CCGR3_LDB_DI1_MASK;
+	writel(reg, &mxc_ccm->CCGR3);
+
+	/* set LDB0, LDB1 clk select to 011/011 */
+	reg = readl(&mxc_ccm->cs2cdr);
+	reg &= ~(MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK
+		 | MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK);
+	reg |= (3 << MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_OFFSET)
+	      | (3 << MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->cs2cdr);
+
+	reg = readl(&mxc_ccm->cscmr2);
+	reg |= MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV | MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV;
+	writel(reg, &mxc_ccm->cscmr2);
+
+	reg = readl(&mxc_ccm->chsccdr);
+	reg |= (CHSCCDR_CLK_SEL_LDB_DI0
+		<< MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET);
+	reg |= (CHSCCDR_CLK_SEL_LDB_DI0
+		<< MXC_CCM_CHSCCDR_IPU1_DI1_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->chsccdr);
+
+	reg = IOMUXC_GPR2_BGREF_RRMODE_EXTERNAL_RES
+	     | IOMUXC_GPR2_DI1_VS_POLARITY_ACTIVE_LOW
+	     | IOMUXC_GPR2_DI0_VS_POLARITY_ACTIVE_LOW
+	     | IOMUXC_GPR2_BIT_MAPPING_CH1_SPWG
+	     | IOMUXC_GPR2_DATA_WIDTH_CH1_18BIT
+	     | IOMUXC_GPR2_BIT_MAPPING_CH0_SPWG
+	     | IOMUXC_GPR2_DATA_WIDTH_CH0_18BIT
+	     | IOMUXC_GPR2_LVDS_CH0_MODE_DISABLED
+	     | IOMUXC_GPR2_LVDS_CH1_MODE_ENABLED_DI0;
+	writel(reg, &iomux->gpr[2]);
+
+	reg = readl(&iomux->gpr[3]);
+	reg = (reg & ~(IOMUXC_GPR3_LVDS1_MUX_CTL_MASK
+			| IOMUXC_GPR3_HDMI_MUX_CTL_MASK))
+	    | (IOMUXC_GPR3_MUX_SRC_IPU1_DI0
+	       << IOMUXC_GPR3_LVDS1_MUX_CTL_OFFSET);
+	writel(reg, &iomux->gpr[3]);
+
+	/* DisplayEnable, BacklightEnable, Brightness controls for RGB, LVDS0 and LVDS1 */
+	imx_iomux_v3_setup_multiple_pads(display_ctrl_pads,
+					ARRAY_SIZE(display_ctrl_pads));
+}
+#endif /* CONFIG_VIDEO_IPUV3 */
+
+/*
+ * Do not overwrite the console
+ * Use always serial for U-Boot console
+ */
+int overwrite_console(void)
+{
+	return 1;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	ea_eeprom_config_t config;
+
+	setup_iomux_enet();
+	setup_pcie();
+
+	/* stored MAC addresses to env variables */
+	if (ea_eeprom_get_config(&config) == 0) {
+
+		if (is_valid_ether_addr(config.mac1) && !getenv("ethaddr")) {
+			eth_setenv_enetaddr("ethaddr", config.mac1);
+		}
+
+		if (is_valid_ether_addr(config.mac2) && !getenv("eth1addr")) {
+			eth_setenv_enetaddr("eth1addr", config.mac2);
+		}
+
+		if (is_valid_ether_addr(config.mac3) && !getenv("eth2addr")) {
+			eth_setenv_enetaddr("eth2addr", config.mac3);
+		}
+
+		if (is_valid_ether_addr(config.mac4) && !getenv("eth3addr")) {
+			eth_setenv_enetaddr("eth3addr", config.mac4);
+		}
+
+	}
+
+	return cpu_eth_init(bis);
+}
+
+int board_early_init_f(void)
+{
+	/* configure and enable pwr */
+	imx_iomux_v3_setup_multiple_pads(peri_pwr_pads,
+			ARRAY_SIZE(peri_pwr_pads));
+	gpio_direction_output(IMX_GPIO_NR(7, 12), 1);
+
+	/* enable USB 5V. Doesn't seem to work to do this in Linux/DTS?? */
+	gpio_direction_output(IMX_GPIO_NR(1, 0), 1);
+
+        /* Empty UART RX FIFO 5ms after PERI_PWR_ENABLE goes high */
+        udelay(5000);
+        while (tstc()) {
+                (void)getc();
+        }
+
+	setup_iomux_uart();
+#if defined(CONFIG_VIDEO_IPUV3)
+	setup_display();
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+	setup_spinor();
+#endif
+
+#ifdef CONFIG_CMD_SATA
+	setup_sata();
+#endif
+
+// Configuration parameters are stored in I2C mapped eeprom and
+// must be initialized here since the configuration is accessed
+// early in the boot sequence
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info0);
+#endif
+
+	ea_eeprom_init();
+
+	return 0;
+}
+
+int board_init(void)
+{
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+#if defined(CONFIG_MX6DL) && defined(CONFIG_MXC_EPDC)
+	setup_epdc();
+#endif
+#ifdef CONFIG_CMD_EADISP
+	eadisp_setup_display(displays, ARRAY_SIZE(displays));
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 8 bit bus width */
+	{"emmc", MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},
+	{NULL,	 0},
+};
+#endif
+
+int board_late_init(void)
+{
+	int ret = 0;
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_SYS_I2C_MXC
+	ret = setup_pmic_voltages();
+	if (ret)
+		return -1;
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
+#ifdef CONFIG_CMD_EADISP
+	eatouch_init();
+#endif
+#ifdef CONFIG_SYS_I2C_MXC
+	disable_ar1021();
+#endif
+	return 0;
+}
+
+int checkboard(void)
+{
+	ea_eeprom_config_t config;
+
+	puts ("Board: Embedded Artists ");
+	if (ea_eeprom_get_config(&config) == 0) {
+
+		printf("%s\n", config.name);
+		printf("       %05d, %s, WO%d\n",
+			config.board_part_nr,
+			config.board_rev,
+			config.batch);
+
+	}
+	else {
+		puts(" [Unknown board due to invalid configuration data]\n");
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_FSL_FASTBOOT
+
+void board_fastboot_setup(void)
+{
+	switch (get_boot_device()) {
+#if defined(CONFIG_FASTBOOT_STORAGE_SATA)
+	case SATA_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "sata");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota sata");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_SATA*/
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD2_BOOT:
+	case MMC2_BOOT:
+	    if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc0");
+	    if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc0");
+	    break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+	    if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc1");
+	    if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc1");
+	    break;
+	case MMC4_BOOT:
+	    if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc2");
+	    if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc2");
+	    break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("unsupported boot devices\n");
+		break;
+	}
+
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+
+#define GPIO_VOL_DN_KEY IMX_GPIO_NR(1, 5)
+iomux_v3_cfg_t const recovery_key_pads[] = {
+	(MX6_PAD_GPIO_5__GPIO1_IO05 | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+int check_recovery_cmd_file(void)
+{
+    int button_pressed = 0;
+    int recovery_mode = 0;
+
+    recovery_mode = recovery_check_and_clean_flag();
+
+    /* Check Recovery Combo Button press or not. */
+	imx_iomux_v3_setup_multiple_pads(recovery_key_pads,
+			ARRAY_SIZE(recovery_key_pads));
+
+    gpio_direction_input(GPIO_VOL_DN_KEY);
+
+    if (gpio_get_value(GPIO_VOL_DN_KEY) == 0) { /* VOL_DN key is low assert */
+		button_pressed = 1;
+		printf("Recovery key pressed\n");
+    }
+
+    return recovery_mode || button_pressed;
+}
+
+void board_recovery_setup(void)
+{
+	int bootdev = get_boot_device();
+
+	switch (bootdev) {
+#if defined(CONFIG_FASTBOOT_STORAGE_SATA)
+	case SATA_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"boota sata recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_SATA*/
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"boota mmc0 recovery");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"boota mmc1 recovery");
+		break;
+	case MMC4_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"booti mmc2 recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("Unsupported bootup device for recovery: dev: %d\n",
+			bootdev);
+		return;
+	}
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FSL_FASTBOOT*/
+
+#ifdef CONFIG_IMX_UDC
+iomux_v3_cfg_t const otg_udc_pads[] = {
+	(MX6_PAD_ENET_RX_ER__USB_OTG_ID | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+void udc_pins_setting(void)
+{
+	imx_iomux_v3_setup_multiple_pads(otg_udc_pads,
+			ARRAY_SIZE(otg_udc_pads));
+
+	/*set daisy chain for otg_pin_id on 6q. for 6dl, this bit is reserved*/
+    mxc_iomux_set_gpr_register(1, 13, 1, 0);
+}
+#endif /*CONFIG_IMX_UDC*/
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET 0x800
+#define UCTRL_PWR_POL (1<<9)
+
+iomux_v3_cfg_t const usb_otg_pads[] = {
+	MX6_PAD_EIM_D22__USB_OTG_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_ENET_RX_ER__USB_OTG_ID | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+iomux_v3_cfg_t const usb_hc1_pads[] = {
+	MX6_PAD_GPIO_0__GPIO1_IO00 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+int board_ehci_hcd_init(int port)
+{
+	u32 * usbnc_usb_ctrl;
+
+	switch (port) {
+	case 0:
+		imx_iomux_v3_setup_multiple_pads(usb_otg_pads,
+			ARRAY_SIZE(usb_otg_pads));
+
+		/*set daisy chain for otg_pin_id on 6q. for 6dl, this bit is reserved*/
+		imx_iomux_set_gpr_register(1, 13, 1, 0);
+		break;
+	case 1:
+		imx_iomux_v3_setup_multiple_pads(usb_hc1_pads,
+			ARRAY_SIZE(usb_hc1_pads));
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
+
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+		port * 4);
+
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	switch (port) {
+	case 0:
+		break;
+	case 1:
+		if (on)
+			gpio_direction_output(IMX_GPIO_NR(1, 0), 1);
+		else
+			gpio_direction_output(IMX_GPIO_NR(1, 0), 0);
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
+	return 0;
+}
+#endif
diff --git a/board/embeddedartists/mx6qea-com/plugin.S b/board/embeddedartists/mx6qea-com/plugin.S
new file mode 100644
index 0000000..6e2a72a
--- /dev/null
+++ b/board/embeddedartists/mx6qea-com/plugin.S
@@ -0,0 +1,480 @@
+/*
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6dqsabresd_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x798]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x758]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x588]
+	str r1, [r0, #0x594]
+	str r1, [r0, #0x56c]
+	str r1, [r0, #0x578]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x57c]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x58c]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x59c]
+	str r1, [r0, #0x5a0]
+	str r1, [r0, #0x78c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x5a8]
+	str r1, [r0, #0x5b0]
+	str r1, [r0, #0x524]
+	str r1, [r0, #0x51c]
+	str r1, [r0, #0x518]
+	str r1, [r0, #0x50c]
+	str r1, [r0, #0x5b8]
+	str r1, [r0, #0x5c0]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x774]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x784]
+	str r1, [r0, #0x788]
+	str r1, [r0, #0x794]
+	str r1, [r0, #0x79c]
+	str r1, [r0, #0x7a0]
+	str r1, [r0, #0x7a4]
+	str r1, [r0, #0x7a8]
+	str r1, [r0, #0x748]
+	str r1, [r0, #0x5ac]
+	str r1, [r0, #0x5b4]
+	str r1, [r0, #0x528]
+	str r1, [r0, #0x520]
+	str r1, [r0, #0x514]
+	str r1, [r0, #0x510]
+	str r1, [r0, #0x5bc]
+	str r1, [r0, #0x5c4]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x001F001F
+	str r2, [r0, #0x80c]
+	str r2, [r0, #0x810]
+	ldr r1, =MMDC_P1_BASE_ADDR
+	str r2, [r1, #0x80c]
+	str r2, [r1, #0x810]
+
+	ldr r2, =0x43270338
+	str r2, [r0, #0x83c]
+	ldr r2, =0x03200314
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x431A032F
+	str r2, [r1, #0x83c]
+	ldr r2, =0x03200263
+	str r2, [r1, #0x840]
+
+	ldr r2, =0x4B434748
+	str r2, [r0, #0x848]
+	ldr r2, =0x4445404C
+	str r2, [r1, #0x848]
+
+	ldr r2, =0x38444542
+	str r2, [r0, #0x850]
+	ldr r2, =0x4935493A
+	str r2, [r1, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	str r2, [r1, #0x81c]
+	str r2, [r1, #0x820]
+	str r2, [r1, #0x824]
+	str r2, [r1, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x00020036
+	str r2, [r0, #0x004]
+	ldr r2, =0x09444040
+	str r2, [r0, #0x008]
+
+	ldr r2, =0x555A7975
+	str r2, [r0, #0x00c]
+	ldr r2, =0xFF538F64
+	str r2, [r0, #0x010]
+
+	ldr r2, =0x01FF00DB
+	str r2, [r0, #0x014]
+	ldr r2, =0x00001740
+	str r2, [r0, #0x018]
+
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x005A1023
+	str r2, [r0, #0x030]
+	ldr r2, =0x00000027
+	str r2, [r0, #0x040]
+
+	ldr r2, =0x831A0000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x04088032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00048031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x09408030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00005800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00011117
+	str r2, [r0, #0x818]
+	str r2, [r1, #0x818]
+	ldr r2, =0x00025576
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+
+.macro imx6dlsabresd_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x774]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x754]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4ac]
+	str r1, [r0, #0x4b0]
+	str r1, [r0, #0x464]
+	str r1, [r0, #0x490]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x494]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4a0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4b4]
+	str r1, [r0, #0x4b8]
+	str r1, [r0, #0x76c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4bc]
+	str r1, [r0, #0x4c0]
+	str r1, [r0, #0x4c4]
+	str r1, [r0, #0x4c8]
+	str r1, [r0, #0x4cc]
+	str r1, [r0, #0x4d0]
+	str r1, [r0, #0x4d4]
+	str r1, [r0, #0x4d8]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x760]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x764]
+	str r1, [r0, #0x770]
+	str r1, [r0, #0x778]
+	str r1, [r0, #0x77c]
+	str r1, [r0, #0x780]
+	str r1, [r0, #0x784]
+	str r1, [r0, #0x78c]
+	str r1, [r0, #0x748]
+	str r1, [r0, #0x470]
+	str r1, [r0, #0x474]
+	str r1, [r0, #0x478]
+	str r1, [r0, #0x47c]
+	str r1, [r0, #0x480]
+	str r1, [r0, #0x484]
+	str r1, [r0, #0x488]
+	str r1, [r0, #0x48c]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x001f001f
+	str r2, [r0, #0x80c]
+	str r2, [r0, #0x810]
+	ldr r1, =MMDC_P1_BASE_ADDR
+	str r2, [r1, #0x80c]
+	str r2, [r1, #0x810]
+
+	ldr r2, =0x4220021F
+	str r2, [r0, #0x83c]
+	ldr r2, =0x0207017E
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x4201020C
+	str r2, [r1, #0x83c]
+	ldr r2, =0x01660172
+	str r2, [r1, #0x840]
+
+	ldr r2, =0x4A4D4E4D
+	str r2, [r0, #0x848]
+	ldr r2, =0x4A4F5049
+	str r2, [r1, #0x848]
+
+	ldr r2, =0x3F3C3D31
+	str r2, [r0, #0x850]
+	ldr r2, =0x3238372B
+	str r2, [r1, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	str r2, [r1, #0x81c]
+	str r2, [r1, #0x820]
+	str r2, [r1, #0x824]
+	str r2, [r1, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x0002002D
+	str r2, [r0, #0x004]
+	ldr r2, =0x00333030
+	str r2, [r0, #0x008]
+
+	ldr r2, =0x3F435313
+	str r2, [r0, #0x00c]
+	ldr r2, =0xB66E8B63
+	str r2, [r0, #0x010]
+
+	ldr r2, =0x01FF00DB
+	str r2, [r0, #0x014]
+	ldr r2, =0x00001740
+	str r2, [r0, #0x018]
+
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x00431023
+	str r2, [r0, #0x030]
+	ldr r2, =0x00000027
+	str r2, [r0, #0x040]
+
+	ldr r2, =0x831A0000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x04008032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00048031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x05208030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00005800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00011117
+	str r2, [r0, #0x818]
+	str r2, [r1, #0x818]
+	ldr r2, =0x0002556D
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+
+.macro imx6solosabresd_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x774]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x754]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4ac]
+	str r1, [r0, #0x4b0]
+	str r1, [r0, #0x464]
+	str r1, [r0, #0x490]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x494]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4a0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4b4]
+	str r1, [r0, #0x4b8]
+	str r1, [r0, #0x76c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4bc]
+	str r1, [r0, #0x4c0]
+	str r1, [r0, #0x4c4]
+	str r1, [r0, #0x4c8]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x760]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x764]
+	str r1, [r0, #0x770]
+	str r1, [r0, #0x778]
+	str r1, [r0, #0x77c]
+	str r1, [r0, #0x470]
+	str r1, [r0, #0x474]
+	str r1, [r0, #0x478]
+	str r1, [r0, #0x47c]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x001F001F
+	str r2, [r0, #0x80c]
+	str r2, [r0, #0x810]
+
+	ldr r2, =0x42190219
+	str r2, [r0, #0x83c]
+	ldr r2, =0x017B0177
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x4B4D4E4D
+	str r2, [r0, #0x848]
+
+	ldr r2, =0x3F3E2D36
+	str r2, [r0, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+
+	ldr r2, =0x0002002D
+	str r2, [r0, #0x004]
+	ldr r2, =0x00333030
+	str r2, [r0, #0x008]
+
+	ldr r2, =0x3F435313
+	str r2, [r0, #0x00c]
+	ldr r2, =0xB66E8B63
+	str r2, [r0, #0x010]
+
+	ldr r2, =0x01FF00DB
+	str r2, [r0, #0x014]
+	ldr r2, =0x00001740
+	str r2, [r0, #0x018]
+
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x00431023
+	str r2, [r0, #0x030]
+	ldr r2, =0x00000017
+	str r2, [r0, #0x040]
+
+	ldr r2, =0x83190000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x04008032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00048031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x05208030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00005800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00011117
+	str r2, [r0, #0x818]
+	ldr r2, =0x0002556D
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0x00C03F3F
+	str r1, [r0, #0x068]
+	ldr r1, =0x0030FC03
+	str r1, [r0, #0x06c]
+	ldr r1, =0x0FFFC000
+	str r1, [r0, #0x070]
+	ldr r1, =0x3FF00000
+	str r1, [r0, #0x074]
+	ldr r1, =0x00FFF300
+	str r1, [r0, #0x078]
+	ldr r1, =0x0F0000C3
+	str r1, [r0, #0x07c]
+	ldr r1, =0x000003FF
+	str r1, [r0, #0x080]
+.endm
+
+.macro imx6_qos_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0xF00000CF
+	str r1, [r0, #0x10]
+
+	ldr r1, =0x007F007F
+	str r1, [r0, #0x18]
+	str r1, [r0, #0x1c]
+.endm
+
+.macro imx6_ddr_setting
+#if defined (CONFIG_MX6SOLO)
+	imx6solosabresd_ddr_setting
+#elif defined (CONFIG_MX6DL)
+	imx6dlsabresd_ddr_setting
+#elif defined (CONFIG_MX6Q)
+	imx6dqsabresd_ddr_setting
+#else
+	#error "SOC not configured"
+#endif
+
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff --git a/board/embeddedartists/mx6sxea-com/Kconfig b/board/embeddedartists/mx6sxea-com/Kconfig
new file mode 100644
index 0000000..d135fb8
--- /dev/null
+++ b/board/embeddedartists/mx6sxea-com/Kconfig
@@ -0,0 +1,15 @@
+if TARGET_MX6SXEA_COM
+
+config SYS_BOARD
+	default "mx6sxea-com"
+
+config SYS_VENDOR
+	default "embeddedartists"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "mx6sxea-com"
+
+endif
diff --git a/board/embeddedartists/mx6sxea-com/MAINTAINERS b/board/embeddedartists/mx6sxea-com/MAINTAINERS
new file mode 100644
index 0000000..3fc02f2
--- /dev/null
+++ b/board/embeddedartists/mx6sxea-com/MAINTAINERS
@@ -0,0 +1,6 @@
+MX6ULEA-COM BOARD
+M:	Andreas Rebert <imx@embeddedartists.com>
+S:	Maintained
+F:	board/embeddedartists/mx6sxea-com/
+F:	include/configs/mx6sxea-com.h
+F:	configs/mx6sxea-com_defconfig
diff --git a/board/embeddedartists/mx6sxea-com/Makefile b/board/embeddedartists/mx6sxea-com/Makefile
new file mode 100644
index 0000000..ac89416
--- /dev/null
+++ b/board/embeddedartists/mx6sxea-com/Makefile
@@ -0,0 +1,8 @@
+# (C) Copyright 2015 Embedded Artists AB
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  += mx6sxea-com.o
+
+
diff --git a/board/embeddedartists/mx6sxea-com/imximage.cfg b/board/embeddedartists/mx6sxea-com/imximage.cfg
new file mode 100644
index 0000000..35e4cd3
--- /dev/null
+++ b/board/embeddedartists/mx6sxea-com/imximage.cfg
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sxsabresd/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF 0x2000
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+/* Enable all clocks */
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+DATA 4 0x020c4084 0xffffffff
+
+/* IOMUX */
+/* DDR IO TYPE */
+DATA 4 0x020e0618 0x000c0000
+DATA 4 0x020e05fc 0x00000000
+
+/* CLOCK */
+DATA 4 0x020e032c 0x00000030
+
+/* ADDRESS */
+DATA 4 0x020e0300 0x00000020
+DATA 4 0x020e02fc 0x00000020
+DATA 4 0x020e05f4 0x00000020
+
+/* CONTROL */
+DATA 4 0x020e0340 0x00000020
+
+DATA 4 0x020e0320 0x00000000
+DATA 4 0x020e0310 0x00000020
+DATA 4 0x020e0314 0x00000020
+DATA 4 0x020e0614 0x00000020
+
+/* DATA STROBE */
+DATA 4 0x020e05f8 0x00020000
+DATA 4 0x020e0330 0x00000028
+DATA 4 0x020e0334 0x00000028
+DATA 4 0x020e0338 0x00000028
+DATA 4 0x020e033c 0x00000028
+
+/* DATA */
+DATA 4 0x020e0608 0x00020000
+DATA 4 0x020e060c 0x00000028
+DATA 4 0x020e0610 0x00000028
+DATA 4 0x020e061c 0x00000028
+DATA 4 0x020e0620 0x00000028
+DATA 4 0x020e02ec 0x00000028
+DATA 4 0x020e02f0 0x00000028
+DATA 4 0x020e02f4 0x00000028
+DATA 4 0x020e02f8 0x00000028
+
+/* Calibrations */
+/* ZQ */
+DATA 4 0x021b0800 0xa1390003
+
+/* write leveling */
+DATA 4 0x021b080c 0x00270023
+DATA 4 0x021b0810 0x00260025
+
+/* DQS Read Gate */
+DATA 4 0x021b083c 0x41480148
+DATA 4 0x021b0840 0x01340130
+
+/* Read/Write Delay */
+DATA 4 0x021b0848 0x40424248
+DATA 4 0x021b0850 0x36343a38
+
+/* read data bit delay */
+DATA 4 0x021b081c 0x33333333
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+
+/* Complete calibration by forced measurment */
+DATA 4 0x021b08b8 0x00000800
+
+/* MMDC init */
+/* in DDR3, 64-bit mode, only MMDC0 is initiated */
+DATA 4 0x021b0004 0x0002002d
+DATA 4 0x021b0008 0x00333030
+DATA 4 0x021b000c 0x676b52f3
+DATA 4 0x021b0010 0xb66d8b63
+DATA 4 0x021b0014 0x01ff00db
+DATA 4 0x021b0018 0x00011740
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b002c 0x000026d2
+DATA 4 0x021b0030 0x006b1023
+DATA 4 0x021b0040 0x0000005f
+DATA 4 0x021b0000 0x84190000
+
+/* Initialize MT41K256M16HA-125 */
+/* MR2 */
+DATA 4 0x021b001c 0x04008032
+/* MR3 */
+DATA 4 0x021b001c 0x00008033
+/* MR1 */
+DATA 4 0x021b001c 0x00048031
+/* MR0 */
+DATA 4 0x021b001c 0x05208030
+/* DDR device ZQ calibration */
+DATA 4 0x021b001c 0x04008040
+
+/* final DDR setup, before operation start */
+DATA 4 0x021b0020 0x00000800
+DATA 4 0x021b0818 0x00011117
+DATA 4 0x021b001c 0x00000000
+#endif
diff --git a/board/embeddedartists/mx6sxea-com/mx6sxea-com.c b/board/embeddedartists/mx6sxea-com/mx6sxea-com.c
new file mode 100644
index 0000000..c1b9c70
--- /dev/null
+++ b/board/embeddedartists/mx6sxea-com/mx6sxea-com.c
@@ -0,0 +1,1295 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#if defined(CONFIG_CMD_EADISP)
+#include <asm/imx-common/eadisp.h>
+#include <asm/imx-common/eatouch.h>
+#endif
+#include <asm/io.h>
+#include <linux/sizes.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <mmc.h>
+#include <miiphy.h>
+#include <netdev.h>
+#ifdef CONFIG_SYS_I2C_MXC
+#include <i2c.h>
+#include <asm/imx-common/mxc_i2c.h>
+#endif
+
+#include <usb.h>
+#include <usb/ehci-fsl.h>
+
+#ifdef CONFIG_MXC_RDC
+#include <asm/imx-common/rdc-sema.h>
+#include <asm/arch/imx-rdc.h>
+#endif
+
+#ifdef CONFIG_VIDEO_MXS
+#include <linux/fb.h>
+#include <mxsfb.h>
+#endif
+
+#ifdef CONFIG_FSL_FASTBOOT
+#include <fsl_fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FSL_FASTBOOT*/
+
+#include "../common/mx6ea_eeprom.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+	PAD_CTL_SPEED_HIGH   |                                   \
+	PAD_CTL_DSE_48ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_CLK_PAD_CTRL  (PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_120ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_RX_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |          \
+	PAD_CTL_SPEED_HIGH   | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE)
+
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+	PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define BUTTON_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE | \
+	PAD_CTL_PUS_22K_UP | PAD_CTL_DSE_40ohm)
+
+#define WDOG_PAD_CTRL (PAD_CTL_PUE | PAD_CTL_PKE | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm)
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_GPIO1_IO00__I2C1_SCL | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO00__GPIO1_IO_0 | PC,
+		.gp = IMX_GPIO_NR(1, 0),
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_GPIO1_IO01__I2C1_SDA | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO01__GPIO1_IO_1 | PC,
+		.gp = IMX_GPIO_NR(1, 1),
+	},
+};
+
+/* I2C2 */
+struct i2c_pads_info i2c_pad_info2 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_GPIO1_IO02__I2C2_SCL | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO02__GPIO1_IO_2 | PC,
+		.gp = IMX_GPIO_NR(1, 2),
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_GPIO1_IO03__I2C2_SDA | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO03__GPIO1_IO_3 | PC,
+		.gp = IMX_GPIO_NR(1, 3),
+	},
+};
+#endif
+
+int dram_init(void)
+{
+	ea_eeprom_config_t config;
+
+	// default size from configuration file
+	gd->ram_size = PHYS_SDRAM_SIZE;
+
+	// getting actual size from eeprom configuration
+
+	if (ea_eeprom_get_config(&config) == 0) {
+		gd->ram_size = (config.ddr_size << 20);
+	}
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX6_PAD_GPIO1_IO04__UART1_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_GPIO1_IO05__UART1_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	MX6_PAD_SD2_CLK__USDHC2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_CMD__USDHC2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA0__USDHC2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA1__USDHC2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA2__USDHC2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA3__USDHC2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc3_pads[] = {
+	MX6_PAD_SD3_CLK__USDHC3_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_CMD__USDHC3_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA0__USDHC3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA1__USDHC3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA2__USDHC3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA3__USDHC3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA4__USDHC3_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA5__USDHC3_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA6__USDHC3_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA7__USDHC3_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* CD pin */
+	MX6_PAD_KEY_COL0__GPIO2_IO_10 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* RST_B, used for power reset cycle */
+	MX6_PAD_KEY_COL1__GPIO2_IO_11 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc4_pads[] = {
+	MX6_PAD_SD4_CLK__USDHC4_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_CMD__USDHC4_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA0__USDHC4_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA1__USDHC4_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA2__USDHC4_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA3__USDHC4_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* CD pin */
+	MX6_PAD_SD4_DATA7__GPIO6_IO_21 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc4_emmc_pads[] = {
+	MX6_PAD_SD4_CLK__USDHC4_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_CMD__USDHC4_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA0__USDHC4_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA1__USDHC4_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA2__USDHC4_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA3__USDHC4_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA4__USDHC4_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA5__USDHC4_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA6__USDHC4_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA7__USDHC4_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_RESET_B__USDHC4_RESET_B | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+
+static iomux_v3_cfg_t const peri_3v3_pads[] = {
+	MX6_PAD_QSPI1B_DATA2__GPIO4_IO_26 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const wdog_b_pad = {
+	MX6_PAD_GPIO1_IO13__GPIO1_IO_13 | MUX_PAD_CTRL(WDOG_PAD_CTRL),
+};
+
+#ifdef CONFIG_FEC_MXC
+static iomux_v3_cfg_t const fec1_pads[] = {
+	MX6_PAD_ENET1_MDC__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_MDIO__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_RX_CTL__ENET1_RX_EN | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RD0__ENET1_RX_DATA_0 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RD1__ENET1_RX_DATA_1 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RD2__ENET1_RX_DATA_2 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RD3__ENET1_RX_DATA_3 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RXC__ENET1_RX_CLK | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_TX_CTL__ENET1_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_TD0__ENET1_TX_DATA_0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_TD1__ENET1_TX_DATA_1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_TD2__ENET1_TX_DATA_2 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_TD3__ENET1_TX_DATA_3 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_TXC__ENET1_RGMII_TXC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const fec2_pads[] = {
+	MX6_PAD_ENET1_MDC__ENET2_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_MDIO__ENET2_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII2_RX_CTL__ENET2_RX_EN | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII2_RD0__ENET2_RX_DATA_0 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII2_RD1__ENET2_RX_DATA_1 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII2_RD2__ENET2_RX_DATA_2 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII2_RD3__ENET2_RX_DATA_3 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII2_RXC__ENET2_RX_CLK | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII2_TX_CTL__ENET2_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII2_TD0__ENET2_TX_DATA_0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII2_TD1__ENET2_TX_DATA_1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII2_TD2__ENET2_TX_DATA_2 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII2_TD3__ENET2_TX_DATA_3 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII2_TXC__ENET2_RGMII_TXC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const phy_control_pads[] = {
+	/* Phy 25M Clock */
+	MX6_PAD_ENET2_RX_CLK__ENET2_REF_CLK_25M | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
+
+	/* ENET PHY Power */
+	MX6_PAD_ENET1_COL__GPIO2_IO_0 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* AR8031 PHY Reset. */
+	MX6_PAD_ENET2_CRS__GPIO2_IO_7 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_iomux_fec(int fec_id)
+{
+	if (0 == fec_id)
+		imx_iomux_v3_setup_multiple_pads(fec1_pads, ARRAY_SIZE(fec1_pads));
+	else
+		imx_iomux_v3_setup_multiple_pads(fec2_pads, ARRAY_SIZE(fec2_pads));
+}
+#endif
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_FSL_QSPI
+
+#define QSPI_PAD_CTRL1	\
+		(PAD_CTL_SRE_FAST | PAD_CTL_SPEED_MED | \
+		 PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_47K_UP | PAD_CTL_DSE_60ohm)
+
+static iomux_v3_cfg_t const quadspi_pads[] = {
+	MX6_PAD_NAND_WP_B__QSPI2_A_DATA_0		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_READY_B__QSPI2_A_DATA_1	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE0_B__QSPI2_A_DATA_2	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE1_B__QSPI2_A_DATA_3	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_ALE__QSPI2_A_SS0_B		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CLE__QSPI2_A_SCLK		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA07__QSPI2_A_DQS		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA01__QSPI2_B_DATA_0	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA00__QSPI2_B_DATA_1	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_WE_B__QSPI2_B_DATA_2		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_RE_B__QSPI2_B_DATA_3		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA03__QSPI2_B_SS0_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA02__QSPI2_B_SCLK		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA05__QSPI2_B_DQS		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+};
+
+int board_qspi_init(void)
+{
+	/* Set the iomux */
+	imx_iomux_v3_setup_multiple_pads(quadspi_pads, ARRAY_SIZE(quadspi_pads));
+
+	/* Set the clock */
+	enable_qspi_clk(1);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+static struct fsl_esdhc_cfg usdhc_cfg[3] = {
+	{USDHC2_BASE_ADDR, 0, 4},
+	{USDHC3_BASE_ADDR},
+#ifdef CONFIG_MX6SXSABRESD_EMMC_REWORK
+	{USDHC4_BASE_ADDR, 0, 8},
+#else
+	{USDHC4_BASE_ADDR, 0, 4},
+#endif
+};
+
+#define USDHC2_PWR_GPIO	IMX_GPIO_NR(6, 22)
+#define USDHC3_CD_GPIO	IMX_GPIO_NR(2, 10)
+#define USDHC3_PWR_GPIO	IMX_GPIO_NR(2, 11)
+#define USDHC4_CD_GPIO	IMX_GPIO_NR(6, 21)
+
+int mmc_get_env_devno(void)
+{
+	u32 soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	int dev_no;
+	u32 bootsel;
+
+	bootsel = (soc_sbmr & 0x000000FF) >> 6 ;
+
+	/* If not boot from sd/mmc, use default value */
+	if (bootsel != 1)
+		return CONFIG_SYS_MMC_ENV_DEV;
+
+	/* BOOT_CFG2[3] and BOOT_CFG2[4] */
+	dev_no = (soc_sbmr & 0x00001800) >> 11;
+
+	/* need ubstract 1 to map to the mmc device id
+	 * see the comments in board_mmc_init function
+	 */
+
+	dev_no--;
+
+	return dev_no;
+}
+
+int mmc_map_to_kernel_blk(int dev_no)
+{
+	return dev_no + 1;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC2_BASE_ADDR:
+		ret = 1; /* Assume uSDHC2 is always present */
+		break;
+	case USDHC3_BASE_ADDR:
+		ret = !gpio_get_value(USDHC3_CD_GPIO);
+		break;
+	case USDHC4_BASE_ADDR:
+#ifdef CONFIG_MX6SXSABRESD_EMMC_REWORK
+		ret = 1;
+#else
+		ret = !gpio_get_value(USDHC4_CD_GPIO);
+#endif
+		break;
+	}
+
+	return ret;
+
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int i;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC2
+	 * mmc1                    USDHC3
+	 * mmc2                    USDHC4
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+#if defined(CONFIG_SPL_BUILD)
+
+		// The SPL framework expects there to be only one MMC device
+		// and we always loads u-boot from eMMC which is mapped to mmc1
+		if (i != 1) continue;
+#endif
+
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+			gpio_direction_output(USDHC2_PWR_GPIO, 1);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			break;
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+			gpio_direction_input(USDHC3_CD_GPIO);
+			gpio_direction_output(USDHC3_PWR_GPIO, 1);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		case 2:
+#ifdef CONFIG_MX6SXSABRESD_EMMC_REWORK
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc4_emmc_pads, ARRAY_SIZE(usdhc4_emmc_pads));
+#else
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc4_pads, ARRAY_SIZE(usdhc4_pads));
+			gpio_direction_input(USDHC4_CD_GPIO);
+#endif
+			usdhc_cfg[2].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) than supported by the board\n", i + 1);
+			return 0;
+			}
+
+			if (fsl_esdhc_initialize(bis, &usdhc_cfg[i]))
+				printf("Warning: failed to initialize mmc dev %d\n", i);
+	}
+
+	return 0;
+}
+
+int check_mmc_autodetect(void)
+{
+	char *autodetect_str = getenv("mmcautodetect");
+
+	if ((autodetect_str != NULL) &&
+		(strcmp(autodetect_str, "yes") == 0)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+void board_late_mmc_init(void)
+{
+	char cmd[32];
+	char mmcblk[32];
+	u32 dev_no = mmc_get_env_devno();
+
+	if (!check_mmc_autodetect())
+		return;
+
+	setenv_ulong("mmcdev", dev_no);
+
+	/* Set mmcblk env */
+	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
+		mmc_map_to_kernel_blk(dev_no));
+	setenv("mmcroot", mmcblk);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
+}
+
+#endif
+
+#ifdef CONFIG_VIDEO_MXS
+static iomux_v3_cfg_t const lvds_ctrl_pads[] = {
+	/* CABC enable */
+	MX6_PAD_ENET1_CRS__GPIO2_IO_1 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* Use GPIO for Brightness adjustment, duty cycle = period */
+	MX6_PAD_USB_H_STROBE__GPIO7_IO_11 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* Backlight power enable */
+	MX6_PAD_GPIO1_IO09__GPIO1_IO_9 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const lcd_pads[] = {
+	MX6_PAD_LCD1_CLK__LCDIF1_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_ENABLE__LCDIF1_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_HSYNC__LCDIF1_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_VSYNC__LCDIF1_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA00__LCDIF1_DATA_0 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA01__LCDIF1_DATA_1 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA02__LCDIF1_DATA_2 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA03__LCDIF1_DATA_3 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA04__LCDIF1_DATA_4 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA05__LCDIF1_DATA_5 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA06__LCDIF1_DATA_6 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA07__LCDIF1_DATA_7 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA08__LCDIF1_DATA_8 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA09__LCDIF1_DATA_9 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA10__LCDIF1_DATA_10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA11__LCDIF1_DATA_11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA12__LCDIF1_DATA_12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA13__LCDIF1_DATA_13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA14__LCDIF1_DATA_14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA15__LCDIF1_DATA_15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA16__LCDIF1_DATA_16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA17__LCDIF1_DATA_17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA18__LCDIF1_DATA_18 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA19__LCDIF1_DATA_19 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA20__LCDIF1_DATA_20 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA21__LCDIF1_DATA_21 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA22__LCDIF1_DATA_22 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA23__LCDIF1_DATA_23 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_RESET__GPIO3_IO_27 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* Use GPIO for Brightness adjustment, duty cycle = period */
+	MX6_PAD_USB_H_DATA__GPIO7_IO_10 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* CABC enable */
+	MX6_PAD_ENET1_CRS__GPIO2_IO_1 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* Backlight power enable */
+	MX6_PAD_GPIO1_IO09__GPIO1_IO_9 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+
+#ifdef CONFIG_CMD_EADISP
+void board_enable_lvds0(const struct display_info_t *di, int enable)
+{
+	static u32 base_addr = LCDIF2_BASE_ADDR;
+	if (enable) {
+		enable_lcdif_clock(base_addr);
+		enable_lvds(base_addr);
+
+		imx_iomux_v3_setup_multiple_pads(lvds_ctrl_pads,
+						ARRAY_SIZE(lvds_ctrl_pads));
+		mdelay(100); /* let panel sync up before enabling backlight */
+
+		/* Enable CABC */
+		gpio_direction_output(IMX_GPIO_NR(2, 1) , 1);
+
+		/* Set Brightness to high */
+		gpio_direction_output(IMX_GPIO_NR(7, 11) , 1);
+
+		/* Backlight power enable */
+		gpio_direction_output(IMX_GPIO_NR(1, 9) , 1);
+	}
+}
+
+void board_enable_rgb(const struct display_info_t *di, int enable)
+{
+	static u32 base_addr = LCDIF1_BASE_ADDR;
+	if (enable) {
+		enable_lcdif_clock(base_addr);
+		imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+		mdelay(100); /* let panel sync up before enabling backlight */
+
+		/* Power up the LCD */
+		gpio_direction_output(IMX_GPIO_NR(2, 1) , 1);
+
+		/* Set Brightness to high */
+		gpio_direction_output(IMX_GPIO_NR(7, 10) , 1);
+
+		/* Backlight power enable */
+		gpio_direction_output(IMX_GPIO_NR(1, 9) , 1);
+	}
+}
+
+static const struct display_info_t displays[] = {
+	/* LVDS */
+	EADISP_HANNSTAR10(LVDS0, 0, 0),
+
+	/* RGB */
+	EADISP_INNOLUX_AT070TN(RGB, 0, 0),
+	EADISP_NHD_43480272EF(RGB, 0, 0),
+	EADISP_NHD_50800480TF(RGB, 0, 0),
+	EADISP_NHD_70800480EF(RGB, 0, 0),
+	EADISP_UMSH_8864(RGB, 0, 0),
+	EADISP_UMSH_8596_30T(RGB, 0, 0),
+	EADISP_UMSH_8596_33T(RGB, 0, 0),
+	EADISP_ROGIN_RX050A(RGB, 0, 0),
+};
+
+#else /* CONFIG_CMD_EADISP */
+
+struct lcd_panel_info_t {
+	unsigned int lcdif_base_addr;
+	int depth;
+	void	(*enable)(struct lcd_panel_info_t const *dev);
+	struct fb_videomode mode;
+};
+
+void do_enable_lvds(struct lcd_panel_info_t const *dev)
+{
+	enable_lcdif_clock(dev->lcdif_base_addr);
+	enable_lvds(dev->lcdif_base_addr);
+
+	imx_iomux_v3_setup_multiple_pads(lvds_ctrl_pads,
+							ARRAY_SIZE(lvds_ctrl_pads));
+
+	/* Enable CABC */
+	gpio_direction_output(IMX_GPIO_NR(2, 1) , 1);
+
+	/* Set Brightness to high */
+	gpio_direction_output(IMX_GPIO_NR(7, 11) , 1);
+
+	/* Backlight power enable */
+	gpio_direction_output(IMX_GPIO_NR(1, 9) , 1);
+}
+
+void do_enable_parallel_lcd(struct lcd_panel_info_t const *dev)
+{
+	enable_lcdif_clock(dev->lcdif_base_addr);
+
+	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+
+	/* Power up the LCD */
+	gpio_direction_output(IMX_GPIO_NR(2, 1) , 1);
+
+	/* Set Brightness to high */
+	gpio_direction_output(IMX_GPIO_NR(7, 10) , 1);
+
+	/* Backlight power enable */
+	gpio_direction_output(IMX_GPIO_NR(1, 9) , 1);
+}
+
+static struct lcd_panel_info_t const displays[] = {{
+	.lcdif_base_addr = LCDIF2_BASE_ADDR,
+	.depth = 18,
+	.enable	= do_enable_lvds,
+	.mode	= {
+		.name			= "Hannstar-XGA",
+		.xres           = 1024,
+		.yres           = 768,
+		.pixclock       = 15385,
+		.left_margin    = 220,
+		.right_margin   = 40,
+		.upper_margin   = 21,
+		.lower_margin   = 7,
+		.hsync_len      = 60,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} }, {
+	.lcdif_base_addr = LCDIF1_BASE_ADDR,
+	.depth = 24,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+		.name			= "Innolux-AT070TN",
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 29850,
+		.left_margin    = 89,
+		.right_margin   = 164,
+		.upper_margin   = 75,
+		.lower_margin   = 75,
+		.hsync_len      = 10,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+
+int board_video_skip(void)
+{
+	int i;
+	int ret;
+	char const *panel = getenv("panel");
+	if (!panel) {
+		panel = displays[0].mode.name;
+		printf("No panel detected: default to %s\n", panel);
+		i = 0;
+	} else {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			if (!strcmp(panel, displays[i].mode.name))
+				break;
+		}
+	}
+	if (i < ARRAY_SIZE(displays)) {
+		ret = mxs_lcd_panel_setup(displays[i].mode, displays[i].depth,
+				    displays[i].lcdif_base_addr);
+		if (!ret) {
+			if (displays[i].enable)
+				displays[i].enable(displays+i);
+			printf("Display: %s (%ux%u)\n",
+			       displays[i].mode.name,
+			       displays[i].mode.xres,
+			       displays[i].mode.yres);
+		} else
+			printf("LCD %s cannot be configured: %d\n",
+			       displays[i].mode.name, ret);
+	} else {
+		printf("unsupported panel %s\n", panel);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#endif /* CONFIG_CMD_EADISP */
+#endif /* CONFIG_VIDEO_MXS */
+
+#ifdef CONFIG_FEC_MXC
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+	ea_eeprom_config_t config;
+
+	setup_iomux_fec(CONFIG_FEC_ENET_DEV);
+
+	ret = fecmxc_initialize_multi(bis, CONFIG_FEC_ENET_DEV,
+		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+	if (ret)
+		printf("FEC%d MXC: %s:failed\n", CONFIG_FEC_ENET_DEV, __func__);
+
+	/* stored MAC addresses to env variables */
+	if (ea_eeprom_get_config(&config) == 0) {
+
+		if (is_valid_ether_addr(config.mac1) && !getenv("ethaddr")) {
+			eth_setenv_enetaddr("ethaddr", config.mac1);
+		}
+
+		if (is_valid_ether_addr(config.mac2) && !getenv("eth1addr")) {
+			eth_setenv_enetaddr("eth1addr", config.mac2);
+		}
+
+		if (is_valid_ether_addr(config.mac3) && !getenv("eth2addr")) {
+			eth_setenv_enetaddr("eth2addr", config.mac3);
+		}
+
+		if (is_valid_ether_addr(config.mac4) && !getenv("eth3addr")) {
+			eth_setenv_enetaddr("eth3addr", config.mac4);
+		}
+
+	}
+
+	return 0;
+}
+
+static int setup_fec(int fec_id)
+{
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *) IOMUXC_GPR_BASE_ADDR;
+
+	if (0 == fec_id)
+		/* Use 125M anatop loopback REF_CLK1 for ENET1, clear gpr1[13], gpr1[17]*/
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC1_MASK, 0);
+	else
+		/* Use 125M anatop loopback REF_CLK1 for ENET2, clear gpr1[14], gpr1[18]*/
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC2_MASK, 0);
+
+	imx_iomux_v3_setup_multiple_pads(phy_control_pads,
+		ARRAY_SIZE(phy_control_pads));
+
+	/* Enable the ENET power, active low */
+	gpio_direction_output(IMX_GPIO_NR(2, 0) , 0);
+
+	/* Reset AR8031 PHY */
+	gpio_direction_output(IMX_GPIO_NR(2, 7) , 0);
+	udelay(500);
+	gpio_set_value(IMX_GPIO_NR(2, 7), 1);
+
+	return enable_fec_anatop_clock(fec_id, ENET_125MHZ);
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	/* Enable 1.8V(SEL_1P5_1P8_POS_REG) on
+	   Phy control debug reg 0 */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x1f);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x8);
+
+	/* rgmii tx clock delay enable */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x05);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x100);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+
+void board_get_hwaddr(int dev_id, unsigned char *mac)
+{
+	ea_eeprom_config_t config;
+
+	if (ea_eeprom_get_config(&config) == 0) {
+		if (dev_id == 0) {
+			memcpy(mac, config.mac1, 6);
+		}
+		else {
+			memcpy(mac, config.mac2, 6);
+		}
+	}
+
+}
+
+#endif
+
+#ifdef CONFIG_SYS_I2C_MXC
+static int disable_ar1021(void)
+{
+        unsigned char cmd[] = { 0x55, 0x01, 0x13 };
+
+        i2c_set_bus_num(0);
+        if (!i2c_probe(0x4d)) {
+
+                if (i2c_write(0x4d, 0x00, 1, cmd, 3)) {
+                        printf("Failed to disable AR1021!\n");
+                        return -1;
+                }
+	}
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PFUZE100_PMIC_I2C
+#define PFUZE100_DEVICEID	0x0
+#define PFUZE100_REVID		0x3
+#define PFUZE100_FABID		0x4
+
+#define PFUZE100_SW1ABVOL	0x20
+#define PFUZE100_SW1ABSTBY	0x21
+#define PFUZE100_SW1ABCONF	0x24
+#define PFUZE100_SW1CVOL	0x2e
+#define PFUZE100_SW1CSTBY	0x2f
+#define PFUZE100_SW1CCONF	0x32
+#define PFUZE100_SW1ABC_SETP(x)	((x - 3000) / 250)
+#define PFUZE100_VGEN5CTL	0x70
+
+/* set all switches APS in normal and PFM mode in standby */
+static int setup_pmic_mode(int chip)
+{
+	unsigned char offset, i, switch_num, value;
+
+	if (!chip) {
+		/* pfuze100 */
+		switch_num = 6;
+		offset = 0x31;
+	} else {
+		/* pfuze200 */
+		switch_num = 4;
+		offset = 0x38;
+	}
+
+	value = 0xc;
+	if (i2c_write(0x8, 0x23, 1, &value, 1)) {
+		printf("Set SW1AB mode error!\n");
+		return -1;
+	}
+
+	for (i = 0; i < switch_num - 1; i++) {
+		if (i2c_write(0x8, offset + i * 7, 1, &value, 1)) {
+			printf("Set switch%x mode error!\n", offset);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int setup_pmic_voltages(void)
+{
+	unsigned char value, rev_id = 0;
+
+	i2c_set_bus_num(CONFIG_PMIC_I2C_BUS);
+
+	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_PMIC_I2C_SLAVE);
+	if (!i2c_probe(CONFIG_PMIC_I2C_SLAVE)) {
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_DEVICEID, 1, &value, 1)) {
+			printf("Read device ID error!\n");
+			return -1;
+		}
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_REVID, 1, &rev_id, 1)) {
+			printf("Read Rev ID error!\n");
+			return -1;
+		}
+		/*
+		 * PFUZE200: Die version 0001 = PF0200
+		 * PFUZE100: Die version 0000 = PF0100
+		 */
+		printf("Found %s! deviceid 0x%x, revid 0x%x\n", (value & 0xf) ?
+		       "PFUZE200" : "PFUZE100", value & 0xf, rev_id);
+
+		if (setup_pmic_mode(value & 0xf)) {
+			printf("setup pmic mode error!\n");
+			return -1;
+		}
+		/* set SW1AB standby volatage 0.975V */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABSTBY, 1, &value, 1)) {
+			printf("Read SW1ABSTBY error!\n");
+			return -1;
+		}
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(9750);
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABSTBY, 1, &value, 1)) {
+			printf("Set SW1ABSTBY error!\n");
+			return -1;
+		}
+
+		/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABCONF, 1, &value, 1)) {
+			printf("Read SW1ABCONFIG error!\n");
+			return -1;
+		}
+		value &= ~0xc0;
+		value |= 0x40;
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABCONF, 1, &value, 1)) {
+			printf("Set SW1ABCONFIG error!\n");
+			return -1;
+		}
+
+		/* set SW1C standby volatage 0.975V */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CSTBY, 1, &value, 1)) {
+			printf("Read SW1CSTBY error!\n");
+			return -1;
+		}
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(9750);
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CSTBY, 1, &value, 1)) {
+			printf("Set SW1CSTBY error!\n");
+			return -1;
+		}
+
+		/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CCONF, 1, &value, 1)) {
+			printf("Read SW1CCONFIG error!\n");
+			return -1;
+		}
+		value &= ~0xc0;
+		value |= 0x40;
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CCONF, 1, &value, 1)) {
+			printf("Set SW1CCONFIG error!\n");
+			return -1;
+		}
+
+		/* Enable power of VGEN5 3V3, needed for SD3 */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_VGEN5CTL, 1, &value, 1)) {
+			printf("Read VGEN5CTL error!\n");
+			return -1;
+		}
+		value &= ~0x1F;
+		value |= 0x1F;
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_VGEN5CTL, 1, &value, 1)) {
+			printf("Set VGEN5CTL error!\n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned char value;
+	int is_400M;
+	u32 vddarm;
+	/* switch to ldo_bypass mode */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+		/* decrease VDDARM to 1.275V */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABVOL, 1, &value, 1)) {
+			printf("Read SW1AB error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(12750);
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABVOL, 1, &value, 1)) {
+			printf("Set SW1AB error!\n");
+			return;
+		}
+		/* decrease VDDSOC to 1.3V */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CVOL, 1, &value, 1)) {
+			printf("Read SW1C error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(13000);
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CVOL, 1, &value, 1)) {
+			printf("Set SW1C error!\n");
+			return;
+		}
+
+		is_400M = set_anatop_bypass(1);
+		if (is_400M)
+			vddarm = PFUZE100_SW1ABC_SETP(10750);
+		else
+			vddarm = PFUZE100_SW1ABC_SETP(11750);
+
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABVOL, 1, &value, 1)) {
+			printf("Read SW1AB error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= vddarm;
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABVOL, 1, &value, 1)) {
+			printf("Set SW1AB error!\n");
+			return;
+		}
+
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CVOL, 1, &value, 1)) {
+			printf("Read SW1C error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(11750);
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CVOL, 1, &value, 1)) {
+			printf("Set SW1C error!\n");
+			return;
+		}
+
+		finish_anatop_bypass();
+		printf("switch to ldo_bypass mode!\n");
+	}
+
+}
+#endif
+#endif
+
+#ifdef CONFIG_MXC_RDC
+static rdc_peri_cfg_t const shared_resources[] = {
+	(RDC_PER_GPIO1 | RDC_DOMAIN(0) | RDC_DOMAIN(1)),
+};
+#endif
+
+int board_early_init_f(void)
+{
+#ifdef CONFIG_MXC_RDC
+	imx_rdc_setup_peripherals(shared_resources, ARRAY_SIZE(shared_resources));
+#endif
+
+#ifdef CONFIG_SYS_AUXCORE_FASTUP
+	arch_auxiliary_core_up(0, CONFIG_SYS_AUXCORE_BOOTDATA);
+#endif
+
+	/* Enable PERI_3V3, which is used by SD2, ENET, LVDS, BT */
+	imx_iomux_v3_setup_multiple_pads(peri_3v3_pads, ARRAY_SIZE(peri_3v3_pads));
+	gpio_direction_output(IMX_GPIO_NR(4, 26) , 1);
+
+	/* Empty UART RX FIFO 5ms after PERI_PWR_ENABLE goes high */
+	udelay(5000);
+	while (tstc()) {
+		(void)getc();
+	}
+
+	setup_iomux_uart();
+
+// Configuration parameters are stored in I2C mapped eeprom and
+// must be initialized here since the configuration is accessed
+// early in the boot sequence
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
+#endif
+
+	ea_eeprom_init();
+
+	return 0;
+}
+
+
+int board_init(void)
+{
+
+	/* Address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+	/*
+	 * Because kernel set WDOG_B mux before pad with the commone pinctrl
+	 * framwork now and wdog reset will be triggered once set WDOG_B mux
+	 * with default pad setting, we set pad setting here to workaround this.
+	 * Since imx_iomux_v3_setup_pad also set mux before pad setting, we set
+	 * as GPIO mux firstly here to workaround it.
+	 */
+	imx_iomux_v3_setup_pad(wdog_b_pad);
+
+#ifdef	CONFIG_FEC_MXC
+	setup_fec(CONFIG_FEC_ENET_DEV);
+#endif
+
+#ifdef CONFIG_FSL_QSPI
+	board_qspi_init();
+#endif
+
+#ifdef CONFIG_CMD_EADISP
+	eadisp_setup_display(displays, ARRAY_SIZE(displays));
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd3", MAKE_CFGVAL(0x42, 0x30, 0x00, 0x00)},
+	{"sd4", MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{"qspi2", MAKE_CFGVAL(0x18, 0x00, 0x00, 0x00)},
+	{NULL,	 0},
+};
+#endif
+
+int board_late_init(void)
+{
+
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_PFUZE100_PMIC_I2C
+	int ret = 0;
+
+	ret = setup_pmic_voltages();
+	if (ret)
+		return -1;
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_init();
+#endif
+
+#ifdef CONFIG_CMD_EADISP
+	eatouch_init();
+#endif
+#ifdef CONFIG_SYS_I2C_MXC
+	disable_ar1021();
+#endif
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+	ea_eeprom_config_t config;
+
+	puts ("Board: Embedded Artists ");
+	if (ea_eeprom_get_config(&config) == 0) {
+
+		printf("%s\n", config.name);
+		printf("       %05d, %s, WO%d\n",
+			config.board_part_nr,
+			config.board_rev,
+			config.batch);
+
+	}
+	else {
+		puts(" [Unknown board due to invalid configuration data]\n");
+	}
+
+
+	return 0;
+}
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET 0x800
+#define UCTRL_PWR_POL (1 << 9)
+
+iomux_v3_cfg_t const usb_otg1_pads[] = {
+	MX6_PAD_QSPI1A_DATA2__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_GPIO1_IO10__ANATOP_OTG1_ID | MUX_PAD_CTRL(NO_PAD_CTRL)
+};
+
+iomux_v3_cfg_t const usb_otg2_pads[] = {
+	MX6_PAD_GPIO1_IO12__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+int board_usb_phy_mode(int port)
+{
+	if (port == 1)
+		return USB_INIT_HOST;
+	else
+		return usb_phy_mode(port);
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	switch (port) {
+	case 0:
+		imx_iomux_v3_setup_multiple_pads(usb_otg1_pads,
+			ARRAY_SIZE(usb_otg1_pads));
+		break;
+	case 1:
+		imx_iomux_v3_setup_multiple_pads(usb_otg2_pads,
+			ARRAY_SIZE(usb_otg2_pads));
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
+
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+		port * 4);
+
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_FASTBOOT
+
+void board_fastboot_setup(void)
+{
+	switch (get_boot_device()) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc0");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc0");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc1");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc1");
+		break;
+	case SD4_BOOT:
+	case MMC4_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc2");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc2");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("unsupported boot devices\n");
+		break;
+	}
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+
+#define GPIO_VOL_DN_KEY IMX_GPIO_NR(1, 19)
+iomux_v3_cfg_t const recovery_key_pads[] = {
+	(MX6_PAD_CSI_DATA05__GPIO1_IO_19 | MUX_PAD_CTRL(BUTTON_PAD_CTRL)),
+};
+
+int check_recovery_cmd_file(void)
+{
+	int button_pressed = 0;
+	int recovery_mode = 0;
+
+	recovery_mode = recovery_check_and_clean_flag();
+
+	/* Check Recovery Combo Button press or not. */
+	imx_iomux_v3_setup_multiple_pads(recovery_key_pads,
+		ARRAY_SIZE(recovery_key_pads));
+
+	gpio_direction_input(GPIO_VOL_DN_KEY);
+
+	if (gpio_get_value(GPIO_VOL_DN_KEY) == 0) { /* VOL_DN key is low assert */
+		button_pressed = 1;
+		printf("Recovery key pressed\n");
+	}
+
+	return recovery_mode || button_pressed;
+}
+
+void board_recovery_setup(void)
+{
+	int bootdev = get_boot_device();
+
+	switch (bootdev) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc0 recovery");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc1 recovery");
+		break;
+	case SD4_BOOT:
+	case MMC4_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc2 recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("Unsupported bootup device for recovery: dev: %d\n",
+			bootdev);
+		return;
+	}
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FLS_FASTBOOT*/
+
+#ifdef CONFIG_IMX_UDC
+iomux_v3_cfg_t const otg_udc_pads[] = {
+	(MX6_PAD_GPIO1_IO10__ANATOP_OTG1_ID | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+void udc_pins_setting(void)
+{
+	imx_iomux_v3_setup_multiple_pads(otg_udc_pads,
+		ARRAY_SIZE(otg_udc_pads));
+}
+
+#endif /*CONFIG_IMX_UDC*/
diff --git a/board/embeddedartists/mx6ulea-com/Kconfig b/board/embeddedartists/mx6ulea-com/Kconfig
new file mode 100644
index 0000000..08119da
--- /dev/null
+++ b/board/embeddedartists/mx6ulea-com/Kconfig
@@ -0,0 +1,15 @@
+if TARGET_MX6ULEA_COM
+
+config SYS_BOARD
+	default "mx6ulea-com"
+
+config SYS_VENDOR
+	default "embeddedartists"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "mx6ulea-com"
+
+endif
diff --git a/board/embeddedartists/mx6ulea-com/MAINTAINERS b/board/embeddedartists/mx6ulea-com/MAINTAINERS
new file mode 100644
index 0000000..c8f1868
--- /dev/null
+++ b/board/embeddedartists/mx6ulea-com/MAINTAINERS
@@ -0,0 +1,6 @@
+MX6ULEA-COM BOARD
+M:	Andreas Rebert <imx@embeddedartists.com>
+S:	Maintained
+F:	board/embeddedartists/mx6ulea-com/
+F:	include/configs/mx6ulea-com.h
+F:	configs/mx6ulea-com_defconfig
diff --git a/board/embeddedartists/mx6ulea-com/Makefile b/board/embeddedartists/mx6ulea-com/Makefile
new file mode 100644
index 0000000..f8723ec
--- /dev/null
+++ b/board/embeddedartists/mx6ulea-com/Makefile
@@ -0,0 +1,10 @@
+# (C) Copyright 2015 Embedded Artists AB.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx6ulea-com.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff --git a/board/embeddedartists/mx6ulea-com/imximage.cfg b/board/embeddedartists/mx6ulea-com/imximage.cfg
new file mode 100644
index 0000000..41d95fb
--- /dev/null
+++ b/board/embeddedartists/mx6ulea-com/imximage.cfg
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6ul_14x14_evk/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+/* Enable all clocks */
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+DATA 4 0x020c4084 0xffffffff
+
+DATA 4 0x020E04B4 0x000C0000
+DATA 4 0x020E04AC 0x00000000
+DATA 4 0x020E027C 0x00000008
+DATA 4 0x020E0250 0x00000030
+DATA 4 0x020E024C 0x00000030
+DATA 4 0x020E0490 0x00000030
+DATA 4 0x020E0288 0x00000030
+DATA 4 0x020E0270 0x00000000
+DATA 4 0x020E0260 0x00000030
+DATA 4 0x020E0264 0x00000030
+DATA 4 0x020E04A0 0x00000030
+DATA 4 0x020E0494 0x00020000
+DATA 4 0x020E0280 0x00000038
+DATA 4 0x020E0284 0x00000030
+DATA 4 0x020E04B0 0x00020000
+DATA 4 0x020E0498 0x00000030
+DATA 4 0x020E04A4 0x00000030
+DATA 4 0x020E0244 0x00000030
+DATA 4 0x020E0248 0x00000030
+DATA 4 0x021B001C 0x00008000
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B080C 0x00090000
+DATA 4 0x021B083C 0x41540154
+DATA 4 0x021B0848 0x40404442
+DATA 4 0x021B0850 0x40405450
+DATA 4 0x021B081C 0x33333333
+DATA 4 0x021B0820 0x33333333
+DATA 4 0x021B082C 0xf3333333
+DATA 4 0x021B0830 0xf3333333
+DATA 4 0x021B08C0 0x00922012
+DATA 4 0x021B0858 0x00000F00
+DATA 4 0x021B08b8 0x00000800
+DATA 4 0x021B0004 0x0002002D
+DATA 4 0x021B0008 0x1B333000
+DATA 4 0x021B000C 0x676B54F3
+DATA 4 0x021B0010 0xB68E0A83
+DATA 4 0x021B0014 0x01FF00DB
+DATA 4 0x021B0018 0x00211740
+DATA 4 0x021B001C 0x00008000
+DATA 4 0x021B002C 0x000026D2
+DATA 4 0x021B0030 0x006B1023
+DATA 4 0x021B0040 0x0000004F
+DATA 4 0x021B0000 0x84180000
+DATA 4 0x021B001C 0x02008032
+DATA 4 0x021B001C 0x00008033
+DATA 4 0x021B001C 0x00048031
+DATA 4 0x021B001C 0x15208030
+DATA 4 0x021B001C 0x04008040
+DATA 4 0x021B0020 0x00000800
+DATA 4 0x021B0818 0x00000227
+DATA 4 0x021B0004 0x0002552D
+DATA 4 0x021B0404 0x00011006
+DATA 4 0x021B001C 0x00000000
+#endif
diff --git a/board/embeddedartists/mx6ulea-com/mx6ulea-com.c b/board/embeddedartists/mx6ulea-com/mx6ulea-com.c
new file mode 100644
index 0000000..87f599a
--- /dev/null
+++ b/board/embeddedartists/mx6ulea-com/mx6ulea-com.c
@@ -0,0 +1,990 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/mxc_i2c.h>
+#if defined(CONFIG_CMD_EADISP)
+#include <asm/imx-common/eadisp.h>
+#include <asm/imx-common/eatouch.h>
+#endif
+#include <asm/io.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <i2c.h>
+#include <linux/sizes.h>
+#include <linux/fb.h>
+#include <miiphy.h>
+#include <mmc.h>
+#include <mxsfb.h>
+#include <netdev.h>
+#include <usb.h>
+#include <usb/ehci-fsl.h>
+#include <power/pmic.h>
+#include <power/pfuze300_pmic.h>
+
+#ifdef CONFIG_FSL_FASTBOOT
+#include <fsl_fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FSL_FASTBOOT*/
+
+#include "../common/mx6ea_eeprom.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_DAT3_CD_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_DOWN  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+	PAD_CTL_SPEED_HIGH   |                                   \
+	PAD_CTL_DSE_48ohm   | PAD_CTL_SRE_FAST)
+
+#define MDIO_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+	PAD_CTL_DSE_48ohm   | PAD_CTL_SRE_FAST | PAD_CTL_ODE)
+
+
+#define ENET_CLK_PAD_CTRL  (PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_RX_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |          \
+	PAD_CTL_SPEED_HIGH   | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE)
+
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+	PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define GPMI_PAD_CTRL0 (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)
+#define GPMI_PAD_CTRL1 (PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_MED | \
+			PAD_CTL_SRE_FAST)
+#define GPMI_PAD_CTRL2 (GPMI_PAD_CTRL0 | GPMI_PAD_CTRL1)
+
+#define WEIM_NOR_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE | \
+		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | \
+		PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define PERI_PWR_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_DSE_40ohm)
+
+iomux_v3_cfg_t const peri_pwr_pads[] = {
+	(MX6_PAD_SNVS_TAMPER2__GPIO5_IO02 | MUX_PAD_CTRL(PERI_PWR_PAD_CTRL)),
+};
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC and EEPROM */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode =  MX6_PAD_UART4_TX_DATA__I2C1_SCL | PC,
+		.gpio_mode = MX6_PAD_UART4_TX_DATA__GPIO1_IO28 | PC,
+		.gp = IMX_GPIO_NR(1, 28),
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_UART4_RX_DATA__I2C1_SDA | PC,
+		.gpio_mode = MX6_PAD_UART4_RX_DATA__GPIO1_IO29 | PC,
+		.gp = IMX_GPIO_NR(1, 29),
+	},
+};
+#endif
+
+int dram_init(void)
+{
+	ea_eeprom_config_t config;
+
+	// default size from configuration file
+	gd->ram_size = PHYS_SDRAM_SIZE;
+
+	// getting actual size from eeprom configuration
+
+	if (ea_eeprom_get_config(&config) == 0) {
+		gd->ram_size = (config.ddr_size << 20);
+	}
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX6_PAD_UART1_TX_DATA__UART1_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_UART1_RX_DATA__UART1_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc1_pads[] = {
+	MX6_PAD_SD1_CLK__USDHC1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_CMD__USDHC1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA0__USDHC1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA1__USDHC1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA2__USDHC1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA3__USDHC1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* CD */
+	MX6_PAD_GPIO1_IO03__GPIO1_IO03 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* PWR EN */
+	MX6_PAD_GPIO1_IO09__GPIO1_IO09 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc2_emmc_pads[] = {
+	MX6_PAD_NAND_RE_B__USDHC2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_WE_B__USDHC2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA00__USDHC2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA01__USDHC2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA02__USDHC2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA03__USDHC2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA04__USDHC2_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA05__USDHC2_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA06__USDHC2_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA07__USDHC2_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/*
+	 * RST_B
+	 */
+	MX6_PAD_NAND_ALE__GPIO4_IO10 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+
+
+#ifdef CONFIG_FEC_MXC
+/*
+ * pin conflicts for fec1 and fec2, GPIO1_IO06 and GPIO1_IO07 can only
+ * be used for ENET1 or ENET2, cannot be used for both.
+ */
+
+static iomux_v3_cfg_t const fec_common_pads[] = {
+	/* enet pwr en */
+	MX6_PAD_SNVS_TAMPER3__GPIO5_IO03 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const fec1_pads[] = {
+	MX6_PAD_GPIO1_IO06__ENET1_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),
+	MX6_PAD_GPIO1_IO07__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_DATA0__ENET1_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_DATA1__ENET1_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_EN__ENET1_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_CLK__ENET1_REF_CLK1 | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
+	MX6_PAD_ENET1_RX_DATA0__ENET1_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_DATA1__ENET1_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_ER__ENET1_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_EN__ENET1_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const fec2_pads[] = {
+	MX6_PAD_GPIO1_IO06__ENET2_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),
+	MX6_PAD_GPIO1_IO07__ENET2_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	MX6_PAD_ENET2_TX_DATA0__ENET2_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_TX_DATA1__ENET2_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_TX_CLK__ENET2_REF_CLK2 | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
+	MX6_PAD_ENET2_TX_EN__ENET2_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	MX6_PAD_ENET2_RX_DATA0__ENET2_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_DATA1__ENET2_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_EN__ENET2_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_ER__ENET2_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
+static void setup_iomux_fec(int fec_id)
+{
+	imx_iomux_v3_setup_multiple_pads(fec_common_pads, ARRAY_SIZE(fec_common_pads));
+
+	if (fec_id == 0)
+		imx_iomux_v3_setup_multiple_pads(fec1_pads, ARRAY_SIZE(fec1_pads));
+	else
+		imx_iomux_v3_setup_multiple_pads(fec2_pads, ARRAY_SIZE(fec2_pads));
+}
+#endif
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_FSL_QSPI
+
+#define QSPI_PAD_CTRL1	\
+	(PAD_CTL_SRE_FAST | PAD_CTL_SPEED_MED | \
+	 PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_47K_UP | PAD_CTL_DSE_120ohm)
+
+static iomux_v3_cfg_t const quadspi_pads[] = {
+	MX6_PAD_NAND_WP_B__QSPI_A_SCLK	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_READY_B__QSPI_A_DATA00	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE0_B__QSPI_A_DATA01	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE1_B__QSPI_A_DATA02	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CLE__QSPI_A_DATA03	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DQS__QSPI_A_SS0_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+};
+
+int board_qspi_init(void)
+{
+	/* Set the iomux */
+	imx_iomux_v3_setup_multiple_pads(quadspi_pads, ARRAY_SIZE(quadspi_pads));
+
+	/* Set the clock */
+	enable_qspi_clk(0);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+static struct fsl_esdhc_cfg usdhc_cfg[2] = {
+	{USDHC1_BASE_ADDR, 0, 4},
+	{USDHC2_BASE_ADDR, 0, 8},
+};
+
+#define USDHC1_CD_GPIO	IMX_GPIO_NR(1, 3)
+#define USDHC1_PWR_GPIO	IMX_GPIO_NR(1, 9)
+#define USDHC2_PWR_GPIO	IMX_GPIO_NR(4, 10)
+
+int mmc_get_env_devno(void)
+{
+	u32 soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	int dev_no;
+	u32 bootsel;
+
+	bootsel = (soc_sbmr & 0x000000FF) >> 6 ;
+
+	/* If not boot from sd/mmc, use default value */
+	if (bootsel != 1)
+		return CONFIG_SYS_MMC_ENV_DEV;
+
+	/* BOOT_CFG2[3] and BOOT_CFG2[4] */
+	dev_no = (soc_sbmr & 0x00001800) >> 11;
+
+	return dev_no;
+}
+
+int mmc_map_to_kernel_blk(int dev_no)
+{
+	return dev_no;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC1_BASE_ADDR:
+		ret = !gpio_get_value(USDHC1_CD_GPIO);
+		break;
+	case USDHC2_BASE_ADDR:
+		ret = 1;
+		break;
+	}
+
+	return ret;
+
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int i, ret;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC1
+	 * mmc1                    USDHC2
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+#if defined(CONFIG_SPL_BUILD)
+
+		// The SPL framework expects there to be only one MMC device
+		// and we always loads u-boot from eMMC which is mapped to mmc1
+		if (i != 1) continue;
+#endif
+
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
+			gpio_direction_input(USDHC1_CD_GPIO);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+
+			gpio_direction_output(USDHC1_PWR_GPIO, 0);
+			udelay(500);
+			gpio_direction_output(USDHC1_PWR_GPIO, 1);
+			break;
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_emmc_pads, ARRAY_SIZE(usdhc2_emmc_pads));
+
+			gpio_direction_output(USDHC2_PWR_GPIO, 0);
+			udelay(500);
+			gpio_direction_output(USDHC2_PWR_GPIO, 1);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) than supported by the board\n", i + 1);
+			return -EINVAL;
+			}
+
+			ret = fsl_esdhc_initialize(bis, &usdhc_cfg[i]);
+			if (ret) {
+				printf("Warning: failed to initialize mmc dev %d\n", i);
+				return ret;
+			}
+	}
+
+	return 0;
+}
+
+int check_mmc_autodetect(void)
+{
+	char *autodetect_str = getenv("mmcautodetect");
+
+	if ((autodetect_str != NULL) &&
+		(strcmp(autodetect_str, "yes") == 0)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+void board_late_mmc_init(void)
+{
+	char cmd[32];
+	char mmcblk[32];
+	u32 dev_no = mmc_get_env_devno();
+
+	if (!check_mmc_autodetect())
+		return;
+
+	setenv_ulong("mmcdev", dev_no);
+
+	/* Set mmcblk env */
+	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
+		mmc_map_to_kernel_blk(dev_no));
+	setenv("mmcroot", mmcblk);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
+}
+#endif
+
+#ifdef CONFIG_VIDEO_MXS
+static iomux_v3_cfg_t const lcd_pads[] = {
+	MX6_PAD_LCD_CLK__LCDIF_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_ENABLE__LCDIF_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_HSYNC__LCDIF_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_VSYNC__LCDIF_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA00__LCDIF_DATA00 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA01__LCDIF_DATA01 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA02__LCDIF_DATA02 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA03__LCDIF_DATA03 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA04__LCDIF_DATA04 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA05__LCDIF_DATA05 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA06__LCDIF_DATA06 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA07__LCDIF_DATA07 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA08__LCDIF_DATA08 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA09__LCDIF_DATA09 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA10__LCDIF_DATA10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA11__LCDIF_DATA11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA12__LCDIF_DATA12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA13__LCDIF_DATA13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA14__LCDIF_DATA14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA15__LCDIF_DATA15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA16__LCDIF_DATA16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA17__LCDIF_DATA17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA18__LCDIF_DATA18 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA19__LCDIF_DATA19 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA20__LCDIF_DATA20 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA21__LCDIF_DATA21 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA22__LCDIF_DATA22 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA23__LCDIF_DATA23 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+
+	/*
+	 * Use GPIO for Brightness adjustment, duty cycle = period.
+	 */
+	MX6_PAD_GPIO1_IO08__GPIO1_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* Display power enable */
+	MX6_PAD_GPIO1_IO02__GPIO1_IO02 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* Backlight enable */
+	MX6_PAD_GPIO1_IO01__GPIO1_IO01 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+#ifdef CONFIG_CMD_EADISP
+void board_enable_rgb(const struct display_info_t *di, int enable)
+{
+	if (enable) {
+		enable_lcdif_clock(LCDIF1_BASE_ADDR);
+
+		imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+
+		mdelay(100); /* let panel sync up before enabling backlight */
+
+		/* Power up the LCD */
+		gpio_direction_output(IMX_GPIO_NR(1, 2) , 1);
+
+		/* Set Brightness to high */
+		gpio_direction_output(IMX_GPIO_NR(1, 8) , 1);
+
+		/* Backlight power enable */
+		gpio_direction_output(IMX_GPIO_NR(1, 1) , 1);
+	}
+}
+
+static const struct display_info_t displays[] = {
+	/* RGB */
+	EADISP_INNOLUX_AT070TN(RGB, 0, 0),
+	EADISP_NHD_43480272EF(RGB, 0, 0),
+	EADISP_NHD_50800480TF(RGB, 0, 0),
+	EADISP_NHD_70800480EF(RGB, 0, 0),
+	EADISP_UMSH_8864(RGB, 0, 0),
+	EADISP_UMSH_8596_30T(RGB, 0, 0),
+	EADISP_UMSH_8596_33T(RGB, 0, 0),
+	EADISP_ROGIN_RX050A(RGB, 0, 0),
+};
+
+#else /* CONFIG_CMD_EADISP */
+
+struct lcd_panel_info_t {
+	unsigned int lcdif_base_addr;
+	int depth;
+	void (*enable)(struct lcd_panel_info_t const *dev);
+	struct fb_videomode mode;
+};
+
+void do_enable_parallel_lcd(struct lcd_panel_info_t const *dev)
+{
+	enable_lcdif_clock(dev->lcdif_base_addr);
+
+	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+
+	/* Power up the LCD */
+	gpio_direction_output(IMX_GPIO_NR(1, 2) , 1);
+
+	/* Set Brightness to high */
+	gpio_direction_output(IMX_GPIO_NR(1, 8) , 1);
+
+	/* Backlight power enable */
+	gpio_direction_output(IMX_GPIO_NR(1, 1) , 1);
+}
+
+static struct lcd_panel_info_t const displays[] = {{
+	.lcdif_base_addr = LCDIF1_BASE_ADDR,
+	.depth = 24,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+		.name			= "Innolux-AT070TN",
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 29850,
+		.left_margin    = 89,
+		.right_margin   = 164,
+		.upper_margin   = 75,
+		.lower_margin   = 75,
+		.hsync_len      = 10,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+
+int board_video_skip(void)
+{
+	int i;
+	int ret;
+	char const *panel = getenv("panel");
+	if (!panel) {
+		panel = displays[0].mode.name;
+		printf("No panel detected: default to %s\n", panel);
+		i = 0;
+	} else {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			if (!strcmp(panel, displays[i].mode.name))
+				break;
+		}
+	}
+	if (i < ARRAY_SIZE(displays)) {
+		ret = mxs_lcd_panel_setup(displays[i].mode, displays[i].depth,
+				    displays[i].lcdif_base_addr);
+		if (!ret) {
+			if (displays[i].enable)
+				displays[i].enable(displays+i);
+			printf("Display: %s (%ux%u)\n",
+			       displays[i].mode.name,
+			       displays[i].mode.xres,
+			       displays[i].mode.yres);
+		} else
+			printf("LCD %s cannot be configured: %d\n",
+			       displays[i].mode.name, ret);
+	} else {
+		printf("unsupported panel %s\n", panel);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#endif /* CONFIG_CMD_EADISP */
+#endif
+
+#ifdef CONFIG_FEC_MXC
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+	ea_eeprom_config_t config;
+
+	setup_iomux_fec(CONFIG_FEC_ENET_DEV);
+
+	/* enet pwr en */
+	gpio_direction_output(IMX_GPIO_NR(5, 3) , 0);
+
+	ret = fecmxc_initialize_multi(bis, CONFIG_FEC_ENET_DEV,
+		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+	if (ret)
+		printf("FEC%d MXC: %s:failed\n", CONFIG_FEC_ENET_DEV, __func__);
+
+	/* stored MAC addresses to env variables */
+	if (ea_eeprom_get_config(&config) == 0) {
+
+		if (is_valid_ether_addr(config.mac1) && !getenv("ethaddr")) {
+			eth_setenv_enetaddr("ethaddr", config.mac1);
+		}
+
+		if (is_valid_ether_addr(config.mac2) && !getenv("eth1addr")) {
+			eth_setenv_enetaddr("eth1addr", config.mac2);
+		}
+
+		if (is_valid_ether_addr(config.mac3) && !getenv("eth2addr")) {
+			eth_setenv_enetaddr("eth2addr", config.mac3);
+		}
+
+		if (is_valid_ether_addr(config.mac4) && !getenv("eth3addr")) {
+			eth_setenv_enetaddr("eth3addr", config.mac4);
+		}
+
+	}
+
+	return 0;
+}
+
+static int setup_fec(int fec_id)
+{
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *) IOMUXC_GPR_BASE_ADDR;
+	int ret;
+
+	if (0 == fec_id) {
+		/* Use 50M anatop loopback REF_CLK1 for ENET1, clear gpr1[13], set gpr1[17]*/
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC1_MASK,
+				IOMUX_GPR1_FEC1_CLOCK_MUX1_SEL_MASK);
+	} else {
+		/* Use 50M anatop loopback REF_CLK2 for ENET2, clear gpr1[14], set gpr1[18]*/
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC2_MASK,
+				IOMUX_GPR1_FEC2_CLOCK_MUX1_SEL_MASK);
+	}
+
+	ret = enable_fec_anatop_clock(fec_id, ENET_50MHZ);
+	if (ret)
+		return ret;
+
+	enable_enet_clk(1);
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1f, 0x8190);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+
+void board_get_hwaddr(int dev_id, unsigned char *mac)
+{
+	ea_eeprom_config_t config;
+
+	if (ea_eeprom_get_config(&config) == 0) {
+		if (dev_id == 0) {
+			memcpy(mac, config.mac1, 6);
+		}
+		else {
+			memcpy(mac, config.mac2, 6);
+		}
+	}
+
+}
+
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+
+static iomux_v3_cfg_t const usb_otg_pads[] = {
+	MX6_PAD_GPIO1_IO00__ANATOP_OTG1_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
+};
+
+/* At default the 3v3 enables the MIC2026 for VBUS power */
+static void setup_usb(void)
+{
+	imx_iomux_v3_setup_multiple_pads(usb_otg_pads,
+					 ARRAY_SIZE(usb_otg_pads));
+}
+
+int board_usb_phy_mode(int port)
+{
+	if (port == 1)
+		return USB_INIT_HOST;
+	else
+		return usb_phy_mode(port);
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port > 1)
+		return -EINVAL;
+
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+				 port * 4);
+
+	/* Set Power polarity */
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_POWER
+#define I2C_PMIC	0
+//static struct pmic *pfuze;
+int power_init_board(void)
+{
+	int ret;
+	u32 rev_id, value;
+	struct pmic *pfuze;
+
+	ret = power_pfuze300_init(I2C_PMIC);
+	if (ret)
+		return ret;
+
+	pfuze = pmic_get("PFUZE300");
+	if (!pfuze)
+		return -ENODEV;
+
+	ret = pmic_probe(pfuze);
+	if (ret)
+		return ret;
+
+//	ret = pfuze_mode_init(pfuze, APS_PFM);
+//	if (ret < 0)
+//		return ret;
+
+	pmic_reg_read(pfuze, PFUZE300_DEVICEID, &value);
+	pmic_reg_read(pfuze, PFUZE300_REVID, &rev_id);
+	printf("PMIC: DEV_ID=0x%x REV_ID=0x%x\n", value, rev_id);
+
+	/*
+	 * Our PFUZE0200 is PMPF0200X0AEP, the Pre-programmed OTP
+	 * Configuration is F0.
+	 * Default VOLT:
+	 * VSNVS_VOLT	|	3.0V
+	 * SW1AB	|	1.375V
+	 * SW2		|	3.3V
+	 * SW3A		|	1.5V
+	 * SW3B		|	1.5V
+	 * VGEN1	|	1.5V
+	 * VGEN2	|	1.5V
+	 * VGEN3	|	2.5V
+	 * VGEN4	|	1.8V
+	 * VGEN5	|	2.8V
+	 * VGEN6	|	3.3V
+	 *
+	 * According to schematic, we need SW3A 1.35V, SW3B 3.3V,
+	 * VGEN1 1.2V, VGEN2 1.5V, VGEN3 2.8V, VGEN4 1.8V,
+	 * VGEN5 3.3V, VGEN6 3.0V.
+	 *
+	 * Here we just use the default VOLT, but not configure
+	 * them, when needed, configure them to our requested voltage.
+	 */
+#if 0
+	/* set SW1AB standby volatage 0.975V */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABSTBY, &value);
+	value &= ~0x3f;
+	value |= PFUZE100_SW1ABC_SETP(9750);
+	pmic_reg_write(pfuze, PFUZE100_SW1ABSTBY, value);
+
+	/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABCONF, &value);
+	value &= ~0xc0;
+	value |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1ABCONF, value);
+
+	/* Enable power of VGEN5 3V3 */
+	pmic_reg_read(pfuze, PFUZE100_VGEN5VOL, &value);
+	value &= ~0x1F;
+	value |= 0x1F;
+	pmic_reg_write(pfuze, PFUZE100_VGEN5VOL, value);
+#endif
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_SYS_I2C_MXC
+static int disable_ar1021(void)
+{
+        unsigned char cmd[] = { 0x55, 0x01, 0x13 };
+
+        i2c_set_bus_num(0);
+        if (!i2c_probe(0x4d)) {
+
+                if (i2c_write(0x4d, 0x00, 1, cmd, 3)) {
+                        printf("Failed to disable AR1021!\n");
+                        return -1;
+                }
+        }
+        return 0;
+}
+#endif
+
+int board_early_init_f(void)
+{
+	/* configure and enable pwr on carrier board*/
+	imx_iomux_v3_setup_multiple_pads(peri_pwr_pads,
+			ARRAY_SIZE(peri_pwr_pads));
+	gpio_direction_output(IMX_GPIO_NR(5, 2), 1);
+
+        /* Empty UART RX FIFO 5ms after PERI_PWR_ENABLE goes high */
+        udelay(5000);
+        while (tstc()) {
+                (void)getc();
+        }
+
+	setup_iomux_uart();
+
+// Configuration parameters are stored in I2C mapped eeprom and
+// must be initialized here since the configuration is accessed
+// early in the boot sequence
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+#endif
+
+	ea_eeprom_init();
+
+	return 0;
+}
+
+int board_init(void)
+{
+	/* Address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+
+#ifdef	CONFIG_FEC_MXC
+	setup_fec(CONFIG_FEC_ENET_DEV);
+#endif
+
+
+#ifdef CONFIG_CMD_EADISP
+	eadisp_setup_display(displays, ARRAY_SIZE(displays));
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX6
+	setup_usb();
+#endif
+
+#ifdef CONFIG_FSL_QSPI
+	board_qspi_init();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd1", MAKE_CFGVAL(0x42, 0x20, 0x00, 0x00)},
+	{"sd2", MAKE_CFGVAL(0x40, 0x28, 0x00, 0x00)},
+	{"qspi1", MAKE_CFGVAL(0x10, 0x00, 0x00, 0x00)},
+	{NULL,	 0},
+};
+#endif
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_init();
+#endif
+
+#ifdef CONFIG_CMD_EADISP
+        eatouch_init();
+#endif
+#ifdef CONFIG_SYS_I2C_MXC
+	disable_ar1021();
+#endif
+
+	set_wdog_reset((struct wdog_regs *)WDOG1_BASE_ADDR);
+
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+	ea_eeprom_config_t config;
+
+	puts ("Board: Embedded Artists ");
+	if (ea_eeprom_get_config(&config) == 0) {
+
+		printf("%s\n", config.name);
+		printf("       %05d, %s, WO%d\n",
+			config.board_part_nr,
+			config.board_rev,
+			config.batch);
+
+	}
+	else {
+		puts(" [Unknown board due to invalid configuration data]\n");
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_FSL_FASTBOOT
+
+void board_fastboot_setup(void)
+{
+	switch (get_boot_device()) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc0");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc0");
+		break;
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc1");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc1");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	case NAND_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "nand");
+		if (!getenv("fbparts"))
+			setenv("fbparts", ANDROID_FASTBOOT_NAND_PARTS);
+		if (!getenv("bootcmd"))
+			setenv("bootcmd",
+				"nand read ${loadaddr} ${boot_nand_offset} "
+				"${boot_nand_size};boota ${loadaddr}");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
+
+	default:
+		printf("unsupported boot devices\n");
+		break;
+	}
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+int check_recovery_cmd_file(void)
+{
+	int recovery_mode = 0;
+
+	recovery_mode = recovery_check_and_clean_flag();
+
+	return recovery_mode;
+}
+
+void board_recovery_setup(void)
+{
+	int bootdev = get_boot_device();
+
+	switch (bootdev) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc0 recovery");
+		break;
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc1 recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	case NAND_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"nand read ${loadaddr} ${recovery_nand_offset} "
+				"${recovery_nand_size};boota ${loadaddr}");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
+
+	default:
+		printf("Unsupported bootup device for recovery: dev: %d\n",
+			bootdev);
+		return;
+	}
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FASTBOOT*/
+
+#ifdef CONFIG_IMX_UDC
+static iomux_v3_cfg_t const otg_udc_pads[] = {
+	MX6_PAD_GPIO1_IO00__ANATOP_OTG1_ID | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+void udc_pins_setting(void)
+{
+	imx_iomux_v3_setup_multiple_pads(otg_udc_pads,
+		ARRAY_SIZE(otg_udc_pads));
+}
+
+#endif /*CONFIG_IMX_UDC*/
diff --git a/board/embeddedartists/mx6ulea-com/plugin.S b/board/embeddedartists/mx6ulea-com/plugin.S
new file mode 100644
index 0000000..15f0c29
--- /dev/null
+++ b/board/embeddedartists/mx6ulea-com/plugin.S
@@ -0,0 +1,139 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6ul_ddr3_arm2_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000C0000
+	str r1, [r0, #0x4B4]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4AC]
+	ldr r1, =0x00000008
+	str r1, [r0, #0x27C]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x250]
+	str r1, [r0, #0x24C]
+	str r1, [r0, #0x490]
+	str r1, [r0, #0x288]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x270]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x260]
+	str r1, [r0, #0x264]
+	str r1, [r0, #0x4A0]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x494]
+
+	ldr r1, =0x00000038
+	str r1, [r0, #0x280]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x284]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x4B0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x498]
+	str r1, [r0, #0x4A4]
+	str r1, [r0, #0x244]
+	str r1, [r0, #0x248]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r1, =0x00008000
+	str r1, [r0, #0x1C]
+	ldr r1, =0xA1390003
+	str r1, [r0, #0x800]
+	ldr r1, =0x00070007
+	str r1, [r0, #0x80C]
+	ldr r1, =0x41490145
+	str r1, [r0, #0x83C]
+	ldr r1, =0x40404546
+	str r1, [r0, #0x848]
+	ldr r1, =0x4040524D
+	str r1, [r0, #0x850]
+	ldr r1, =0x33333333
+	str r1, [r0, #0x81C]
+	str r1, [r0, #0x820]
+	ldr r1, =0xF3333333
+	str r1, [r0, #0x82C]
+	str r1, [r0, #0x830]
+	ldr r1, =0x00922012
+	str r1, [r0, #0x8C0]
+	ldr r1, =0x00000F00
+	str r1, [r0, #0x858]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x8B8]
+	ldr r1, =0x0002002D
+	str r1, [r0, #0x004]
+	ldr r1, =0x1B333000
+	str r1, [r0, #0x008]
+	ldr r1, =0x676B54F3
+	str r1, [r0, #0x00C]
+	ldr r1, =0xB68E0A83
+	str r1, [r0, #0x010]
+	ldr r1, =0x01FF00DB
+	str r1, [r0, #0x014]
+	ldr r1, =0x00211740
+	str r1, [r0, #0x018]
+	ldr r1, =0x00008000
+	str r1, [r0, #0x01C]
+	ldr r1, =0x000026D2
+	str r1, [r0, #0x02C]
+	ldr r1, =0x006B1023
+	str r1, [r0, #0x030]
+	ldr r1, =0x0000004F
+	str r1, [r0, #0x040]
+	ldr r1, =0x84180000
+	str r1, [r0, #0x000]
+	ldr r1, =0x02008032
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00008033
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00048031
+	str r1, [r0, #0x01C]
+	ldr r1, =0x15208030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x04008040
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x020]
+	ldr r1, =0x00000227
+	str r1, [r0, #0x818]
+	ldr r1, =0x0002552D
+	str r1, [r0, #0x004]
+	ldr r1, =0x00011006
+	str r1, [r0, #0x404]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x01C]
+.endm
+
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xFFFFFFFF
+	str r1, [r0, #0x68]
+	str r1, [r0, #0x6C]
+	str r1, [r0, #0x70]
+	str r1, [r0, #0x74]
+	str r1, [r0, #0x78]
+	str r1, [r0, #0x7C]
+	str r1, [r0, #0x80]
+	str r1, [r0, #0x84]
+.endm
+
+.macro imx6_qos_setting
+.endm
+
+.macro imx6_ddr_setting
+	imx6ul_ddr3_arm2_setting
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff --git a/board/embeddedartists/mx7dea-com/Kconfig b/board/embeddedartists/mx7dea-com/Kconfig
new file mode 100644
index 0000000..b73261b
--- /dev/null
+++ b/board/embeddedartists/mx7dea-com/Kconfig
@@ -0,0 +1,15 @@
+if TARGET_MX7DEA_COM
+
+config SYS_BOARD
+	default "mx7dea-com"
+
+config SYS_VENDOR
+	default "embeddedartists"
+
+config SYS_SOC
+	default "mx7"
+
+config SYS_CONFIG_NAME
+	default "mx7dea-com"
+
+endif
diff --git a/board/embeddedartists/mx7dea-com/Makefile b/board/embeddedartists/mx7dea-com/Makefile
new file mode 100644
index 0000000..b5200f1
--- /dev/null
+++ b/board/embeddedartists/mx7dea-com/Makefile
@@ -0,0 +1,10 @@
+# (C) Copyright 2015 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx7dea-com.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff --git a/board/embeddedartists/mx7dea-com/imximage.cfg b/board/embeddedartists/mx7dea-com/imximage.cfg
new file mode 100644
index 0000000..d23b3bc
--- /dev/null
+++ b/board/embeddedartists/mx7dea-com/imximage.cfg
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx7dsabresd/plugin.bin 0x00910000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x30340004 0x4F400005
+
+DATA 4 0x30391000 0x00000002
+DATA 4 0x307a0000 0x01040001
+DATA 4 0x307a01a0 0x80400003
+DATA 4 0x307a01a4 0x00100020
+DATA 4 0x307a01a8 0x80100004
+DATA 4 0x307a0064 0x0040005e
+DATA 4 0x307a0490 0x00000001
+DATA 4 0x307a00d0 0x00020001
+DATA 4 0x307a00d4 0x00010000
+DATA 4 0x307a00dc 0x09300004
+DATA 4 0x307a00e0 0x04080000
+DATA 4 0x307a00e4 0x00090004
+DATA 4 0x307a00f4 0x0000033f
+DATA 4 0x307a0100 0x0908120a
+DATA 4 0x307a0104 0x0002020e
+DATA 4 0x307a0108 0x03040407
+DATA 4 0x307a010c 0x00002006
+DATA 4 0x307a0110 0x04020204
+DATA 4 0x307a0114 0x03030202
+DATA 4 0x307a0120 0x03030803
+DATA 4 0x307a0180 0x00800020
+DATA 4 0x307a0190 0x02098204
+DATA 4 0x307a0194 0x00030303
+DATA 4 0x307a0200 0x00000016
+DATA 4 0x307a0204 0x00171717
+DATA 4 0x307a0214 0x04040404
+DATA 4 0x307a0218 0x00040404
+DATA 4 0x307a0240 0x06000601
+DATA 4 0x307a0244 0x00001323
+DATA 4 0x30391000 0x00000000
+DATA 4 0x30790000 0x17420f40
+DATA 4 0x30790004 0x10210100
+DATA 4 0x30790010 0x00060807
+DATA 4 0x307900b0 0x1010007e
+DATA 4 0x3079009c 0x00000d6e
+DATA 4 0x30790020 0x08080808
+DATA 4 0x30790030 0x08080808
+DATA 4 0x30790050 0x01000010
+DATA 4 0x30790050 0x00000010
+
+DATA 4 0x307900c0 0x0e407304
+DATA 4 0x307900c0 0x0e447304
+DATA 4 0x307900c0 0x0e447306
+
+CHECK_BITS_SET 4 0x307900c4 0x1
+
+DATA 4 0x307900c0 0x0e447304
+DATA 4 0x307900c0 0x0e407304
+
+DATA 4 0x30384130 0x00000000
+DATA 4 0x30340020 0x00000178
+DATA 4 0x30384130 0x00000002
+DATA 4 0x30790018 0x0000000f
+
+CHECK_BITS_SET 4 0x307a0004 0x1
+
+#endif
diff --git a/board/embeddedartists/mx7dea-com/mx7dea-com.c b/board/embeddedartists/mx7dea-com/mx7dea-com.c
new file mode 100644
index 0000000..6e31d8b
--- /dev/null
+++ b/board/embeddedartists/mx7dea-com/mx7dea-com.c
@@ -0,0 +1,1214 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx7-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#if defined(CONFIG_CMD_EADISP)
+#include <asm/imx-common/eadisp.h>
+#include <asm/imx-common/eatouch.h>
+#endif
+#include <asm/io.h>
+#include <linux/sizes.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <mmc.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <power/pmic.h>
+#ifdef CONFIG_SYS_I2C_MXC
+#include <i2c.h>
+#include <asm/imx-common/mxc_i2c.h>
+#endif
+#if defined(CONFIG_MXC_EPDC)
+#include <lcd.h>
+#include <mxc_epdc_fb.h>
+#endif
+#include <asm/arch/crm_regs.h>
+
+#ifdef CONFIG_VIDEO_MXS
+#include <linux/fb.h>
+#include <mxsfb.h>
+#endif
+
+#ifdef CONFIG_FSL_FASTBOOT
+#include <fsl_fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FSL_FASTBOOT*/
+
+#include "../common/mx6ea_eeprom.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_DSE_3P3V_49OHM | \
+	PAD_CTL_PUS_PU100KOHM | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_DSE_3P3V_32OHM | PAD_CTL_SRE_SLOW | \
+	PAD_CTL_HYS | PAD_CTL_PUE | PAD_CTL_PUS_PU47KOHM)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_PU100KOHM | PAD_CTL_DSE_3P3V_49OHM)
+#define ENET_PAD_CTRL_MII  (PAD_CTL_DSE_3P3V_32OHM)
+
+#define ENET_RX_PAD_CTRL  (PAD_CTL_PUS_PU100KOHM | PAD_CTL_DSE_3P3V_49OHM)
+
+#define I2C_PAD_CTRL    (PAD_CTL_DSE_3P3V_32OHM | PAD_CTL_SRE_SLOW | \
+	PAD_CTL_HYS | PAD_CTL_PUE | PAD_CTL_PUS_PU100KOHM)
+
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_PU100KOHM | \
+	PAD_CTL_DSE_3P3V_49OHM)
+
+#define QSPI_PAD_CTRL	\
+	(PAD_CTL_DSE_3P3V_49OHM | PAD_CTL_PUE | PAD_CTL_PUS_PU47KOHM)
+
+#define SPI_PAD_CTRL (PAD_CTL_DSE_3P3V_49OHM | PAD_CTL_SRE_SLOW | PAD_CTL_HYS)
+
+#define BUTTON_PAD_CTRL    (PAD_CTL_PUS_PU5KOHM | PAD_CTL_DSE_3P3V_98OHM)
+
+#define NAND_PAD_CTRL (PAD_CTL_DSE_3P3V_49OHM | PAD_CTL_SRE_SLOW | PAD_CTL_HYS)
+
+#define NAND_PAD_READY0_CTRL (PAD_CTL_DSE_3P3V_49OHM | PAD_CTL_PUS_PU5KOHM)
+
+#define EPDC_PAD_CTRL	0x0
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = MX7D_PAD_I2C1_SCL__I2C1_SCL | PC,
+		.gpio_mode = MX7D_PAD_I2C1_SCL__GPIO4_IO8 | PC,
+		.gp = IMX_GPIO_NR(4, 8),
+	},
+	.sda = {
+		.i2c_mode = MX7D_PAD_I2C1_SDA__I2C1_SDA | PC,
+		.gpio_mode = MX7D_PAD_I2C1_SDA__GPIO4_IO9 | PC,
+		.gp = IMX_GPIO_NR(4, 9),
+	},
+};
+
+/* I2C3 */
+struct i2c_pads_info i2c_pad_info3 = {
+	.scl = {
+		.i2c_mode = MX7D_PAD_I2C3_SCL__I2C3_SCL | PC,
+		.gpio_mode = MX7D_PAD_I2C3_SCL__GPIO4_IO12 | PC,
+		.gp = IMX_GPIO_NR(4, 12),
+	},
+	.sda = {
+		.i2c_mode = MX7D_PAD_I2C3_SDA__I2C3_SDA | PC,
+		.gpio_mode = MX7D_PAD_I2C3_SDA__GPIO4_IO13 | PC,
+		.gp = IMX_GPIO_NR(4, 13),
+	},
+};
+#endif
+
+
+
+int dram_init(void)
+{
+	ea_eeprom_config_t config;
+
+	// default size from configuration file
+	gd->ram_size = PHYS_SDRAM_SIZE;
+
+        // getting actual size from eeprom configuration
+
+        if (ea_eeprom_get_config(&config) == 0) {
+                /* ddr_size is given in MB */
+                gd->ram_size = (config.ddr_size << 20);
+        }
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const wdog_pads[] = {
+	MX7D_PAD_GPIO1_IO00__WDOG1_WDOG_B | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX7D_PAD_UART1_TX_DATA__UART1_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX7D_PAD_UART1_RX_DATA__UART1_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc1_pads[] = {
+	MX7D_PAD_SD1_CLK__SD1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_CMD__SD1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_DATA0__SD1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_DATA1__SD1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_DATA2__SD1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_DATA3__SD1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	MX7D_PAD_SD1_CD_B__GPIO5_IO0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_RESET_B__GPIO5_IO2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc3_emmc_pads[] = {
+	MX7D_PAD_SD3_CLK__SD3_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_CMD__SD3_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA0__SD3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA1__SD3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA2__SD3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA3__SD3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA4__SD3_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA5__SD3_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA6__SD3_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA7__SD3_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_STROBE__SD3_STROBE	 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	MX7D_PAD_SD3_RESET_B__GPIO6_IO11 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+#define IOX_SDI IMX_GPIO_NR(1, 9)
+#define IOX_STCP IMX_GPIO_NR(1, 12)
+#define IOX_SHCP IMX_GPIO_NR(1, 13)
+
+static iomux_v3_cfg_t const iox_pads[] = {
+	/* IOX_SDI */
+	MX7D_PAD_GPIO1_IO09__GPIO1_IO9	| MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* IOX_STCP */
+	MX7D_PAD_GPIO1_IO12__GPIO1_IO12	| MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* IOX_SHCP */
+	MX7D_PAD_GPIO1_IO13__GPIO1_IO13	| MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+/*
+ * PCIE_DIS_B --> Q0
+ * PCIE_RST_B --> Q1
+ * HDMI_RST_B --> Q2
+ * PERI_RST_B --> Q3
+ * SENSOR_RST_B --> Q4
+ * ENET_RST_B --> Q5
+ * PERI_3V3_EN --> Q6
+ * LCD_PWR_EN --> Q7
+ */
+enum qn {
+	PCIE_DIS_B,
+	PCIE_RST_B,
+	HDMI_RST_B,
+	PERI_RST_B,
+	SENSOR_RST_B,
+	ENET_RST_B,
+	PERI_3V3_EN,
+	LCD_PWR_EN,
+};
+
+enum qn_func {
+	qn_reset,
+	qn_enable,
+	qn_disable,
+};
+
+enum qn_level {
+	qn_low = 0,
+	qn_high = 1,
+};
+
+static enum qn_level seq[3][2] = {
+	{0, 1}, {1, 1}, {0, 0}
+};
+
+static enum qn_func qn_output[8] = {
+	qn_disable, qn_reset, qn_reset, qn_reset, qn_reset, qn_reset, qn_enable,
+	qn_enable
+};
+
+void iox74lv_init(void)
+{
+	int i;
+
+	for (i = 7; i >= 0; i--) {
+		gpio_direction_output(IOX_SHCP, 0);
+		gpio_direction_output(IOX_SDI, seq[qn_output[i]][0]);
+		udelay(500);
+		gpio_direction_output(IOX_SHCP, 1);
+		udelay(500);
+	}
+
+	gpio_direction_output(IOX_STCP, 0);
+	udelay(500);
+	/*
+	  * shift register will be output to pins
+	  */
+	gpio_direction_output(IOX_STCP, 1);
+
+	for (i = 7; i >= 0; i--) {
+		gpio_direction_output(IOX_SHCP, 0);
+		gpio_direction_output(IOX_SDI, seq[qn_output[i]][1]);
+		udelay(500);
+		gpio_direction_output(IOX_SHCP, 1);
+		udelay(500);
+	}
+	gpio_direction_output(IOX_STCP, 0);
+	udelay(500);
+	/*
+	  * shift register will be output to pins
+	  */
+	gpio_direction_output(IOX_STCP, 1);
+};
+
+void iox74lv_set(int index)
+{
+	int i;
+	for (i = 7; i >= 0; i--) {
+		gpio_direction_output(IOX_SHCP, 0);
+
+		if (i == index)
+			gpio_direction_output(IOX_SDI, seq[qn_output[i]][0]);
+		else
+			gpio_direction_output(IOX_SDI, seq[qn_output[i]][1]);
+		udelay(500);
+		gpio_direction_output(IOX_SHCP, 1);
+		udelay(500);
+	}
+
+	gpio_direction_output(IOX_STCP, 0);
+	udelay(500);
+	/*
+	  * shift register will be output to pins
+	  */
+	gpio_direction_output(IOX_STCP, 1);
+
+	for (i = 7; i >= 0; i--) {
+		gpio_direction_output(IOX_SHCP, 0);
+		gpio_direction_output(IOX_SDI, seq[qn_output[i]][1]);
+		udelay(500);
+		gpio_direction_output(IOX_SHCP, 1);
+		udelay(500);
+	}
+
+	gpio_direction_output(IOX_STCP, 0);
+	udelay(500);
+	/*
+	  * shift register will be output to pins
+	  */
+	gpio_direction_output(IOX_STCP, 1);
+};
+
+
+#ifdef CONFIG_SYS_USE_NAND
+static iomux_v3_cfg_t const gpmi_pads[] = {
+	MX7D_PAD_SD3_DATA0__NAND_DATA00 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_DATA1__NAND_DATA01 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_DATA2__NAND_DATA02 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_DATA3__NAND_DATA03 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_DATA4__NAND_DATA04 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_DATA5__NAND_DATA05 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_DATA6__NAND_DATA06 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_DATA7__NAND_DATA07 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_CLK__NAND_CLE	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_CMD__NAND_ALE	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_STROBE__NAND_RE_B	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_RESET_B__NAND_WE_B	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SAI1_MCLK__NAND_WP_B	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SAI1_RX_BCLK__NAND_CE3_B	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SAI1_RX_SYNC__NAND_CE2_B	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SAI1_RX_DATA__NAND_CE1_B	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SAI1_TX_BCLK__NAND_CE0_B	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SAI1_TX_SYNC__NAND_DQS	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SAI1_TX_DATA__NAND_READY_B	| MUX_PAD_CTRL(NAND_PAD_READY0_CTRL),
+};
+
+static void setup_gpmi_nand(void)
+{
+	imx_iomux_v3_setup_multiple_pads(gpmi_pads, ARRAY_SIZE(gpmi_pads));
+
+	/*
+	 * NAND_USDHC_BUS_CLK is set in rom
+	 */
+
+	set_clk_nand();
+
+	/*
+	 * APBH clock root is set in init_esdhc, USDHC3_CLK.
+	 * There is no clk gate for APBHDMA.
+	 * No touch here.
+	 */
+}
+#endif
+
+#ifdef CONFIG_VIDEO_MXS
+static iomux_v3_cfg_t const lcd_pads[] = {
+	MX7D_PAD_LCD_CLK__LCD_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_ENABLE__LCD_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_HSYNC__LCD_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_VSYNC__LCD_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA00__LCD_DATA0 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA01__LCD_DATA1 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA02__LCD_DATA2 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA03__LCD_DATA3 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA04__LCD_DATA4 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA05__LCD_DATA5 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA06__LCD_DATA6 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA07__LCD_DATA7 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA08__LCD_DATA8 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA09__LCD_DATA9 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA10__LCD_DATA10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA11__LCD_DATA11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA12__LCD_DATA12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA13__LCD_DATA13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA14__LCD_DATA14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA15__LCD_DATA15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA16__LCD_DATA16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA17__LCD_DATA17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA18__LCD_DATA18 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA19__LCD_DATA19 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA20__LCD_DATA20 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA21__LCD_DATA21 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA22__LCD_DATA22 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA23__LCD_DATA23 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+
+	/*
+	 * Use GPIO for Brightness adjustment, duty cycle = period.
+	 */
+	MX7D_PAD_GPIO1_IO01__GPIO1_IO1 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* Display power enable */
+	MX7D_PAD_EPDC_GDOE__GPIO2_IO25 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* Backlight enable */
+	MX7D_PAD_EPDC_GDCLK__GPIO2_IO24 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+#ifdef CONFIG_CMD_EADISP
+
+struct lcd_panel_info_t {
+	unsigned int lcdif_base_addr;
+	int depth;
+	void	(*enable)(struct lcd_panel_info_t const *dev);
+	struct fb_videomode mode;
+};
+
+void board_enable_rgb(const struct display_info_t *di, int enable)
+{
+	if (enable) {
+		imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+
+		mdelay(100); /* let panel sync up before enabling backlight */
+
+		/* Power up the LCD */
+		gpio_direction_output(IMX_GPIO_NR(2, 25) , 1);
+
+		/* Set Brightness to high */
+		gpio_direction_output(IMX_GPIO_NR(1, 1) , 1);
+
+		/* Backlight power enable */
+		gpio_direction_output(IMX_GPIO_NR(2, 24) , 1);
+	}
+}
+
+static const struct display_info_t displays[] = {
+	/* RGB */
+	EADISP_INNOLUX_AT070TN(RGB, 0, 0),
+	EADISP_NHD_43480272EF(RGB, 0, 0),
+	EADISP_NHD_50800480TF(RGB, 0, 0),
+	EADISP_NHD_70800480EF(RGB, 0, 0),
+	EADISP_UMSH_8864(RGB, 0, 0),
+	EADISP_UMSH_8596_30T(RGB, 0, 0),
+	EADISP_UMSH_8596_33T(RGB, 0, 0),
+	EADISP_ROGIN_RX050A(RGB, 0, 0),
+};
+
+#else /* CONFIG_CMD_EADISP */
+
+void do_enable_parallel_lcd(struct lcd_panel_info_t const *dev)
+{
+	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+
+	mdelay(100); /* let panel sync up before enabling backlight */
+
+	/* Power up the LCD */
+	gpio_direction_output(IMX_GPIO_NR(2, 25) , 1);
+
+	/* Set Brightness to high */
+	gpio_direction_output(IMX_GPIO_NR(1, 1) , 1);
+
+	/* Backlight power enable */
+	gpio_direction_output(IMX_GPIO_NR(2, 24) , 1);
+}
+
+static struct lcd_panel_info_t const displays[] = {{
+	.lcdif_base_addr = ELCDIF1_IPS_BASE_ADDR,
+	.depth = 24,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+		.name			= "Innolux-AT070TN",
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 29850,
+		.left_margin    = 89,
+		.right_margin   = 164,
+		.upper_margin   = 75,
+		.lower_margin   = 75,
+		.hsync_len      = 10,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+
+int board_video_skip(void)
+{
+	int i;
+	int ret;
+	char const *panel = getenv("panel");
+	if (!panel) {
+		panel = displays[0].mode.name;
+		printf("No panel detected: default to %s\n", panel);
+		i = 0;
+	} else {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			if (!strcmp(panel, displays[i].mode.name))
+				break;
+		}
+	}
+	if (i < ARRAY_SIZE(displays)) {
+		ret = mxs_lcd_panel_setup(displays[i].mode, displays[i].depth,
+				    displays[i].lcdif_base_addr);
+		if (!ret) {
+			if (displays[i].enable)
+				displays[i].enable(displays+i);
+			printf("Display: %s (%ux%u)\n",
+			       displays[i].mode.name,
+			       displays[i].mode.xres,
+			       displays[i].mode.yres);
+		} else
+			printf("LCD %s cannot be configured: %d\n",
+			       displays[i].mode.name, ret);
+	} else {
+		printf("unsupported panel %s\n", panel);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#endif /* CONFIG_CMD_EADISP */
+#endif /* CONFIG_VIDEO_MXS */
+
+#ifdef CONFIG_FEC_MXC
+static iomux_v3_cfg_t const fec1_pads[] = {
+	MX7D_PAD_ENET1_RGMII_RX_CTL__ENET1_RGMII_RX_CTL | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_RD0__ENET1_RGMII_RD0 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_RD1__ENET1_RGMII_RD1 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_RD2__ENET1_RGMII_RD2 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_RD3__ENET1_RGMII_RD3 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_RXC__ENET1_RGMII_RXC | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TX_CTL__ENET1_RGMII_TX_CTL | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TD0__ENET1_RGMII_TD0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TD1__ENET1_RGMII_TD1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TD2__ENET1_RGMII_TD2 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TD3__ENET1_RGMII_TD3 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TXC__ENET1_RGMII_TXC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_GPIO1_IO10__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL_MII),
+	MX7D_PAD_GPIO1_IO11__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL_MII),
+	MX7D_PAD_ENET1_COL__GPIO7_IO15 | MUX_PAD_CTRL(ENET_PAD_CTRL), /*
+	MX7D_PAD_ENET1_RX_CLK__GPIO7_IO13 |MUX_PAD_CTRL(ENET_PAD_CTRL), */
+};
+
+static void setup_iomux_fec(void)
+{
+	imx_iomux_v3_setup_multiple_pads(fec1_pads, ARRAY_SIZE(fec1_pads));
+}
+#endif
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_FSL_QSPI
+static iomux_v3_cfg_t const quadspi_pads[] = {
+	MX7D_PAD_EPDC_DATA00__QSPI_A_DATA0 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA01__QSPI_A_DATA1 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA02__QSPI_A_DATA2 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA03__QSPI_A_DATA3 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA05__QSPI_A_SCLK  | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA06__QSPI_A_SS0_B | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+};
+
+int board_qspi_init(void)
+{
+	/* Set the iomux */
+	imx_iomux_v3_setup_multiple_pads(quadspi_pads, ARRAY_SIZE(quadspi_pads));
+
+	/* Set the clock */
+	set_clk_qspi();
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+
+#define USDHC1_CD_GPIO	IMX_GPIO_NR(5, 0)
+#define USDHC1_PWR_GPIO	IMX_GPIO_NR(5, 2)
+#define USDHC3_PWR_GPIO IMX_GPIO_NR(6, 11)
+
+static struct fsl_esdhc_cfg usdhc_cfg[3] = {
+	{USDHC1_BASE_ADDR, 0, 4},
+	{USDHC3_BASE_ADDR},
+};
+
+int mmc_get_env_devno(void)
+{
+	struct bootrom_sw_info **p =
+		(struct bootrom_sw_info **)ROM_SW_INFO_ADDR;
+
+	u8 boot_type = (*p)->boot_dev_type;
+	u8 dev_no = (*p)->boot_dev_instance;
+
+	/* If not boot from sd/mmc, use default value */
+	if ((boot_type != BOOT_TYPE_SD) && (boot_type != BOOT_TYPE_MMC))
+		return CONFIG_SYS_MMC_ENV_DEV;
+
+	if (2 == dev_no)
+		dev_no--;
+
+	return dev_no;
+}
+
+int mmc_map_to_kernel_blk(int dev_no)
+{
+	if (1 == dev_no)
+		dev_no++;
+
+	return dev_no;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC1_BASE_ADDR:
+		ret = !gpio_get_value(USDHC1_CD_GPIO);
+		break;
+	case USDHC3_BASE_ADDR:
+		ret = 1; /* Assume uSDHC3 emmc is always present */
+		break;
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int i, ret;
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC1
+	 * mmc2                    USDHC3 (eMMC)
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+#if defined(CONFIG_SPL_BUILD)
+                // The SPL framework expects there to be only one MMC device
+                // and we always loads u-boot from eMMC which is mapped to mmc1
+                if (i != 1) continue;
+#endif
+
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
+			gpio_request(USDHC1_CD_GPIO, "usdhc1_cd");
+			gpio_direction_input(USDHC1_CD_GPIO);
+			gpio_request(USDHC1_PWR_GPIO, "usdhc1_pwr");
+			gpio_direction_output(USDHC1_PWR_GPIO, 0);
+			udelay(500);
+			gpio_direction_output(USDHC1_PWR_GPIO, 1);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+			break;
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_emmc_pads, ARRAY_SIZE(usdhc3_emmc_pads));
+			gpio_request(USDHC3_PWR_GPIO, "usdhc3_pwr");
+			gpio_direction_output(USDHC3_PWR_GPIO, 0);
+			udelay(500);
+			gpio_direction_output(USDHC3_PWR_GPIO, 1);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) than supported by the board\n", i + 1);
+			return 0;
+			}
+
+			ret = fsl_esdhc_initialize(bis, &usdhc_cfg[i]);
+			if (ret)
+				return ret;
+	}
+
+	return 0;
+}
+
+int check_mmc_autodetect(void)
+{
+	char *autodetect_str = getenv("mmcautodetect");
+
+	if ((autodetect_str != NULL) &&
+		(strcmp(autodetect_str, "yes") == 0)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+void board_late_mmc_init(void)
+{
+	char cmd[32];
+	char mmcblk[32];
+	u32 dev_no = mmc_get_env_devno();
+
+	if (!check_mmc_autodetect())
+		return;
+
+	setenv_ulong("mmcdev", dev_no);
+
+	/* Set mmcblk env */
+	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
+		mmc_map_to_kernel_blk(dev_no));
+	setenv("mmcroot", mmcblk);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
+}
+
+#endif
+
+#ifdef CONFIG_FEC_MXC
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+	ea_eeprom_config_t config;
+
+	setup_iomux_fec();
+
+	ret = fecmxc_initialize_multi(bis, 0,
+		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+	if (ret)
+		printf("FEC1 MXC: %s:failed\n", __func__);
+
+        /* stored MAC addresses to env variables */
+        if (ea_eeprom_get_config(&config) == 0) {
+
+                if (is_valid_ether_addr(config.mac1) && !getenv("ethaddr")) {
+                        eth_setenv_enetaddr("ethaddr", config.mac1);
+                }
+
+                if (is_valid_ether_addr(config.mac2) && !getenv("eth1addr")) {
+                        eth_setenv_enetaddr("eth1addr", config.mac2);
+                }
+
+                if (is_valid_ether_addr(config.mac3) && !getenv("eth2addr")) {
+                        eth_setenv_enetaddr("eth2addr", config.mac3);
+                }
+
+                if (is_valid_ether_addr(config.mac4) && !getenv("eth3addr")) {
+                        eth_setenv_enetaddr("eth3addr", config.mac4);
+                }
+
+        }
+
+	return ret;
+}
+
+static int setup_fec(void)
+{
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *) IOMUXC_GPR_BASE_ADDR;
+	int ret;
+
+	/* Use 125M anatop REF_CLK1 for ENET1, clear gpr1[13], gpr1[17]*/
+	clrsetbits_le32(&iomuxc_gpr_regs->gpr[1],
+		(IOMUXC_GPR_GPR1_GPR_ENET1_TX_CLK_SEL_MASK |
+		 IOMUXC_GPR_GPR1_GPR_ENET1_CLK_DIR_MASK), 0);
+
+
+	/* enet pwr en */
+	gpio_direction_output(IMX_GPIO_NR(7, 15) , 0);
+
+	ret = set_clk_enet(ENET_125MHz);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+
+int board_phy_config(struct phy_device *phydev)
+{
+	/* enable rgmii rxc skew and phy mode select to RGMII copper */
+
+	/* Enable 1.8V(SEL_1P5_1P8_POS_REG) on
+	   Phy control debug reg 0 */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x1f);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x8);
+
+	/* rgmii tx clock delay enable */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x05);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x100);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+	return 0;
+}
+
+void board_get_hwaddr(int dev_id, unsigned char *mac)
+{
+        ea_eeprom_config_t config;
+
+        if (ea_eeprom_get_config(&config) == 0) {
+                if (dev_id == 0) {
+                        memcpy(mac, config.mac1, 6);
+                }
+                else {
+                        memcpy(mac, config.mac2, 6);
+                }
+        }
+
+}
+
+
+#endif
+
+#ifdef CONFIG_MXC_EPDC
+static iomux_v3_cfg_t const epdc_enable_pads[] = {
+	MX7D_PAD_EPDC_DATA00__EPDC_DATA0	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA01__EPDC_DATA1	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA02__EPDC_DATA2	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA03__EPDC_DATA3	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA04__EPDC_DATA4	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA05__EPDC_DATA5	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA06__EPDC_DATA6	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA07__EPDC_DATA7	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCLK__EPDC_SDCLK		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_SDLE__EPDC_SDLE		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_SDOE__EPDC_SDOE		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_SDSHR__EPDC_SDSHR		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE0__EPDC_SDCE0		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE1__EPDC_SDCE1		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_GDCLK__EPDC_GDCLK		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_GDOE__EPDC_GDOE		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_GDRL__EPDC_GDRL		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_GDSP__EPDC_GDSP		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_BDR0__EPDC_BDR0		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_BDR1__EPDC_BDR1		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const epdc_disable_pads[] = {
+	MX7D_PAD_EPDC_DATA00__GPIO2_IO0,
+	MX7D_PAD_EPDC_DATA01__GPIO2_IO1,
+	MX7D_PAD_EPDC_DATA02__GPIO2_IO2,
+	MX7D_PAD_EPDC_DATA03__GPIO2_IO3,
+	MX7D_PAD_EPDC_DATA04__GPIO2_IO4,
+	MX7D_PAD_EPDC_DATA05__GPIO2_IO5,
+	MX7D_PAD_EPDC_DATA06__GPIO2_IO6,
+	MX7D_PAD_EPDC_DATA07__GPIO2_IO7,
+	MX7D_PAD_EPDC_SDCLK__GPIO2_IO16,
+	MX7D_PAD_EPDC_SDLE__GPIO2_IO17,
+	MX7D_PAD_EPDC_SDOE__GPIO2_IO18,
+	MX7D_PAD_EPDC_SDSHR__GPIO2_IO19,
+	MX7D_PAD_EPDC_SDCE0__GPIO2_IO20,
+	MX7D_PAD_EPDC_SDCE1__GPIO2_IO21,
+	MX7D_PAD_EPDC_GDCLK__GPIO2_IO24,
+	MX7D_PAD_EPDC_GDOE__GPIO2_IO25,
+	MX7D_PAD_EPDC_GDRL__GPIO2_IO26,
+	MX7D_PAD_EPDC_GDSP__GPIO2_IO27,
+	MX7D_PAD_EPDC_BDR0__GPIO2_IO28,
+	MX7D_PAD_EPDC_BDR1__GPIO2_IO29,
+};
+
+vidinfo_t panel_info = {
+	.vl_refresh = 85,
+	.vl_col = 1024,
+	.vl_row = 758,
+	.vl_pixclock = 40000000,
+	.vl_left_margin = 12,
+	.vl_right_margin = 76,
+	.vl_upper_margin = 4,
+	.vl_lower_margin = 5,
+	.vl_hsync = 12,
+	.vl_vsync = 2,
+	.vl_sync = 0,
+	.vl_mode = 0,
+	.vl_flag = 0,
+	.vl_bpix = 3,
+	.cmap = 0,
+};
+
+struct epdc_timing_params panel_timings = {
+	.vscan_holdoff = 4,
+	.sdoed_width = 10,
+	.sdoed_delay = 20,
+	.sdoez_width = 10,
+	.sdoez_delay = 20,
+	.gdclk_hp_offs = 524,
+	.gdsp_offs = 327,
+	.gdoe_offs = 0,
+	.gdclk_offs = 19,
+	.num_ce = 1,
+};
+
+static void setup_epdc_power(void)
+{
+	/* IOMUX_GPR1: bit30: Disable On-chip RAM EPDC Function */
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *) IOMUXC_GPR_BASE_ADDR;
+
+	clrsetbits_le32(&iomuxc_gpr_regs->gpr[1],
+		IOMUXC_GPR_GPR1_GPR_ENABLE_OCRAM_EPDC_MASK, 0);
+
+	/* Setup epdc voltage */
+
+	/* EPDC_PWRSTAT - GPIO2[31] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX7D_PAD_EPDC_PWR_STAT__GPIO2_IO31 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	gpio_direction_input(IMX_GPIO_NR(2, 31));
+
+	/* EPDC_VCOM0 - GPIO4[14] for VCOM control */
+	imx_iomux_v3_setup_pad(MX7D_PAD_I2C4_SCL__GPIO4_IO14 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(4, 14), 1);
+
+	/* EPDC_PWRWAKEUP - GPIO2[23] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX7D_PAD_EPDC_SDCE3__GPIO2_IO23 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(2, 23), 1);
+
+	/* EPDC_PWRCTRL0 - GPIO2[30] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX7D_PAD_EPDC_PWR_COM__GPIO2_IO30 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(2, 30), 1);
+}
+
+static void epdc_enable_pins(void)
+{
+	/* epdc iomux settings */
+	imx_iomux_v3_setup_multiple_pads(epdc_enable_pads,
+				ARRAY_SIZE(epdc_enable_pads));
+}
+
+static void epdc_disable_pins(void)
+{
+	/* Configure MUX settings for EPDC pins to GPIO  and drive to 0 */
+	imx_iomux_v3_setup_multiple_pads(epdc_disable_pads,
+				ARRAY_SIZE(epdc_disable_pads));
+}
+
+static void setup_epdc(void)
+{
+	/*** epdc Maxim PMIC settings ***/
+
+	/* EPDC_PWRSTAT - GPIO2[31] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX7D_PAD_EPDC_PWR_STAT__GPIO2_IO31 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC_VCOM0 - GPIO4[14] for VCOM control */
+	imx_iomux_v3_setup_pad(MX7D_PAD_I2C4_SCL__GPIO4_IO14 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC_PWRWAKEUP - GPIO4[23] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX7D_PAD_EPDC_SDCE3__GPIO2_IO23 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC_PWRCTRL0 - GPIO4[20] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX7D_PAD_EPDC_PWR_COM__GPIO2_IO30 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* Set pixel clock rates for EPDC in clock.c */
+
+	panel_info.epdc_data.wv_modes.mode_init = 0;
+	panel_info.epdc_data.wv_modes.mode_du = 1;
+	panel_info.epdc_data.wv_modes.mode_gc4 = 3;
+	panel_info.epdc_data.wv_modes.mode_gc8 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc16 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc32 = 2;
+
+	panel_info.epdc_data.epdc_timings = panel_timings;
+
+	setup_epdc_power();
+}
+
+void epdc_power_on(void)
+{
+	unsigned int reg;
+	struct gpio_regs *gpio_regs = (struct gpio_regs *)GPIO2_BASE_ADDR;
+
+	/* Set EPD_PWR_CTL0 to high - enable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(2, 30), 1);
+	udelay(1000);
+
+	/* Enable epdc signal pin */
+	epdc_enable_pins();
+
+	/* Set PMIC Wakeup to high - enable Display power */
+	gpio_set_value(IMX_GPIO_NR(2, 23), 1);
+
+	/* Wait for PWRGOOD == 1 */
+	while (1) {
+		reg = readl(&gpio_regs->gpio_psr);
+		if (!(reg & (1 << 31)))
+			break;
+
+		udelay(100);
+	}
+
+	/* Enable VCOM */
+	gpio_set_value(IMX_GPIO_NR(4, 14), 1);
+
+	udelay(500);
+}
+
+void epdc_power_off(void)
+{
+	/* Set PMIC Wakeup to low - disable Display power */
+	gpio_set_value(IMX_GPIO_NR(2, 23), 0);
+
+	/* Disable VCOM */
+	gpio_set_value(IMX_GPIO_NR(4, 14), 0);
+
+	epdc_disable_pins();
+
+	/* Set EPD_PWR_CTL0 to low - disable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(2, 30), 0);
+}
+#endif
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	setup_i2c(2, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info3);
+#endif
+
+	ea_eeprom_init();
+
+	return 0;
+}
+
+int board_init(void)
+{
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+	imx_iomux_v3_setup_multiple_pads(iox_pads, ARRAY_SIZE(iox_pads));
+
+	iox74lv_init();
+
+#ifdef CONFIG_FEC_MXC
+	setup_fec();
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+	setup_gpmi_nand();
+#endif
+
+#ifdef CONFIG_FSL_QSPI
+	board_qspi_init();
+#endif
+
+#ifdef	CONFIG_MXC_EPDC
+	qn_output[5] = qn_disable;
+	iox74lv_set(5);
+	setup_epdc();
+#endif
+
+#ifdef CONFIG_CMD_EADISP
+	eadisp_setup_display(displays, ARRAY_SIZE(displays));
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd1", MAKE_CFGVAL(0x10, 0x10, 0x00, 0x00)},
+	{"emmc", MAKE_CFGVAL(0x10, 0x2a, 0x00, 0x00)},
+	/* TODO: Nand */
+	{"qspi", MAKE_CFGVAL(0x00, 0x40, 0x00, 0x00)},
+	{NULL,   0},
+};
+#endif
+
+#ifdef CONFIG_POWER
+#define I2C_PMIC	0
+int power_init_board(void)
+{
+	return 0;
+}
+#endif
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_init();
+#endif
+
+#ifdef CONFIG_CMD_EADISP
+	eatouch_init();
+#endif
+
+	imx_iomux_v3_setup_multiple_pads(wdog_pads, ARRAY_SIZE(wdog_pads));
+
+	set_wdog_reset((struct wdog_regs *)WDOG1_BASE_ADDR);
+
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+	ea_eeprom_config_t config;
+
+	puts("Board: Embedded Artists ");
+        if (ea_eeprom_get_config(&config) == 0) {
+
+                printf("%s\n", config.name);
+                printf("       %05d, %s, WO%d\n",
+                        config.board_part_nr,
+                        config.board_rev,
+                        config.batch);
+
+        }
+        else {
+                puts(" [Unknown board due to invalid configuration data]\n");
+        }
+
+	return 0;
+}
+
+#ifdef CONFIG_USB_EHCI_MX7
+iomux_v3_cfg_t const usb_otg1_pads[] = {
+	MX7D_PAD_GPIO1_IO05__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+iomux_v3_cfg_t const usb_otg2_pads[] = {
+	MX7D_PAD_UART3_CTS_B__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+int board_ehci_hcd_init(int port)
+{
+	switch (port) {
+	case 0:
+		imx_iomux_v3_setup_multiple_pads(usb_otg1_pads,
+						 ARRAY_SIZE(usb_otg1_pads));
+		break;
+	case 1:
+		imx_iomux_v3_setup_multiple_pads(usb_otg2_pads,
+						 ARRAY_SIZE(usb_otg2_pads));
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_FASTBOOT
+
+void board_fastboot_setup(void)
+{
+	switch (get_boot_device()) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc0");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc0");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc1");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc1");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("unsupported boot devices\n");
+		break;
+	}
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+
+/* Use S3 button for recovery key */
+#define GPIO_VOL_DN_KEY IMX_GPIO_NR(5, 10)
+iomux_v3_cfg_t const recovery_key_pads[] = {
+	(MX7D_PAD_SD2_WP__GPIO5_IO10 | MUX_PAD_CTRL(BUTTON_PAD_CTRL)),
+};
+
+int check_recovery_cmd_file(void)
+{
+	int button_pressed = 0;
+	int recovery_mode = 0;
+
+	recovery_mode = recovery_check_and_clean_flag();
+
+	/* Check Recovery Combo Button press or not. */
+	imx_iomux_v3_setup_multiple_pads(recovery_key_pads,
+		ARRAY_SIZE(recovery_key_pads));
+
+	gpio_direction_input(GPIO_VOL_DN_KEY);
+
+	if (gpio_get_value(GPIO_VOL_DN_KEY) == 0) { /* VOL_DN key is low assert */
+		button_pressed = 1;
+		printf("Recovery key pressed\n");
+	}
+
+	return recovery_mode || button_pressed;
+}
+
+void board_recovery_setup(void)
+{
+	int bootdev = get_boot_device();
+
+	switch (bootdev) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc0 recovery");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc1 recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("Unsupported bootup device for recovery: dev: %d\n",
+			bootdev);
+		return;
+	}
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FSL_FASTBOOT*/
diff --git a/board/embeddedartists/mx7dea-com/plugin.S b/board/embeddedartists/mx7dea-com/plugin.S
new file mode 100644
index 0000000..77e098b
--- /dev/null
+++ b/board/embeddedartists/mx7dea-com/plugin.S
@@ -0,0 +1,156 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx7d_sabresd_ddr_setting
+	/* Configure ocram_epdc */
+	ldr r0, =IOMUXC_GPR_BASE_ADDR
+	ldr r1, =0x4f400005
+	str r1, [r0, #0x4]
+
+	ldr r0, =SRC_BASE_ADDR
+	ldr r1, =0x2
+	ldr r2, =0x1000
+	str r1, [r0, r2]
+
+	ldr r0, =DDRC_IPS_BASE_ADDR
+	ldr r1, =0x01040001
+	str r1, [r0]
+	ldr r1, =0x80400003
+	str r1, [r0, #0x1a0]
+	ldr r1, =0x00100020
+	str r1, [r0, #0x1a4]
+	ldr r1, =0x80100004
+	str r1, [r0, #0x1a8]
+	ldr r1, =0x00400046
+	str r1, [r0, #0x64]
+	ldr r1, =0x1
+	str r1, [r0, #0x490]
+	ldr r1, =0x00020001
+	str r1, [r0, #0xd0]
+	ldr r1, =0x00690000
+	str r1, [r0, #0xd4]
+	ldr r1, =0x09300004
+	str r1, [r0, #0xdc]
+	ldr r1, =0x04080000
+	str r1, [r0, #0xe0]
+	ldr r1, =0x00100004
+	str r1, [r0, #0xe4]
+	ldr r1, =0x33f
+	str r1, [r0, #0xf4]
+	ldr r1, =0x09081109
+	str r1, [r0, #0x100]
+	ldr r1, =0x0007020d
+	str r1, [r0, #0x104]
+	ldr r1, =0x03040407
+	str r1, [r0, #0x108]
+	ldr r1, =0x00002006
+	str r1, [r0, #0x10c]
+	ldr r1, =0x04020205
+	str r1, [r0, #0x110]
+	ldr r1, =0x03030202
+	str r1, [r0, #0x114]
+	ldr r1, =0x00000803
+	str r1, [r0, #0x120]
+	ldr r1, =0x00800020
+	str r1, [r0, #0x180]
+	ldr r1, =0x02000100
+	str r1, [r0, #0x184]
+	ldr r1, =0x02098204
+	str r1, [r0, #0x190]
+	ldr r1, =0x00030303
+	str r1, [r0, #0x194]
+
+	ldr r1, =0x00000016
+	str r1, [r0, #0x200]
+	ldr r1, =0x00171717
+	str r1, [r0, #0x204]
+	ldr r1, =0x04040404
+	str r1, [r0, #0x214]
+	ldr r1, =0x0f040404
+	str r1, [r0, #0x218]
+
+	ldr r1, =0x06000604
+	str r1, [r0, #0x240]
+	ldr r1, =0x00000001
+	str r1, [r0, #0x244]
+
+	ldr r0, =SRC_BASE_ADDR
+	mov r1, #0x0
+	ldr r2, =0x1000
+	str r1, [r0, r2]
+
+	ldr r0, =DDRPHY_IPS_BASE_ADDR
+	ldr r1, =0x17420f40
+	str r1, [r0]
+	ldr r1, =0x10210100
+	str r1, [r0, #0x4]
+	ldr r1, =0x00060807
+	str r1, [r0, #0x10]
+	ldr r1, =0x1010007e
+	str r1, [r0, #0xb0]
+	ldr r1, =0x00000d6e
+	str r1, [r0, #0x9c]
+	ldr r1, =0x08080808
+	str r1, [r0, #0x20]
+	ldr r1, =0x08080808
+	str r1, [r0, #0x30]
+	ldr r1, =0x01000010
+	str r1, [r0, #0x50]
+
+	ldr r1, =0x0e407304
+	str r1, [r0, #0xc0]
+	ldr r1, =0x0e447304
+	str r1, [r0, #0xc0]
+	ldr r1, =0x0e447306
+	str r1, [r0, #0xc0]
+
+wait_zq:
+	ldr r1, [r0, #0xc4]
+	tst r1, #0x1
+	beq wait_zq
+
+	ldr r1, =0x0e447304
+	str r1, [r0, #0xc0]
+	ldr r1, =0x0e407304
+	str r1, [r0, #0xc0]
+
+	ldr r0, =CCM_BASE_ADDR
+	mov r1, #0x0
+	ldr r2, =0x4130
+	str r1, [r0, r2]
+	ldr r0, =IOMUXC_GPR_BASE_ADDR
+	mov r1, #0x178
+	str r1, [r0, #0x20]
+	ldr r0, =CCM_BASE_ADDR
+	mov r1, #0x2
+	ldr r2, =0x4130
+	str r1, [r0, r2]
+	ldr r0, =DDRPHY_IPS_BASE_ADDR
+	ldr r1, =0x0000000f
+	str r1, [r0, #0x18]
+
+	ldr r0, =DDRC_IPS_BASE_ADDR
+wait_stat:
+	ldr r1, [r0, #0x4]
+	tst r1, #0x1
+	beq wait_stat
+.endm
+
+.macro imx7_clock_gating
+.endm
+
+.macro imx7_qos_setting
+.endm
+
+.macro imx7_ddr_setting
+	imx7d_sabresd_ddr_setting
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx7_plugin.S>
diff --git a/board/embeddedartists/mx7dea-ucom/Kconfig b/board/embeddedartists/mx7dea-ucom/Kconfig
new file mode 100644
index 0000000..9ff282d
--- /dev/null
+++ b/board/embeddedartists/mx7dea-ucom/Kconfig
@@ -0,0 +1,15 @@
+if TARGET_MX7DEA_UCOM
+
+config SYS_BOARD
+	default "mx7dea-ucom"
+
+config SYS_VENDOR
+	default "embeddedartists"
+
+config SYS_SOC
+	default "mx7"
+
+config SYS_CONFIG_NAME
+	default "mx7dea-ucom"
+
+endif
diff --git a/board/embeddedartists/mx7dea-ucom/Makefile b/board/embeddedartists/mx7dea-ucom/Makefile
new file mode 100644
index 0000000..fbec36b
--- /dev/null
+++ b/board/embeddedartists/mx7dea-ucom/Makefile
@@ -0,0 +1,10 @@
+# (C) Copyright 2015 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx7dea-ucom.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff --git a/board/embeddedartists/mx7dea-ucom/imximage.cfg b/board/embeddedartists/mx7dea-ucom/imximage.cfg
new file mode 100644
index 0000000..e1f2957
--- /dev/null
+++ b/board/embeddedartists/mx7dea-ucom/imximage.cfg
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx7dsabresd/plugin.bin 0x00910000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x30340004 0x4F400005
+
+DATA 4 0x30391000 0x00000002
+DATA 4 0x307a0000 0x01040008
+DATA 4 0x307A0064 0x00200038
+DATA 4 0x307a0490 0x00000001
+DATA 4 0x307A00D0 0x00350001
+DATA 4 0x307A00DC 0x00C3000A
+DATA 4 0x307A00E0 0x00010000
+DATA 4 0x307A00E4 0x00110006
+DATA 4 0x307A00F4 0x0000033F	
+DATA 4 0x307A0100 0x0A0E110B	
+DATA 4 0x307A0104 0x00020211	
+DATA 4 0x307A0108 0x03060708	
+DATA 4 0x307A010C 0x00A0500C	
+DATA 4 0x307A0110 0x05020307	
+DATA 4 0x307A0114 0x02020404	
+DATA 4 0x307A0118 0x02020003	
+DATA 4 0x307A011C 0x00000202	
+DATA 4 0x307A0120 0x00000202	
+DATA 4 0x307A0180 0x00600018
+DATA 4 0x307A0184 0x00E00100
+DATA 4 0x307A0190 0x02098205	
+DATA 4 0x307A0194 0x00060303	
+DATA 4 0x307A01A0 0x80400003	
+DATA 4 0x307A01A4 0x00100020	
+DATA 4 0x307A01A8 0x80100004	
+DATA 4 0x307A0200 0x00000016	
+DATA 4 0x307A0204 0x00171717	
+DATA 4 0x307A0210 0x00000F0F	
+DATA 4 0x307A0214 0x04040404	
+DATA 4 0x307A0218 0x0F040404	
+DATA 4 0x307A0240 0x06000600
+DATA 4 0x307A0244 0x00000000
+
+
+
+DATA 4 0x30391000 0x00000000
+DATA 4 0x30790000 0x17421e40
+DATA 4 0x30790004 0x10210100
+DATA 4 0x30790008 0x00010000
+DATA 4 0x30790010 0x0007080C
+DATA 4 0x307900b0 0x1010007e
+DATA 4 0x3079001C 0x01010000
+DATA 4 0x3079009c 0x00000b24
+DATA 4 0x30790020 0x0A0A0A0A
+DATA 4 0x30790030 0x06060606
+DATA 4 0x30790050 0x01000008
+DATA 4 0x30790050 0x00000008
+DATA 4 0x30790018 0x0000000F
+
+DATA 4 0x307900c0 0x0C487304
+DATA 4 0x307900c0 0x0C4C7304
+DATA 4 0x307900c0 0x0C4C7306
+DATA 4 0x307900C0 0x0C4C7304
+
+/* CHECK_BITS_SET 4 0x307900c4 0x1 */
+
+
+DATA 4 0x30384130 0x00000000
+DATA 4 0x30340020 0x00000178
+DATA 4 0x30384130 0x00000002
+
+/*
+DATA 4 0x30790018 0x0000000f
+CHECK_BITS_SET 4 0x307a0004 0x1
+*/
+
+#endif
diff --git a/board/embeddedartists/mx7dea-ucom/mx7dea-ucom.c b/board/embeddedartists/mx7dea-ucom/mx7dea-ucom.c
new file mode 100644
index 0000000..67d29df
--- /dev/null
+++ b/board/embeddedartists/mx7dea-ucom/mx7dea-ucom.c
@@ -0,0 +1,1249 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx7-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#if defined(CONFIG_CMD_EADISP)
+#include <asm/imx-common/eadisp.h>
+#include <asm/imx-common/eatouch.h>
+#endif
+#include <asm/io.h>
+#include <linux/sizes.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <mmc.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <power/pmic.h>
+#ifdef CONFIG_SYS_I2C_MXC
+#include <i2c.h>
+#include <asm/imx-common/mxc_i2c.h>
+#endif
+#if defined(CONFIG_MXC_EPDC)
+#include <lcd.h>
+#include <mxc_epdc_fb.h>
+#endif
+#include <asm/arch/crm_regs.h>
+
+#ifdef CONFIG_VIDEO_MXS
+#include <linux/fb.h>
+#include <mxsfb.h>
+#endif
+
+#ifdef CONFIG_FSL_FASTBOOT
+#include <fsl_fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FSL_FASTBOOT*/
+
+#include "../common/mx6ea_eeprom.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_DSE_3P3V_49OHM | \
+	PAD_CTL_PUS_PU100KOHM | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_DSE_3P3V_32OHM | PAD_CTL_SRE_SLOW | \
+	PAD_CTL_HYS | PAD_CTL_PUE | PAD_CTL_PUS_PU47KOHM)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_PU100KOHM | PAD_CTL_DSE_3P3V_49OHM)
+#define ENET_PAD_CTRL_MII  (PAD_CTL_DSE_3P3V_32OHM)
+
+#define ENET_RX_PAD_CTRL  (PAD_CTL_PUS_PU100KOHM | PAD_CTL_DSE_3P3V_49OHM)
+
+#define I2C_PAD_CTRL    (PAD_CTL_DSE_3P3V_32OHM | PAD_CTL_SRE_SLOW | \
+	PAD_CTL_HYS | PAD_CTL_PUE | PAD_CTL_PUS_PU100KOHM)
+
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_PU100KOHM | \
+	PAD_CTL_DSE_3P3V_49OHM)
+
+#define QSPI_PAD_CTRL	\
+	(PAD_CTL_DSE_3P3V_49OHM | PAD_CTL_PUE | PAD_CTL_PUS_PU47KOHM)
+
+#define SPI_PAD_CTRL (PAD_CTL_DSE_3P3V_49OHM | PAD_CTL_SRE_SLOW | PAD_CTL_HYS)
+
+#define BUTTON_PAD_CTRL    (PAD_CTL_PUS_PU5KOHM | PAD_CTL_DSE_3P3V_98OHM)
+
+#define NAND_PAD_CTRL (PAD_CTL_DSE_3P3V_49OHM | PAD_CTL_SRE_SLOW | PAD_CTL_HYS)
+
+#define NAND_PAD_READY0_CTRL (PAD_CTL_DSE_3P3V_49OHM | PAD_CTL_PUS_PU5KOHM)
+
+#define EPDC_PAD_CTRL	0x0
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = MX7D_PAD_I2C1_SCL__I2C1_SCL | PC,
+		.gpio_mode = MX7D_PAD_I2C1_SCL__GPIO4_IO8 | PC,
+		.gp = IMX_GPIO_NR(4, 8),
+	},
+	.sda = {
+		.i2c_mode = MX7D_PAD_I2C1_SDA__I2C1_SDA | PC,
+		.gpio_mode = MX7D_PAD_I2C1_SDA__GPIO4_IO9 | PC,
+		.gp = IMX_GPIO_NR(4, 9),
+	},
+};
+
+/* I2C3 */
+struct i2c_pads_info i2c_pad_info3 = {
+	.scl = {
+		.i2c_mode = MX7D_PAD_I2C3_SCL__I2C3_SCL | PC,
+		.gpio_mode = MX7D_PAD_I2C3_SCL__GPIO4_IO12 | PC,
+		.gp = IMX_GPIO_NR(4, 12),
+	},
+	.sda = {
+		.i2c_mode = MX7D_PAD_I2C3_SDA__I2C3_SDA | PC,
+		.gpio_mode = MX7D_PAD_I2C3_SDA__GPIO4_IO13 | PC,
+		.gp = IMX_GPIO_NR(4, 13),
+	},
+};
+#endif
+
+
+
+int dram_init(void)
+{
+	ea_eeprom_config_t config;
+
+	// default size from configuration file
+	gd->ram_size = PHYS_SDRAM_SIZE;
+
+        // getting actual size from eeprom configuration
+
+        if (ea_eeprom_get_config(&config) == 0) {
+                /* ddr_size is given in MB */
+                gd->ram_size = (config.ddr_size << 20);
+        }
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const wdog_pads[] = {
+	MX7D_PAD_GPIO1_IO00__WDOG1_WDOG_B | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX7D_PAD_UART1_TX_DATA__UART1_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX7D_PAD_UART1_RX_DATA__UART1_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc1_pads[] = {
+	MX7D_PAD_SD1_CLK__SD1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_CMD__SD1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_DATA0__SD1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_DATA1__SD1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_DATA2__SD1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_DATA3__SD1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	MX7D_PAD_SD1_CD_B__GPIO5_IO0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_RESET_B__GPIO5_IO2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc3_emmc_pads[] = {
+	MX7D_PAD_SD3_CLK__SD3_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_CMD__SD3_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA0__SD3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA1__SD3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA2__SD3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA3__SD3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA4__SD3_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA5__SD3_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA6__SD3_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA7__SD3_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_STROBE__SD3_STROBE	 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	MX7D_PAD_SD3_RESET_B__GPIO6_IO11 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+#define IOX_SDI IMX_GPIO_NR(1, 9)
+#define IOX_STCP IMX_GPIO_NR(1, 12)
+#define IOX_SHCP IMX_GPIO_NR(1, 13)
+
+static iomux_v3_cfg_t const iox_pads[] = {
+	/* IOX_SDI */
+	MX7D_PAD_GPIO1_IO09__GPIO1_IO9	| MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* IOX_STCP */
+	MX7D_PAD_GPIO1_IO12__GPIO1_IO12	| MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* IOX_SHCP */
+	MX7D_PAD_GPIO1_IO13__GPIO1_IO13	| MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+/*
+ * PCIE_DIS_B --> Q0
+ * PCIE_RST_B --> Q1
+ * HDMI_RST_B --> Q2
+ * PERI_RST_B --> Q3
+ * SENSOR_RST_B --> Q4
+ * ENET_RST_B --> Q5
+ * PERI_3V3_EN --> Q6
+ * LCD_PWR_EN --> Q7
+ */
+enum qn {
+	PCIE_DIS_B,
+	PCIE_RST_B,
+	HDMI_RST_B,
+	PERI_RST_B,
+	SENSOR_RST_B,
+	ENET_RST_B,
+	PERI_3V3_EN,
+	LCD_PWR_EN,
+};
+
+enum qn_func {
+	qn_reset,
+	qn_enable,
+	qn_disable,
+};
+
+enum qn_level {
+	qn_low = 0,
+	qn_high = 1,
+};
+
+static enum qn_level seq[3][2] = {
+	{0, 1}, {1, 1}, {0, 0}
+};
+
+static enum qn_func qn_output[8] = {
+	qn_disable, qn_reset, qn_reset, qn_reset, qn_reset, qn_reset, qn_enable,
+	qn_enable
+};
+
+void iox74lv_init(void)
+{
+	int i;
+
+	for (i = 7; i >= 0; i--) {
+		gpio_direction_output(IOX_SHCP, 0);
+		gpio_direction_output(IOX_SDI, seq[qn_output[i]][0]);
+		udelay(500);
+		gpio_direction_output(IOX_SHCP, 1);
+		udelay(500);
+	}
+
+	gpio_direction_output(IOX_STCP, 0);
+	udelay(500);
+	/*
+	  * shift register will be output to pins
+	  */
+	gpio_direction_output(IOX_STCP, 1);
+
+	for (i = 7; i >= 0; i--) {
+		gpio_direction_output(IOX_SHCP, 0);
+		gpio_direction_output(IOX_SDI, seq[qn_output[i]][1]);
+		udelay(500);
+		gpio_direction_output(IOX_SHCP, 1);
+		udelay(500);
+	}
+	gpio_direction_output(IOX_STCP, 0);
+	udelay(500);
+	/*
+	  * shift register will be output to pins
+	  */
+	gpio_direction_output(IOX_STCP, 1);
+};
+
+void iox74lv_set(int index)
+{
+	int i;
+	for (i = 7; i >= 0; i--) {
+		gpio_direction_output(IOX_SHCP, 0);
+
+		if (i == index)
+			gpio_direction_output(IOX_SDI, seq[qn_output[i]][0]);
+		else
+			gpio_direction_output(IOX_SDI, seq[qn_output[i]][1]);
+		udelay(500);
+		gpio_direction_output(IOX_SHCP, 1);
+		udelay(500);
+	}
+
+	gpio_direction_output(IOX_STCP, 0);
+	udelay(500);
+	/*
+	  * shift register will be output to pins
+	  */
+	gpio_direction_output(IOX_STCP, 1);
+
+	for (i = 7; i >= 0; i--) {
+		gpio_direction_output(IOX_SHCP, 0);
+		gpio_direction_output(IOX_SDI, seq[qn_output[i]][1]);
+		udelay(500);
+		gpio_direction_output(IOX_SHCP, 1);
+		udelay(500);
+	}
+
+	gpio_direction_output(IOX_STCP, 0);
+	udelay(500);
+	/*
+	  * shift register will be output to pins
+	  */
+	gpio_direction_output(IOX_STCP, 1);
+};
+
+
+#ifdef CONFIG_SYS_USE_NAND
+static iomux_v3_cfg_t const gpmi_pads[] = {
+	MX7D_PAD_SD3_DATA0__NAND_DATA00 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_DATA1__NAND_DATA01 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_DATA2__NAND_DATA02 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_DATA3__NAND_DATA03 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_DATA4__NAND_DATA04 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_DATA5__NAND_DATA05 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_DATA6__NAND_DATA06 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_DATA7__NAND_DATA07 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_CLK__NAND_CLE	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_CMD__NAND_ALE	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_STROBE__NAND_RE_B	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SD3_RESET_B__NAND_WE_B	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SAI1_MCLK__NAND_WP_B	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SAI1_RX_BCLK__NAND_CE3_B	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SAI1_RX_SYNC__NAND_CE2_B	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SAI1_RX_DATA__NAND_CE1_B	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SAI1_TX_BCLK__NAND_CE0_B	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SAI1_TX_SYNC__NAND_DQS	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	MX7D_PAD_SAI1_TX_DATA__NAND_READY_B	| MUX_PAD_CTRL(NAND_PAD_READY0_CTRL),
+};
+
+static void setup_gpmi_nand(void)
+{
+	imx_iomux_v3_setup_multiple_pads(gpmi_pads, ARRAY_SIZE(gpmi_pads));
+
+	/*
+	 * NAND_USDHC_BUS_CLK is set in rom
+	 */
+
+	set_clk_nand();
+
+	/*
+	 * APBH clock root is set in init_esdhc, USDHC3_CLK.
+	 * There is no clk gate for APBHDMA.
+	 * No touch here.
+	 */
+}
+#endif
+
+#ifdef CONFIG_VIDEO_MXS
+static iomux_v3_cfg_t const lcd_pads[] = {
+	MX7D_PAD_LCD_CLK__LCD_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_ENABLE__LCD_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_HSYNC__LCD_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_VSYNC__LCD_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA00__LCD_DATA0 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA01__LCD_DATA1 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA02__LCD_DATA2 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA03__LCD_DATA3 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA04__LCD_DATA4 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA05__LCD_DATA5 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA06__LCD_DATA6 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA07__LCD_DATA7 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA08__LCD_DATA8 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA09__LCD_DATA9 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA10__LCD_DATA10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA11__LCD_DATA11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA12__LCD_DATA12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA13__LCD_DATA13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA14__LCD_DATA14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA15__LCD_DATA15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA16__LCD_DATA16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA17__LCD_DATA17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA18__LCD_DATA18 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA19__LCD_DATA19 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA20__LCD_DATA20 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA21__LCD_DATA21 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA22__LCD_DATA22 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA23__LCD_DATA23 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+
+	/*
+	 * Use GPIO for Brightness adjustment, duty cycle = period.
+	 */
+	MX7D_PAD_GPIO1_IO01__GPIO1_IO1 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* Display power enable */
+	MX7D_PAD_EPDC_GDOE__GPIO2_IO25 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* Backlight enable */
+	MX7D_PAD_EPDC_GDCLK__GPIO2_IO24 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+#ifdef CONFIG_CMD_EADISP
+
+struct lcd_panel_info_t {
+	unsigned int lcdif_base_addr;
+	int depth;
+	void	(*enable)(struct lcd_panel_info_t const *dev);
+	struct fb_videomode mode;
+};
+
+void board_enable_rgb(const struct display_info_t *di, int enable)
+{
+	if (enable) {
+		imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+
+		mdelay(100); /* let panel sync up before enabling backlight */
+
+		/* Power up the LCD */
+		gpio_direction_output(IMX_GPIO_NR(2, 25) , 1);
+
+		/* Set Brightness to high */
+		gpio_direction_output(IMX_GPIO_NR(1, 1) , 1);
+
+		/* Backlight power enable */
+		gpio_direction_output(IMX_GPIO_NR(2, 24) , 1);
+	}
+}
+
+static const struct display_info_t displays[] = {
+	/* RGB */
+	EADISP_INNOLUX_AT070TN(RGB, 0, 0),
+	EADISP_NHD_43480272EF(RGB, 0, 0),
+	EADISP_NHD_50800480TF(RGB, 0, 0),
+	EADISP_NHD_70800480EF(RGB, 0, 0),
+	EADISP_UMSH_8864(RGB, 0, 0),
+	EADISP_UMSH_8596_30T(RGB, 0, 0),
+	EADISP_UMSH_8596_33T(RGB, 0, 0),
+	EADISP_ROGIN_RX050A(RGB, 0, 0),
+};
+
+#else /* CONFIG_CMD_EADISP */
+
+void do_enable_parallel_lcd(struct lcd_panel_info_t const *dev)
+{
+	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+
+	mdelay(100); /* let panel sync up before enabling backlight */
+
+	/* Power up the LCD */
+	gpio_direction_output(IMX_GPIO_NR(2, 25) , 1);
+
+	/* Set Brightness to high */
+	gpio_direction_output(IMX_GPIO_NR(1, 1) , 1);
+
+	/* Backlight power enable */
+	gpio_direction_output(IMX_GPIO_NR(2, 24) , 1);
+}
+
+static struct lcd_panel_info_t const displays[] = {{
+	.lcdif_base_addr = ELCDIF1_IPS_BASE_ADDR,
+	.depth = 24,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+		.name			= "Innolux-AT070TN",
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 29850,
+		.left_margin    = 89,
+		.right_margin   = 164,
+		.upper_margin   = 75,
+		.lower_margin   = 75,
+		.hsync_len      = 10,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+
+int board_video_skip(void)
+{
+	int i;
+	int ret;
+	char const *panel = getenv("panel");
+	if (!panel) {
+		panel = displays[0].mode.name;
+		printf("No panel detected: default to %s\n", panel);
+		i = 0;
+	} else {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			if (!strcmp(panel, displays[i].mode.name))
+				break;
+		}
+	}
+	if (i < ARRAY_SIZE(displays)) {
+		ret = mxs_lcd_panel_setup(displays[i].mode, displays[i].depth,
+				    displays[i].lcdif_base_addr);
+		if (!ret) {
+			if (displays[i].enable)
+				displays[i].enable(displays+i);
+			printf("Display: %s (%ux%u)\n",
+			       displays[i].mode.name,
+			       displays[i].mode.xres,
+			       displays[i].mode.yres);
+		} else
+			printf("LCD %s cannot be configured: %d\n",
+			       displays[i].mode.name, ret);
+	} else {
+		printf("unsupported panel %s\n", panel);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#endif /* CONFIG_CMD_EADISP */
+#endif /* CONFIG_VIDEO_MXS */
+
+#ifdef CONFIG_FEC_MXC
+static iomux_v3_cfg_t const fec1_pads[] = {
+	MX7D_PAD_ENET1_RGMII_RX_CTL__ENET1_RGMII_RX_CTL | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_RD0__ENET1_RGMII_RD0 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_RD1__ENET1_RGMII_RD1 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_RD2__ENET1_RGMII_RD2 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_RD3__ENET1_RGMII_RD3 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_RXC__ENET1_RGMII_RXC | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TX_CTL__ENET1_RGMII_TX_CTL | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TD0__ENET1_RGMII_TD0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TD1__ENET1_RGMII_TD1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TD2__ENET1_RGMII_TD2 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TD3__ENET1_RGMII_TD3 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TXC__ENET1_RGMII_TXC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_GPIO1_IO10__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL_MII),
+	MX7D_PAD_GPIO1_IO11__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL_MII),
+	MX7D_PAD_ENET1_COL__GPIO7_IO15 | MUX_PAD_CTRL(ENET_PAD_CTRL), /*
+	MX7D_PAD_ENET1_RX_CLK__GPIO7_IO13 |MUX_PAD_CTRL(ENET_PAD_CTRL), */
+};
+
+static void setup_iomux_fec(void)
+{
+	imx_iomux_v3_setup_multiple_pads(fec1_pads, ARRAY_SIZE(fec1_pads));
+}
+#endif
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_FSL_QSPI
+static iomux_v3_cfg_t const quadspi_pads[] = {
+	MX7D_PAD_EPDC_DATA00__QSPI_A_DATA0 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA01__QSPI_A_DATA1 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA02__QSPI_A_DATA2 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA03__QSPI_A_DATA3 | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA05__QSPI_A_SCLK  | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA06__QSPI_A_SS0_B | MUX_PAD_CTRL(QSPI_PAD_CTRL),
+};
+
+int board_qspi_init(void)
+{
+	/* Set the iomux */
+	imx_iomux_v3_setup_multiple_pads(quadspi_pads, ARRAY_SIZE(quadspi_pads));
+
+	/* Set the clock */
+	set_clk_qspi();
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+
+#define USDHC1_CD_GPIO	IMX_GPIO_NR(5, 0)
+#define USDHC1_PWR_GPIO	IMX_GPIO_NR(5, 2)
+#define USDHC3_PWR_GPIO IMX_GPIO_NR(6, 11)
+
+static struct fsl_esdhc_cfg usdhc_cfg[3] = {
+	{USDHC1_BASE_ADDR, 0, 4},
+	{USDHC3_BASE_ADDR},
+};
+
+int mmc_get_env_devno(void)
+{
+	struct bootrom_sw_info **p =
+		(struct bootrom_sw_info **)ROM_SW_INFO_ADDR;
+
+	u8 boot_type = (*p)->boot_dev_type;
+	u8 dev_no = (*p)->boot_dev_instance;
+
+	/* If not boot from sd/mmc, use default value */
+	if ((boot_type != BOOT_TYPE_SD) && (boot_type != BOOT_TYPE_MMC))
+		return CONFIG_SYS_MMC_ENV_DEV;
+
+	if (2 == dev_no)
+		dev_no--;
+
+	return dev_no;
+}
+
+int mmc_map_to_kernel_blk(int dev_no)
+{
+	if (1 == dev_no)
+		dev_no++;
+
+	return dev_no;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC1_BASE_ADDR:
+		ret = !gpio_get_value(USDHC1_CD_GPIO);
+		break;
+	case USDHC3_BASE_ADDR:
+		ret = 1; /* Assume uSDHC3 emmc is always present */
+		break;
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int i, ret;
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC1
+	 * mmc2                    USDHC3 (eMMC)
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+#if defined(CONFIG_SPL_BUILD)
+                // The SPL framework expects there to be only one MMC device
+                // and we always loads u-boot from eMMC which is mapped to mmc1
+                if (i != 1) continue;
+#endif
+
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
+			gpio_request(USDHC1_CD_GPIO, "usdhc1_cd");
+			gpio_direction_input(USDHC1_CD_GPIO);
+			gpio_request(USDHC1_PWR_GPIO, "usdhc1_pwr");
+			gpio_direction_output(USDHC1_PWR_GPIO, 0);
+			udelay(500);
+			gpio_direction_output(USDHC1_PWR_GPIO, 1);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+			break;
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_emmc_pads, ARRAY_SIZE(usdhc3_emmc_pads));
+			gpio_request(USDHC3_PWR_GPIO, "usdhc3_pwr");
+			gpio_direction_output(USDHC3_PWR_GPIO, 0);
+			udelay(500);
+			gpio_direction_output(USDHC3_PWR_GPIO, 1);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) than supported by the board\n", i + 1);
+			return 0;
+			}
+
+			ret = fsl_esdhc_initialize(bis, &usdhc_cfg[i]);
+			if (ret)
+				return ret;
+	}
+
+	return 0;
+}
+
+int check_mmc_autodetect(void)
+{
+	char *autodetect_str = getenv("mmcautodetect");
+
+	if ((autodetect_str != NULL) &&
+		(strcmp(autodetect_str, "yes") == 0)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+void board_late_mmc_init(void)
+{
+	char cmd[32];
+	char mmcblk[32];
+	u32 dev_no = mmc_get_env_devno();
+
+	if (!check_mmc_autodetect())
+		return;
+
+	setenv_ulong("mmcdev", dev_no);
+
+	/* Set mmcblk env */
+	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
+		mmc_map_to_kernel_blk(dev_no));
+	setenv("mmcroot", mmcblk);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
+}
+
+#endif
+
+#ifdef CONFIG_FEC_MXC
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+	ea_eeprom_config_t config;
+
+	setup_iomux_fec();
+
+	ret = fecmxc_initialize_multi(bis, 0,
+		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+	if (ret)
+		printf("FEC1 MXC: %s:failed\n", __func__);
+
+        /* stored MAC addresses to env variables */
+        if (ea_eeprom_get_config(&config) == 0) {
+
+                if (is_valid_ether_addr(config.mac1) && !getenv("ethaddr")) {
+                        eth_setenv_enetaddr("ethaddr", config.mac1);
+                }
+
+                if (is_valid_ether_addr(config.mac2) && !getenv("eth1addr")) {
+                        eth_setenv_enetaddr("eth1addr", config.mac2);
+                }
+
+                if (is_valid_ether_addr(config.mac3) && !getenv("eth2addr")) {
+                        eth_setenv_enetaddr("eth2addr", config.mac3);
+                }
+
+                if (is_valid_ether_addr(config.mac4) && !getenv("eth3addr")) {
+                        eth_setenv_enetaddr("eth3addr", config.mac4);
+                }
+
+        }
+
+	return ret;
+}
+
+static int setup_fec(void)
+{
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *) IOMUXC_GPR_BASE_ADDR;
+	int ret;
+
+	/* Use 125M anatop REF_CLK1 for ENET1, clear gpr1[13], gpr1[17]*/
+	clrsetbits_le32(&iomuxc_gpr_regs->gpr[1],
+		(IOMUXC_GPR_GPR1_GPR_ENET1_TX_CLK_SEL_MASK |
+		 IOMUXC_GPR_GPR1_GPR_ENET1_CLK_DIR_MASK), 0);
+
+
+	/* enet pwr en */
+	gpio_direction_output(IMX_GPIO_NR(7, 15) , 0);
+
+	ret = set_clk_enet(ENET_125MHz);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+
+int board_phy_config(struct phy_device *phydev)
+{
+	/* enable rgmii rxc skew and phy mode select to RGMII copper */
+
+	/* Enable 1.8V(SEL_1P5_1P8_POS_REG) on
+	   Phy control debug reg 0 */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x1f);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x8);
+
+	/* rgmii tx clock delay enable */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x05);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x100);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+	return 0;
+}
+
+void board_get_hwaddr(int dev_id, unsigned char *mac)
+{
+        ea_eeprom_config_t config;
+
+        if (ea_eeprom_get_config(&config) == 0) {
+                if (dev_id == 0) {
+                        memcpy(mac, config.mac1, 6);
+                }
+                else {
+                        memcpy(mac, config.mac2, 6);
+                }
+        }
+
+}
+
+
+#endif
+
+#ifdef CONFIG_MXC_EPDC
+static iomux_v3_cfg_t const epdc_enable_pads[] = {
+	MX7D_PAD_EPDC_DATA00__EPDC_DATA0	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA01__EPDC_DATA1	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA02__EPDC_DATA2	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA03__EPDC_DATA3	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA04__EPDC_DATA4	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA05__EPDC_DATA5	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA06__EPDC_DATA6	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA07__EPDC_DATA7	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCLK__EPDC_SDCLK		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_SDLE__EPDC_SDLE		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_SDOE__EPDC_SDOE		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_SDSHR__EPDC_SDSHR		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE0__EPDC_SDCE0		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE1__EPDC_SDCE1		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_GDCLK__EPDC_GDCLK		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_GDOE__EPDC_GDOE		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_GDRL__EPDC_GDRL		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_GDSP__EPDC_GDSP		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_BDR0__EPDC_BDR0		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX7D_PAD_EPDC_BDR1__EPDC_BDR1		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const epdc_disable_pads[] = {
+	MX7D_PAD_EPDC_DATA00__GPIO2_IO0,
+	MX7D_PAD_EPDC_DATA01__GPIO2_IO1,
+	MX7D_PAD_EPDC_DATA02__GPIO2_IO2,
+	MX7D_PAD_EPDC_DATA03__GPIO2_IO3,
+	MX7D_PAD_EPDC_DATA04__GPIO2_IO4,
+	MX7D_PAD_EPDC_DATA05__GPIO2_IO5,
+	MX7D_PAD_EPDC_DATA06__GPIO2_IO6,
+	MX7D_PAD_EPDC_DATA07__GPIO2_IO7,
+	MX7D_PAD_EPDC_SDCLK__GPIO2_IO16,
+	MX7D_PAD_EPDC_SDLE__GPIO2_IO17,
+	MX7D_PAD_EPDC_SDOE__GPIO2_IO18,
+	MX7D_PAD_EPDC_SDSHR__GPIO2_IO19,
+	MX7D_PAD_EPDC_SDCE0__GPIO2_IO20,
+	MX7D_PAD_EPDC_SDCE1__GPIO2_IO21,
+	MX7D_PAD_EPDC_GDCLK__GPIO2_IO24,
+	MX7D_PAD_EPDC_GDOE__GPIO2_IO25,
+	MX7D_PAD_EPDC_GDRL__GPIO2_IO26,
+	MX7D_PAD_EPDC_GDSP__GPIO2_IO27,
+	MX7D_PAD_EPDC_BDR0__GPIO2_IO28,
+	MX7D_PAD_EPDC_BDR1__GPIO2_IO29,
+};
+
+vidinfo_t panel_info = {
+	.vl_refresh = 85,
+	.vl_col = 1024,
+	.vl_row = 758,
+	.vl_pixclock = 40000000,
+	.vl_left_margin = 12,
+	.vl_right_margin = 76,
+	.vl_upper_margin = 4,
+	.vl_lower_margin = 5,
+	.vl_hsync = 12,
+	.vl_vsync = 2,
+	.vl_sync = 0,
+	.vl_mode = 0,
+	.vl_flag = 0,
+	.vl_bpix = 3,
+	.cmap = 0,
+};
+
+struct epdc_timing_params panel_timings = {
+	.vscan_holdoff = 4,
+	.sdoed_width = 10,
+	.sdoed_delay = 20,
+	.sdoez_width = 10,
+	.sdoez_delay = 20,
+	.gdclk_hp_offs = 524,
+	.gdsp_offs = 327,
+	.gdoe_offs = 0,
+	.gdclk_offs = 19,
+	.num_ce = 1,
+};
+
+static void setup_epdc_power(void)
+{
+	/* IOMUX_GPR1: bit30: Disable On-chip RAM EPDC Function */
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *) IOMUXC_GPR_BASE_ADDR;
+
+	clrsetbits_le32(&iomuxc_gpr_regs->gpr[1],
+		IOMUXC_GPR_GPR1_GPR_ENABLE_OCRAM_EPDC_MASK, 0);
+
+	/* Setup epdc voltage */
+
+	/* EPDC_PWRSTAT - GPIO2[31] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX7D_PAD_EPDC_PWR_STAT__GPIO2_IO31 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	gpio_direction_input(IMX_GPIO_NR(2, 31));
+
+	/* EPDC_VCOM0 - GPIO4[14] for VCOM control */
+	imx_iomux_v3_setup_pad(MX7D_PAD_I2C4_SCL__GPIO4_IO14 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(4, 14), 1);
+
+	/* EPDC_PWRWAKEUP - GPIO2[23] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX7D_PAD_EPDC_SDCE3__GPIO2_IO23 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(2, 23), 1);
+
+	/* EPDC_PWRCTRL0 - GPIO2[30] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX7D_PAD_EPDC_PWR_COM__GPIO2_IO30 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(2, 30), 1);
+}
+
+static void epdc_enable_pins(void)
+{
+	/* epdc iomux settings */
+	imx_iomux_v3_setup_multiple_pads(epdc_enable_pads,
+				ARRAY_SIZE(epdc_enable_pads));
+}
+
+static void epdc_disable_pins(void)
+{
+	/* Configure MUX settings for EPDC pins to GPIO  and drive to 0 */
+	imx_iomux_v3_setup_multiple_pads(epdc_disable_pads,
+				ARRAY_SIZE(epdc_disable_pads));
+}
+
+static void setup_epdc(void)
+{
+	/*** epdc Maxim PMIC settings ***/
+
+	/* EPDC_PWRSTAT - GPIO2[31] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX7D_PAD_EPDC_PWR_STAT__GPIO2_IO31 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC_VCOM0 - GPIO4[14] for VCOM control */
+	imx_iomux_v3_setup_pad(MX7D_PAD_I2C4_SCL__GPIO4_IO14 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC_PWRWAKEUP - GPIO4[23] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX7D_PAD_EPDC_SDCE3__GPIO2_IO23 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC_PWRCTRL0 - GPIO4[20] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX7D_PAD_EPDC_PWR_COM__GPIO2_IO30 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* Set pixel clock rates for EPDC in clock.c */
+
+	panel_info.epdc_data.wv_modes.mode_init = 0;
+	panel_info.epdc_data.wv_modes.mode_du = 1;
+	panel_info.epdc_data.wv_modes.mode_gc4 = 3;
+	panel_info.epdc_data.wv_modes.mode_gc8 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc16 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc32 = 2;
+
+	panel_info.epdc_data.epdc_timings = panel_timings;
+
+	setup_epdc_power();
+}
+
+void epdc_power_on(void)
+{
+	unsigned int reg;
+	struct gpio_regs *gpio_regs = (struct gpio_regs *)GPIO2_BASE_ADDR;
+
+	/* Set EPD_PWR_CTL0 to high - enable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(2, 30), 1);
+	udelay(1000);
+
+	/* Enable epdc signal pin */
+	epdc_enable_pins();
+
+	/* Set PMIC Wakeup to high - enable Display power */
+	gpio_set_value(IMX_GPIO_NR(2, 23), 1);
+
+	/* Wait for PWRGOOD == 1 */
+	while (1) {
+		reg = readl(&gpio_regs->gpio_psr);
+		if (!(reg & (1 << 31)))
+			break;
+
+		udelay(100);
+	}
+
+	/* Enable VCOM */
+	gpio_set_value(IMX_GPIO_NR(4, 14), 1);
+
+	udelay(500);
+}
+
+void epdc_power_off(void)
+{
+	/* Set PMIC Wakeup to low - disable Display power */
+	gpio_set_value(IMX_GPIO_NR(2, 23), 0);
+
+	/* Disable VCOM */
+	gpio_set_value(IMX_GPIO_NR(4, 14), 0);
+
+	epdc_disable_pins();
+
+	/* Set EPD_PWR_CTL0 to low - disable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(2, 30), 0);
+}
+#endif
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	setup_i2c(2, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info3);
+#endif
+
+	ea_eeprom_init();
+
+	return 0;
+}
+
+int board_init(void)
+{
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+	imx_iomux_v3_setup_multiple_pads(iox_pads, ARRAY_SIZE(iox_pads));
+
+	iox74lv_init();
+
+#ifdef CONFIG_FEC_MXC
+	setup_fec();
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+	setup_gpmi_nand();
+#endif
+
+#ifdef CONFIG_FSL_QSPI
+	board_qspi_init();
+#endif
+
+#ifdef	CONFIG_MXC_EPDC
+	qn_output[5] = qn_disable;
+	iox74lv_set(5);
+	setup_epdc();
+#endif
+
+#ifdef CONFIG_CMD_EADISP
+	eadisp_setup_display(displays, ARRAY_SIZE(displays));
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd1", MAKE_CFGVAL(0x10, 0x10, 0x00, 0x00)},
+	{"emmc", MAKE_CFGVAL(0x10, 0x2a, 0x00, 0x00)},
+	/* TODO: Nand */
+	{"qspi", MAKE_CFGVAL(0x00, 0x40, 0x00, 0x00)},
+	{NULL,   0},
+};
+#endif
+
+#ifdef CONFIG_POWER
+#define I2C_PMIC	0
+#define POWER_PMIC_BD71815_I2C_ADDR (0x4B)
+#define BD71815_REG_LDO_MODE1 (0x10)
+#define BD71815_REG_LDO3_VOLT (0x16)
+int power_init_board(void)
+{
+        uint8_t value;
+
+        /*
+         * Fix for LDO3 when DCIN is not supplied.
+         */
+
+        i2c_set_bus_num(I2C_PMIC);
+
+        if (i2c_probe(POWER_PMIC_BD71815_I2C_ADDR)) {
+                printf("failed to probe PMIC (%x)\n", POWER_PMIC_BD71815_I2C_ADDR);
+                return -1;
+        }
+
+        if (i2c_read(POWER_PMIC_BD71815_I2C_ADDR, BD71815_REG_LDO_MODE1, 1, &value, 1)) {
+                printf("power_init_board: failed to read register 0x10\n");
+                return -1;
+        }
+
+        /* Bit 2: LDO3_REG_MODE_0. When set to 1 LDO3 is controlled via register */
+        value |= (1<<2);
+        if (i2c_write(POWER_PMIC_BD71815_I2C_ADDR, BD71815_REG_LDO_MODE1, 1, &value, 1)) {
+                printf("power_init_board: failed to write to reg 0x10\n");
+        }
+
+        /* 3.15V */
+        value = 0x2f;
+        if (i2c_write(POWER_PMIC_BD71815_I2C_ADDR, BD71815_REG_LDO3_VOLT, 1, &value, 1)) {
+                printf("power_init_board: failed to write to reg 0x16\n");
+        }
+
+
+
+        return 0;
+}
+#endif
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_init();
+#endif
+
+#ifdef CONFIG_CMD_EADISP
+	eatouch_init();
+#endif
+
+	imx_iomux_v3_setup_multiple_pads(wdog_pads, ARRAY_SIZE(wdog_pads));
+
+	set_wdog_reset((struct wdog_regs *)WDOG1_BASE_ADDR);
+
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+	ea_eeprom_config_t config;
+
+	puts("Board: Embedded Artists ");
+        if (ea_eeprom_get_config(&config) == 0) {
+
+                printf("%s\n", config.name);
+                printf("       %05d, %s, WO%d\n",
+                        config.board_part_nr,
+                        config.board_rev,
+                        config.batch);
+
+        }
+        else {
+                puts(" [Unknown board due to invalid configuration data]\n");
+        }
+
+	return 0;
+}
+
+#ifdef CONFIG_USB_EHCI_MX7
+iomux_v3_cfg_t const usb_otg1_pads[] = {
+	MX7D_PAD_GPIO1_IO05__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+iomux_v3_cfg_t const usb_otg2_pads[] = {
+	MX7D_PAD_UART3_CTS_B__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+int board_ehci_hcd_init(int port)
+{
+	switch (port) {
+	case 0:
+		imx_iomux_v3_setup_multiple_pads(usb_otg1_pads,
+						 ARRAY_SIZE(usb_otg1_pads));
+		break;
+	case 1:
+		imx_iomux_v3_setup_multiple_pads(usb_otg2_pads,
+						 ARRAY_SIZE(usb_otg2_pads));
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_FASTBOOT
+
+void board_fastboot_setup(void)
+{
+	switch (get_boot_device()) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc0");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc0");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc1");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc1");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("unsupported boot devices\n");
+		break;
+	}
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+
+/* Use S3 button for recovery key */
+#define GPIO_VOL_DN_KEY IMX_GPIO_NR(5, 10)
+iomux_v3_cfg_t const recovery_key_pads[] = {
+	(MX7D_PAD_SD2_WP__GPIO5_IO10 | MUX_PAD_CTRL(BUTTON_PAD_CTRL)),
+};
+
+int check_recovery_cmd_file(void)
+{
+	int button_pressed = 0;
+	int recovery_mode = 0;
+
+	recovery_mode = recovery_check_and_clean_flag();
+
+	/* Check Recovery Combo Button press or not. */
+	imx_iomux_v3_setup_multiple_pads(recovery_key_pads,
+		ARRAY_SIZE(recovery_key_pads));
+
+	gpio_direction_input(GPIO_VOL_DN_KEY);
+
+	if (gpio_get_value(GPIO_VOL_DN_KEY) == 0) { /* VOL_DN key is low assert */
+		button_pressed = 1;
+		printf("Recovery key pressed\n");
+	}
+
+	return recovery_mode || button_pressed;
+}
+
+void board_recovery_setup(void)
+{
+	int bootdev = get_boot_device();
+
+	switch (bootdev) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc0 recovery");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc1 recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("Unsupported bootup device for recovery: dev: %d\n",
+			bootdev);
+		return;
+	}
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FSL_FASTBOOT*/
diff --git a/board/embeddedartists/mx7dea-ucom/plugin.S b/board/embeddedartists/mx7dea-ucom/plugin.S
new file mode 100644
index 0000000..77e098b
--- /dev/null
+++ b/board/embeddedartists/mx7dea-ucom/plugin.S
@@ -0,0 +1,156 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx7d_sabresd_ddr_setting
+	/* Configure ocram_epdc */
+	ldr r0, =IOMUXC_GPR_BASE_ADDR
+	ldr r1, =0x4f400005
+	str r1, [r0, #0x4]
+
+	ldr r0, =SRC_BASE_ADDR
+	ldr r1, =0x2
+	ldr r2, =0x1000
+	str r1, [r0, r2]
+
+	ldr r0, =DDRC_IPS_BASE_ADDR
+	ldr r1, =0x01040001
+	str r1, [r0]
+	ldr r1, =0x80400003
+	str r1, [r0, #0x1a0]
+	ldr r1, =0x00100020
+	str r1, [r0, #0x1a4]
+	ldr r1, =0x80100004
+	str r1, [r0, #0x1a8]
+	ldr r1, =0x00400046
+	str r1, [r0, #0x64]
+	ldr r1, =0x1
+	str r1, [r0, #0x490]
+	ldr r1, =0x00020001
+	str r1, [r0, #0xd0]
+	ldr r1, =0x00690000
+	str r1, [r0, #0xd4]
+	ldr r1, =0x09300004
+	str r1, [r0, #0xdc]
+	ldr r1, =0x04080000
+	str r1, [r0, #0xe0]
+	ldr r1, =0x00100004
+	str r1, [r0, #0xe4]
+	ldr r1, =0x33f
+	str r1, [r0, #0xf4]
+	ldr r1, =0x09081109
+	str r1, [r0, #0x100]
+	ldr r1, =0x0007020d
+	str r1, [r0, #0x104]
+	ldr r1, =0x03040407
+	str r1, [r0, #0x108]
+	ldr r1, =0x00002006
+	str r1, [r0, #0x10c]
+	ldr r1, =0x04020205
+	str r1, [r0, #0x110]
+	ldr r1, =0x03030202
+	str r1, [r0, #0x114]
+	ldr r1, =0x00000803
+	str r1, [r0, #0x120]
+	ldr r1, =0x00800020
+	str r1, [r0, #0x180]
+	ldr r1, =0x02000100
+	str r1, [r0, #0x184]
+	ldr r1, =0x02098204
+	str r1, [r0, #0x190]
+	ldr r1, =0x00030303
+	str r1, [r0, #0x194]
+
+	ldr r1, =0x00000016
+	str r1, [r0, #0x200]
+	ldr r1, =0x00171717
+	str r1, [r0, #0x204]
+	ldr r1, =0x04040404
+	str r1, [r0, #0x214]
+	ldr r1, =0x0f040404
+	str r1, [r0, #0x218]
+
+	ldr r1, =0x06000604
+	str r1, [r0, #0x240]
+	ldr r1, =0x00000001
+	str r1, [r0, #0x244]
+
+	ldr r0, =SRC_BASE_ADDR
+	mov r1, #0x0
+	ldr r2, =0x1000
+	str r1, [r0, r2]
+
+	ldr r0, =DDRPHY_IPS_BASE_ADDR
+	ldr r1, =0x17420f40
+	str r1, [r0]
+	ldr r1, =0x10210100
+	str r1, [r0, #0x4]
+	ldr r1, =0x00060807
+	str r1, [r0, #0x10]
+	ldr r1, =0x1010007e
+	str r1, [r0, #0xb0]
+	ldr r1, =0x00000d6e
+	str r1, [r0, #0x9c]
+	ldr r1, =0x08080808
+	str r1, [r0, #0x20]
+	ldr r1, =0x08080808
+	str r1, [r0, #0x30]
+	ldr r1, =0x01000010
+	str r1, [r0, #0x50]
+
+	ldr r1, =0x0e407304
+	str r1, [r0, #0xc0]
+	ldr r1, =0x0e447304
+	str r1, [r0, #0xc0]
+	ldr r1, =0x0e447306
+	str r1, [r0, #0xc0]
+
+wait_zq:
+	ldr r1, [r0, #0xc4]
+	tst r1, #0x1
+	beq wait_zq
+
+	ldr r1, =0x0e447304
+	str r1, [r0, #0xc0]
+	ldr r1, =0x0e407304
+	str r1, [r0, #0xc0]
+
+	ldr r0, =CCM_BASE_ADDR
+	mov r1, #0x0
+	ldr r2, =0x4130
+	str r1, [r0, r2]
+	ldr r0, =IOMUXC_GPR_BASE_ADDR
+	mov r1, #0x178
+	str r1, [r0, #0x20]
+	ldr r0, =CCM_BASE_ADDR
+	mov r1, #0x2
+	ldr r2, =0x4130
+	str r1, [r0, r2]
+	ldr r0, =DDRPHY_IPS_BASE_ADDR
+	ldr r1, =0x0000000f
+	str r1, [r0, #0x18]
+
+	ldr r0, =DDRC_IPS_BASE_ADDR
+wait_stat:
+	ldr r1, [r0, #0x4]
+	tst r1, #0x1
+	beq wait_stat
+.endm
+
+.macro imx7_clock_gating
+.endm
+
+.macro imx7_qos_setting
+.endm
+
+.macro imx7_ddr_setting
+	imx7d_sabresd_ddr_setting
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx7_plugin.S>
diff --git a/common/spl/spl.c b/common/spl/spl.c
index 8e1fb40..ae8a192 100644
--- a/common/spl/spl.c
+++ b/common/spl/spl.c
@@ -127,6 +127,16 @@ __weak void __noreturn jump_to_image_no_args(struct spl_image_info *spl_image)
 	image_entry_noargs_t image_entry =
 			(image_entry_noargs_t) spl_image->entry_point;
 
+#ifdef CONFIG_SECURE_BOOT
+	extern uint32_t authenticate_image(
+			uint32_t ddr_start, uint32_t image_size);
+
+	if (authenticate_image(spl_image->load_addr, spl_image->size) == 0) {
+		debug("SPL failed to Authenticate image, Please check\n");
+		hang();
+	}
+#endif
+
 	debug("image entry point: 0x%X\n", spl_image->entry_point);
 	image_entry();
 }
diff --git a/common/spl/spl_mmc.c b/common/spl/spl_mmc.c
index e580f22..e4353fb 100644
--- a/common/spl/spl_mmc.c
+++ b/common/spl/spl_mmc.c
@@ -33,9 +33,26 @@ static int mmc_load_image_raw_sector(struct mmc *mmc, unsigned long sector)
 
 	spl_parse_image_header(header);
 
+#ifdef CONFIG_SECURE_BOOT
+	/* 
+	 * A signed image will have IVT + CSF at end of image
+	 * We must read enough of the image into SDRAM to be able
+	 * to verify signature. 
+	 * - IVT must be added to a 4K boundary
+	 * - IVT header is 32 bytes (0x20)
+	 * - Read enough to get CSF. Reading 8K although CSF is smaller
+	 */
+
+	/* align size to 4K */
+	image_size_sectors = (spl_image.size + 0x1000 - 1) & ~(0x1000 - 1);
+	/* add ivt size (0x20) + CSF pad size (8K) */
+	image_size_sectors = (image_size_sectors + 0x20 + 0x2000 + mmc->read_bl_len - 1) /
+				mmc->read_bl_len;
+#else
 	/* convert size to sectors - round up */
 	image_size_sectors = (spl_image.size + mmc->read_bl_len - 1) /
 				mmc->read_bl_len;
+#endif
 
 	/* Read the header too to avoid extra memcpy */
 	err = mmc->block_dev.block_read(0, sector, image_size_sectors,
diff --git a/configs/mx6dlea-com_defconfig b/configs/mx6dlea-com_defconfig
new file mode 100644
index 0000000..35103c6
--- /dev/null
+++ b/configs/mx6dlea-com_defconfig
@@ -0,0 +1,6 @@
+CONFIG_SPL=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/embeddedartists/mx6qea-com/imximage_mx6dl.cfg,MX6DL"
+CONFIG_ARM=y
+CONFIG_TARGET_MX6QEA_COM=y
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/configs/mx6qea-com-android_defconfig b/configs/mx6qea-com-android_defconfig
new file mode 100644
index 0000000..af37dff
--- /dev/null
+++ b/configs/mx6qea-com-android_defconfig
@@ -0,0 +1,8 @@
+#CONFIG_SPL=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/embeddedartists/mx6qea-com/imximage.cfg,MX6Q,ANDROID_SUPPORT"
+CONFIG_ARM=y
+CONFIG_TARGET_MX6QEA_COM=y
+CONFIG_SYS_MALLOC_F=y
+CONFIG_SYS_MALLOC_F_LEN=0x400
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/configs/mx6qea-com_defconfig b/configs/mx6qea-com_defconfig
new file mode 100644
index 0000000..37c5238
--- /dev/null
+++ b/configs/mx6qea-com_defconfig
@@ -0,0 +1,6 @@
+CONFIG_SPL=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/embeddedartists/mx6qea-com/imximage.cfg,MX6Q"
+CONFIG_ARM=y
+CONFIG_TARGET_MX6QEA_COM=y
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/configs/mx6sxea-com-android_defconfig b/configs/mx6sxea-com-android_defconfig
new file mode 100644
index 0000000..a210354
--- /dev/null
+++ b/configs/mx6sxea-com-android_defconfig
@@ -0,0 +1,8 @@
+#CONFIG_SPL=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/embeddedartists/mx6sxea-com/imximage.cfg,MX6SX,ANDROID_SUPPORT"
+CONFIG_ARM=y
+CONFIG_TARGET_MX6SXEA_COM=y
+CONFIG_SYS_MALLOC_F=y
+CONFIG_SYS_MALLOC_F_LEN=0x400
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/configs/mx6sxea-com_defconfig b/configs/mx6sxea-com_defconfig
new file mode 100644
index 0000000..e1e803c
--- /dev/null
+++ b/configs/mx6sxea-com_defconfig
@@ -0,0 +1,6 @@
+CONFIG_SPL=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/embeddedartists/mx6sxea-com/imximage.cfg,MX6SX"
+CONFIG_ARM=y
+CONFIG_TARGET_MX6SXEA_COM=y
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/configs/mx6ulea-com_defconfig b/configs/mx6ulea-com_defconfig
new file mode 100644
index 0000000..445fcf9
--- /dev/null
+++ b/configs/mx6ulea-com_defconfig
@@ -0,0 +1,6 @@
+CONFIG_SPL=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/embeddedartists/mx6ulea-com/imximage.cfg,MX6UL"
+CONFIG_ARM=y
+CONFIG_TARGET_MX6ULEA_COM=y
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/configs/mx7dea-com_defconfig b/configs/mx7dea-com_defconfig
new file mode 100644
index 0000000..061a0a8
--- /dev/null
+++ b/configs/mx7dea-com_defconfig
@@ -0,0 +1,7 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/embeddedartists/mx7dea-com/imximage.cfg,MX7D"
+CONFIG_ARM=y
+CONFIG_TARGET_MX7DEA_COM=y
+CONFIG_SYS_MALLOC_F=y
+CONFIG_SYS_MALLOC_F_LEN=0x400
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/configs/mx7dea-ucom-android_defconfig b/configs/mx7dea-ucom-android_defconfig
new file mode 100644
index 0000000..081423d
--- /dev/null
+++ b/configs/mx7dea-ucom-android_defconfig
@@ -0,0 +1,8 @@
+#CONFIG_SPL=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/embeddedartists/mx7dea-ucom/imximage.cfg,MX7D,ANDROID_SUPPORT"
+CONFIG_ARM=y
+CONFIG_TARGET_MX7DEA_UCOM=y
+CONFIG_SYS_MALLOC_F=y
+CONFIG_SYS_MALLOC_F_LEN=0x400
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/configs/mx7dea-ucom_defconfig b/configs/mx7dea-ucom_defconfig
new file mode 100644
index 0000000..437eaef
--- /dev/null
+++ b/configs/mx7dea-ucom_defconfig
@@ -0,0 +1,7 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/embeddedartists/mx7dea-ucom/imximage.cfg,MX7D"
+CONFIG_ARM=y
+CONFIG_TARGET_MX7DEA_UCOM=y
+CONFIG_SYS_MALLOC_F=y
+CONFIG_SYS_MALLOC_F_LEN=0x400
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/include/configs/mx6qea-com.h b/include/configs/mx6qea-com.h
new file mode 100644
index 0000000..8d7cd84
--- /dev/null
+++ b/include/configs/mx6qea-com.h
@@ -0,0 +1,510 @@
+/*
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Embedded Artists i.MX6 Quad COM Board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX6QEA_COM_H
+#define __MX6QEA_COM_H
+
+#include <asm/arch/imx-regs.h>
+#include <asm/imx-common/gpio.h>
+
+
+#define CONFIG_SPL_TEXT_BASE	0x00908000
+#define CONFIG_SPL_FRAMEWORK
+
+
+#if defined(CONFIG_SPL_BUILD)
+
+
+#define CONFIG_SPL_I2C_SUPPORT
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_GPIO_SUPPORT
+#define CONFIG_SPL_SERIAL_SUPPORT
+
+#define CONFIG_SPL_MMC_SUPPORT
+#define CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR 138
+
+#define CONFIG_SPL_BOARD_INIT
+
+#define CONFIG_SYS_SPL_MALLOC_START	0x912800
+#define CONFIG_SYS_SPL_MALLOC_SIZE	0x4800
+
+
+#endif
+
+
+#define CONFIG_MACH_TYPE	3980
+#define CONFIG_MXC_UART_BASE	UART1_BASE
+#define CONFIG_CONSOLE_DEV		"ttymxc0"
+#define CONFIG_MMCROOT			"/dev/mmcblk2p2"  /* SDHC3 */
+
+
+#define CONFIG_MX6
+
+#ifdef CONFIG_MX6SOLO
+#define CONFIG_MX6DL
+#endif
+
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+#include "mx6_common.h"
+#include <linux/sizes.h>
+
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+#include <asm/arch/imx-regs.h>
+#include <asm/imx-common/gpio.h>
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_REVISION_TAG
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(10 * SZ_1M)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
+#define CONFIG_MXC_GPIO
+
+#define CONFIG_MXC_UART
+
+#define CONFIG_CMD_FUSE
+#ifdef CONFIG_CMD_FUSE
+#define CONFIG_MXC_OCOTP
+#endif
+
+/* MMC Configs */
+#define CONFIG_FSL_ESDHC
+#define CONFIG_FSL_USDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR      0
+
+#define CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_BOUNCE_BUFFER
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+
+#define CONFIG_SUPPORT_EMMC_BOOT /* eMMC specific */
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_NET
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_XCV_TYPE		RGMII
+#define CONFIG_ETHPRIME			"FEC"
+#define CONFIG_FEC_MXC_PHYADDR		1
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_ATHEROS
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_CONS_INDEX              1
+#define CONFIG_BAUDRATE                        115200
+
+/* Command definition */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_BMODE
+#define CONFIG_CMD_BOOTZ
+#define CONFIG_CMD_SETEXPR
+#undef CONFIG_CMD_IMLS
+
+#define CONFIG_BOOTDELAY               1
+
+#define CONFIG_LOADADDR                        0x12000000
+#define CONFIG_SYS_TEXT_BASE           0x17800000
+#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=" CONFIG_CONSOLE_DEV ",115200 " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		"enable_wait_mode=off "\
+		"\0" \
+		"initrd_addr=0x12C00000\0" \
+		"initrd_high=0xffffffff\0" \
+		"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+#if defined(CONFIG_SYS_BOOT_SATA)
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		CONFIG_MFG_ENV_SETTINGS \
+		"fdt_addr=0x18000000\0" \
+		"fdt_high=0xffffffff\0"   \
+		"bootargs=console=" CONFIG_CONSOLE_DEV ",115200 \0"\
+		"bootargs_sata=setenv bootargs ${bootargs} " \
+			"root=/dev/sda1 rootwait rw \0" \
+		"bootcmd_sata=run bootargs_sata; sata init; " \
+			"sata read ${loadaddr} 0x800  0x4000; " \
+			"sata read ${fdt_addr} 0x8000 0x800; " \
+			"bootz ${loadaddr} - ${fdt_addr} \0" \
+		"bootcmd=run bootcmd_sata \0"
+
+#else
+
+
+#ifdef CONFIG_MX6DL
+#define CONFIG_FDT_FILE "imx6dlea-com-kit.dtb"
+#else
+#define CONFIG_FDT_FILE "imx6qea-com-kit.dtb"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	"script=boot.scr\0" \
+	"image=zImage\0" \
+	"fdt_file=" CONFIG_FDT_FILE "\0" \
+	"fdt_addr=0x18000000\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=yes\0" \
+	"console=" CONFIG_CONSOLE_DEV "\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"initrd_high=0xffffffff\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
+	"update_sd_firmware=" \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"if mmc dev ${mmcdev}; then "	\
+			"if ${get_cmd} ${update_sd_firmware_filename}; then " \
+				"setexpr fw_sz ${filesize} / 0x200; " \
+				"setexpr fw_sz ${fw_sz} + 1; "	\
+				"mmc write ${loadaddr} 0x2 ${fw_sz}; " \
+			"fi; "	\
+		"fi\0" \
+	"smp=" CONFIG_SYS_NOSMP "\0"\
+	"mmcargs=setenv bootargs console=${console},${baudrate} ${smp} " \
+		"root=${mmcroot} ${args_from_script}\0" \
+	"loadbootscript=" \
+		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} ${smp} " \
+		"root=/dev/nfs " \
+		"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp ${args_from_script}\0" \
+	"netboot=echo Booting from net ...; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${image}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0"
+
+#define CONFIG_BOOTCOMMAND \
+	"mmc dev ${mmcdev};" \
+	"if mmc rescan; then " \
+		"if run loadbootscript; then " \
+		"run bootscript; " \
+		"else " \
+			"if run loadimage; then " \
+				"run mmcboot; " \
+			"else run netboot; " \
+			"fi; " \
+		"fi; " \
+	"else run netboot; fi"
+#endif
+
+#define CONFIG_ARP_TIMEOUT     200UL
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2     "> "
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_CBSIZE              1024
+
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS             256
+#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
+
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_MEMTEST_START       0x10000000
+#define CONFIG_SYS_MEMTEST_END         0x10010000
+#define CONFIG_SYS_MEMTEST_SCRATCH     0x10800000
+
+#define CONFIG_SYS_LOAD_ADDR           CONFIG_LOADADDR
+
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_STACKSIZE               (128 * 1024)
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS           1
+#define PHYS_SDRAM                     MMDC0_ARB_BASE_ADDR
+
+#ifdef CONFIG_MX6DL
+#define PHYS_SDRAM_SIZE			SZ_1G
+#else
+#define PHYS_SDRAM_SIZE			SZ_2G
+#endif
+
+#define CONFIG_SYS_SDRAM_BASE          PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR       IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE       IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* FLASH and environment organization */
+#define CONFIG_SYS_NO_FLASH
+
+#define CONFIG_ENV_SIZE			(8 * 1024)
+
+#ifndef CONFIG_SYS_NOSMP
+#define CONFIG_SYS_NOSMP
+#endif
+
+#if defined CONFIG_SYS_BOOT_SPINOR
+#define CONFIG_SYS_USE_SPINOR
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_EIMNOR
+#define CONFIG_SYS_USE_EIMNOR
+#define CONFIG_ENV_IS_IN_FLASH
+#elif defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_SYS_USE_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#elif defined CONFIG_SYS_BOOT_SATA
+#define CONFIG_ENV_IS_IN_SATA
+#define CONFIG_CMD_SATA
+#else
+#define CONFIG_ENV_IS_IN_MMC
+#endif
+
+#ifdef CONFIG_CMD_SATA
+#define CONFIG_DWC_AHSATA
+#define CONFIG_SYS_SATA_MAX_DEVICE	1
+#define CONFIG_DWC_AHSATA_PORT_ID	0
+#define CONFIG_DWC_AHSATA_BASE_ADDR	SATA_ARB_BASE_ADDR
+#define CONFIG_LBA48
+#define CONFIG_LIBATA
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_MXC_SPI
+#define CONFIG_SF_DEFAULT_BUS  0
+#define CONFIG_SF_DEFAULT_SPEED 20000000
+#define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+#undef CONFIG_SYS_NO_FLASH
+#define CONFIG_SYS_FLASH_BASE           WEIM_ARB_BASE_ADDR
+#define CONFIG_SYS_FLASH_SECT_SIZE     (128 * 1024)
+#define CONFIG_SYS_MAX_FLASH_BANKS 1    /* max number of memory banks */
+#define CONFIG_SYS_MAX_FLASH_SECT 256   /* max number of sectors on one chip */
+#define CONFIG_SYS_FLASH_CFI            /* Flash memory is CFI compliant */
+#define CONFIG_FLASH_CFI_DRIVER         /* Use drivers/cfi_flash.c */
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE /* Use buffered writes*/
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#endif
+
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(8 * 64 * 1024)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET              (768 * 1024)
+#define CONFIG_ENV_SECT_SIZE           (64 * 1024)
+#define CONFIG_ENV_SPI_BUS             CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS              CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE            CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ          CONFIG_SF_DEFAULT_SPEED
+#elif defined(CONFIG_ENV_IS_IN_FLASH)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_SIZE                        CONFIG_SYS_FLASH_SECT_SIZE
+#define CONFIG_ENV_SECT_SIZE           CONFIG_SYS_FLASH_SECT_SIZE
+#define CONFIG_ENV_OFFSET              (4 * CONFIG_SYS_FLASH_SECT_SIZE)
+#elif defined(CONFIG_ENV_IS_IN_NAND)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_OFFSET              (8 << 20)
+#define CONFIG_ENV_SECT_SIZE           (128 << 10)
+#define CONFIG_ENV_SIZE                        CONFIG_ENV_SECT_SIZE
+#elif defined(CONFIG_ENV_IS_IN_SATA)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_SATA_ENV_DEV		0
+#define CONFIG_SYS_DCACHE_OFF /* remove when sata driver support cache */
+#endif
+
+#define CONFIG_OF_LIBFDT
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+#define CONFIG_CMD_CACHE
+#endif
+
+/*
+ * I2C configs
+ */
+#define CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_SPEED		100000
+
+/* EEPROM */
+#define CONFIG_CMD_EEPROM
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 2
+#define CONFIG_ENV_EEPROM_IS_ON_I2C
+#define CONFIG_SYS_I2C_MULTI_EEPROMS
+/* the page boundary is 32 bytes (2^5 = 32) */
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS 5
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS 10
+
+/* Framebuffer */
+#define CONFIG_VIDEO
+#define CONFIG_CMD_EADISP
+#define CONFIG_VIDEO_IPUV3
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_BMP_16BPP
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_VIDEO_BMP_LOGO
+#ifdef CONFIG_MX6DL
+#define CONFIG_IPUV3_CLK 198000000
+#else
+#define CONFIG_IPUV3_CLK 264000000
+#endif
+#define CONFIG_IMX_HDMI
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "mx6sabreandroid_common.h"
+#endif
+
+
+
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2 /* Enabled USB controller number */
+
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#define CONFIG_SYS_MMC_ENV_DEV		2	/* SDHC4 */
+#define CONFIG_SYS_MMC_ENV_PART                0       /* user partition */
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_SF_DEFAULT_CS   (0|(IMX_GPIO_NR(4, 9)<<8))
+#endif
+
+/*
+ * imx6 q/dl/solo pcie would be failed to work properly in kernel, if
+ * the pcie module is iniialized/enumerated both in uboot and linux
+ * kernel.
+ * rootcause:imx6 q/dl/solo pcie don't have the reset mechanism.
+ * it is only be RESET by the POR. So, the pcie module only be
+ * initialized/enumerated once in one POR.
+ * Set to use pcie in kernel defaultly, mask the pcie config here.
+ * Remove the mask freely, if the uboot pcie functions, rather than
+ * the kernel's, are required.
+ */
+/* #define CONFIG_CMD_PCI */
+#ifdef CONFIG_CMD_PCI
+#define CONFIG_PCI
+#define CONFIG_PCI_PNP
+#define CONFIG_PCI_SCAN_SHOW
+#define CONFIG_PCIE_IMX
+#define CONFIG_PCIE_IMX_PERST_GPIO	IMX_GPIO_NR(7, 12)
+#define CONFIG_PCIE_IMX_POWER_GPIO	IMX_GPIO_NR(3, 19)
+#endif
+
+/*#define CONFIG_SPLASH_SCREEN*/
+/*#define CONFIG_MXC_EPDC*/
+
+/*
+ * SPLASH SCREEN Configs
+ */
+#if defined(CONFIG_SPLASH_SCREEN) && defined(CONFIG_MXC_EPDC)
+	/*
+	 * Framebuffer and LCD
+	 */
+	#define CONFIG_CMD_BMP
+	#define CONFIG_LCD
+	#define CONFIG_FB_BASE				(CONFIG_SYS_TEXT_BASE + 0x300000)
+	#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+	#undef LCD_TEST_PATTERN
+	/* #define CONFIG_SPLASH_IS_IN_MMC			1 */
+	#define LCD_BPP					LCD_MONOCHROME
+	/* #define CONFIG_SPLASH_SCREEN_ALIGN		1 */
+
+	#define CONFIG_WORKING_BUF_ADDR			(CONFIG_SYS_TEXT_BASE + 0x100000)
+	#define CONFIG_WAVEFORM_BUF_ADDR		(CONFIG_SYS_TEXT_BASE + 0x200000)
+	#define CONFIG_WAVEFORM_FILE_OFFSET		0x600000
+	#define CONFIG_WAVEFORM_FILE_SIZE		0xF0A00
+	#define CONFIG_WAVEFORM_FILE_IN_MMC
+
+#ifdef CONFIG_SPLASH_IS_IN_MMC
+	#define CONFIG_SPLASH_IMG_OFFSET		0x4c000
+	#define CONFIG_SPLASH_IMG_SIZE			0x19000
+#endif
+#endif /* CONFIG_SPLASH_SCREEN && CONFIG_MXC_EPDC */
+
+#endif                         /* __MX6QEA_COM_H */
diff --git a/include/configs/mx6sxea-com.h b/include/configs/mx6sxea-com.h
new file mode 100644
index 0000000..ac988dc
--- /dev/null
+++ b/include/configs/mx6sxea-com.h
@@ -0,0 +1,436 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Embedded Artists i.MX6 SoloX COM Board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX6SXEA_COM_H
+#define __MX6SXEA_COM_H
+
+#include <asm/arch/imx-regs.h>
+#include <linux/sizes.h>
+#include "mx6_common.h"
+#include <asm/imx-common/gpio.h>
+
+#define CONFIG_SPL_TEXT_BASE	0x00908000
+#define CONFIG_SPL_FRAMEWORK
+
+
+#if defined(CONFIG_SPL_BUILD)
+
+
+#define CONFIG_SPL_I2C_SUPPORT
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_GPIO_SUPPORT
+#define CONFIG_SPL_SERIAL_SUPPORT
+
+#define CONFIG_SPL_MMC_SUPPORT
+#define CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR 138
+
+#define CONFIG_SPL_BOARD_INIT
+
+#define CONFIG_SYS_SPL_MALLOC_START	0x912800
+#define CONFIG_SYS_SPL_MALLOC_SIZE	0x4800
+
+
+#endif
+
+
+#define CONFIG_MX6
+#define CONFIG_ROM_UNIFIED_SECTIONS
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+#define CONFIG_DBG_MONITOR
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_REVISION_TAG
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(16 * SZ_1M)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
+#define CONFIG_MXC_GPIO
+
+#define CONFIG_MXC_UART
+#define CONFIG_MXC_UART_BASE		UART1_BASE
+
+#define CONFIG_CMD_FUSE
+#ifdef CONFIG_CMD_FUSE
+#define CONFIG_MXC_OCOTP
+#endif
+
+/* MMC Configs */
+#define CONFIG_FSL_ESDHC
+#define CONFIG_FSL_USDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR	0
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+
+#define CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_FAT
+
+#define CONFIG_DOS_PARTITION
+#define CONFIG_SUPPORT_EMMC_BOOT /* eMMC specific */
+
+#define CONFIG_BAUDRATE			115200
+
+#undef CONFIG_BOOTM_NETBSD
+#undef CONFIG_BOOTM_PLAN9
+#undef CONFIG_BOOTM_RTEMS
+
+#undef CONFIG_CMD_EXPORTENV
+#undef CONFIG_CMD_IMPORTENV
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_NET
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define CONFIG_FEC_ENET_DEV 0
+
+#if (CONFIG_FEC_ENET_DEV == 0)
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x1
+#elif (CONFIG_FEC_ENET_DEV == 1)
+#define IMX_FEC_BASE			ENET2_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x2
+#endif
+#define CONFIG_FEC_XCV_TYPE             RGMII
+#define CONFIG_ETHPRIME                 "FEC"
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_ATHEROS
+#define CONFIG_FEC_DMA_MINALIGN		64
+#define CONFIG_FEC_MXC_25M_REF_CLK
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_CONS_INDEX		1
+
+/* I2C configs */
+#define CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_SPEED		100000
+
+/* MAX7322 */
+#ifdef CONFIG_FEC_ENABLE_MAX7322
+#define CONFIG_MAX7322_I2C_ADDR		0x68
+#define CONFIG_MAX7322_I2C_BUS		1
+#endif
+
+/* EEPROM */
+#define CONFIG_CMD_EEPROM
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 2
+#define CONFIG_ENV_EEPROM_IS_ON_I2C
+#define CONFIG_SYS_I2C_MULTI_EEPROMS
+/* the page boundary is 32 bytes (2^5 = 32) */
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS 5
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS 10
+
+/* PMIC */
+#define CONFIG_PFUZE100_PMIC_I2C
+#ifdef CONFIG_PFUZE100_PMIC_I2C
+#define CONFIG_PMIC_I2C_BUS		0
+#define CONFIG_PMIC_I2C_SLAVE		0x8
+#endif
+
+/* VIDEO */
+#define CONFIG_VIDEO
+#define CONFIG_VIDEO_GIS
+#define CONFIG_CMD_EADISP
+
+/* Command definition */
+#include <config_cmd_default.h>
+
+#undef CONFIG_CMD_IMLS
+
+#define CONFIG_BOOTDELAY		3
+
+#define CONFIG_LOADADDR			0x80800000
+#define CONFIG_SYS_TEXT_BASE		0x87800000
+
+#define CONFIG_SYS_AUXCORE_BOOTDATA 0x78000000 /* Set to QSPI2 B flash at default */
+#ifndef CONFIG_SYS_AUXCORE_FASTUP
+#define CONFIG_CMD_BOOTAUX /* Boot M4 by command, disable this when M4 fast up */
+#define CONFIG_CMD_SETEXPR
+#endif
+
+#ifdef CONFIG_CMD_BOOTAUX
+#define UPDATE_M4_ENV \
+	"m4image=m4_qspi.bin\0" \
+	"loadm4image=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${m4image}\0" \
+	"update_m4_from_sd=" \
+		"if sf probe 1:0; then " \
+			"if run loadm4image; then " \
+				"setexpr fw_sz ${filesize} + 0xffff; " \
+				"setexpr fw_sz ${fw_sz} / 0x10000; "	\
+				"setexpr fw_sz ${fw_sz} * 0x10000; "	\
+				"sf erase 0x0 ${fw_sz}; " \
+				"sf write ${loadaddr} 0x0 ${filesize}; " \
+			"fi; " \
+		"fi\0" \
+	"m4boot=sf probe 1:0; bootaux "__stringify(CONFIG_SYS_AUXCORE_BOOTDATA)"\0"
+#else
+#define UPDATE_M4_ENV ""
+#endif
+
+#ifdef CONFIG_VIDEO
+#define CONFIG_VIDEO_MODE \
+	"panel=Hannstar-XGA\0"
+#else
+#define CONFIG_VIDEO_MODE ""
+#endif
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		"\0" \
+	"initrd_addr=0x83800000\0" \
+	"initrd_high=0xffffffff\0" \
+	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	UPDATE_M4_ENV \
+	CONFIG_VIDEO_MODE \
+	"script=boot.scr\0" \
+	"image=zImage\0" \
+	"console=ttymxc0\0" \
+	"fdt_high=0xffffffff\0" \
+	"initrd_high=0xffffffff\0" \
+	"fdt_file=imx6sxea-com-kit.dtb\0" \
+	"fdt_addr=0x83000000\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=yes\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"mmcpart=1\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
+	"mmcargs=setenv bootargs console=${console},${baudrate} " \
+		"root=${mmcroot} ${args_from_script}\0" \
+	"loadbootscript=" \
+		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} " \
+		"root=/dev/nfs " \
+	    "ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp ${args_from_script}\0" \
+	"netboot=echo Booting from net ...; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${image}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0"
+
+#define CONFIG_BOOTCOMMAND \
+	   "mmc dev ${mmcdev};" \
+	   "if mmc rescan; then " \
+		   "if run loadbootscript; then " \
+			   "run bootscript; " \
+		   "else " \
+			   "if run loadimage; then " \
+				   "run mmcboot; " \
+			   "else run netboot; " \
+			   "fi; " \
+		   "fi; " \
+	   "else run netboot; fi"
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT		"=> "
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_CBSIZE		1024
+
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS		256
+#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
+
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_MEMTEST_START	0x80000000
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + 0x10000)
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
+#define CONFIG_SYS_HZ			1000
+
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_STACKSIZE		SZ_128K
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS		1
+#define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
+#define PHYS_SDRAM_SIZE			SZ_1G
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* FLASH and environment organization */
+#define CONFIG_SYS_NO_FLASH
+
+#define CONFIG_ENV_SIZE			SZ_8K
+
+#ifdef CONFIG_SYS_AUXCORE_FASTUP
+/*#define CONFIG_MXC_RDC*/   /* Disable the RDC temporarily, will enable it in future */
+#define CONFIG_ENV_IS_IN_MMC  /* Must disable QSPI driver, because M4 run on QSPI */
+#elif defined CONFIG_SYS_BOOT_QSPI
+#define CONFIG_FSL_QSPI
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#else
+#define CONFIG_FSL_QSPI   /* Enable the QSPI flash at default */
+#define CONFIG_ENV_IS_IN_MMC
+#endif
+
+#ifdef CONFIG_FSL_QSPI
+#define CONFIG_QSPI_BASE		QSPI2_BASE_ADDR
+#define CONFIG_QSPI_MEMMAP_BASE		QSPI2_ARB_BASE_ADDR
+
+#define CONFIG_CMD_SF
+#define	CONFIG_SPI_FLASH
+#define	CONFIG_SPI_FLASH_BAR
+#define	CONFIG_SPI_FLASH_SPANSION
+#define CONFIG_SPI_FLASH_STMICRO
+#define	CONFIG_SF_DEFAULT_BUS		0
+#define	CONFIG_SF_DEFAULT_CS		0
+#define	CONFIG_SF_DEFAULT_SPEED		40000000
+#define	CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+#endif
+
+#define CONFIG_SYS_MMC_ENV_DEV		2  /*USDHC4*/
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
+#define CONFIG_MMCROOT			"/dev/mmcblk3p2"  /* USDHC4 */
+
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(8 * SZ_64K)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+#endif
+
+
+#define CONFIG_OF_LIBFDT
+#define CONFIG_CMD_BOOTZ
+
+#define CONFIG_CMD_BMODE
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+#define CONFIG_CMD_CACHE
+#endif
+
+#ifdef CONFIG_VIDEO
+#define	CONFIG_CFB_CONSOLE
+#define	CONFIG_VIDEO_MXS
+#define	CONFIG_VIDEO_LOGO
+#define	CONFIG_VIDEO_SW_CURSOR
+#define	CONFIG_VGA_AS_SINGLE_DEVICE
+#define	CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define	CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define	CONFIG_CMD_BMP
+#define	CONFIG_BMP_16BPP
+#define	CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_VIDEO_BMP_LOGO
+#ifdef CONFIG_VIDEO_GIS
+#define CONFIG_VIDEO_CSI
+#define CONFIG_VIDEO_PXP
+#define CONFIG_VIDEO_VADC
+#endif
+#endif
+
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+
+/*
+ * The PCIe support in uboot would bring failures in i.MX6SX PCIe
+ * EP/RC validations. Disable PCIe support in uboot here.
+ * RootCause: The bit10(ltssm_en) of GPR12 would be set in uboot,
+ * thus the i.MX6SX PCIe EP would be cheated that the other i.MX6SX
+ * PCIe RC had been configured and trying to setup PCIe link directly,
+ * although the i.MX6SX RC is not properly configured at that time.
+ * PCIe can be supported in uboot, if the i.MX6SX PCIe EP/RC validation
+ * is not running.
+ */
+/* #define CONFIG_CMD_PCI */
+#ifdef CONFIG_CMD_PCI
+#define CONFIG_PCI
+#define CONFIG_PCI_PNP
+#define CONFIG_PCI_SCAN_SHOW
+#define CONFIG_PCIE_IMX
+#define CONFIG_PCIE_IMX_PERST_GPIO	IMX_GPIO_NR(2, 0)
+#define CONFIG_PCIE_IMX_POWER_GPIO	IMX_GPIO_NR(2, 1)
+#endif
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "mx6sxsabresdandroid.h"
+#endif
+
+#endif				/* __MX6SXEA_COM_H */
diff --git a/include/configs/mx6ulea-com.h b/include/configs/mx6ulea-com.h
new file mode 100644
index 0000000..74547ed
--- /dev/null
+++ b/include/configs/mx6ulea-com.h
@@ -0,0 +1,443 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Embedded Artists i.MX6 UltraLite COM Board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef __MX6ULEA_COM_H
+#define __MX6ULEA_COM_H
+
+
+#include <asm/arch/imx-regs.h>
+#include <linux/sizes.h>
+#include "mx6_common.h"
+#include <asm/imx-common/gpio.h>
+
+#define CONFIG_SPL_TEXT_BASE	0x00908000
+#define CONFIG_SPL_FRAMEWORK
+
+
+#if defined(CONFIG_SPL_BUILD)
+
+
+#define CONFIG_SPL_I2C_SUPPORT
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_GPIO_SUPPORT
+#define CONFIG_SPL_SERIAL_SUPPORT
+
+#define CONFIG_SPL_MMC_SUPPORT
+#define CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR 138
+
+#define CONFIG_SPL_BOARD_INIT
+
+#define CONFIG_SYS_SPL_MALLOC_START	0x912800
+#define CONFIG_SYS_SPL_MALLOC_SIZE	0x4800
+
+
+#endif
+
+#define CONFIG_MX6
+#define CONFIG_ROM_UNIFIED_SECTIONS
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_PFUZE300
+#define CONFIG_POWER_PFUZE300_I2C_ADDR 0x08
+/* DCDC used on EVK, no PMIC */
+#undef CONFIG_LDO_BYPASS_CHECK
+
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+#ifdef CONFIG_SECURE_BOOT
+#ifndef CONFIG_CSF_SIZE
+#define CONFIG_CSF_SIZE 0x4000
+#endif
+#endif
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_REVISION_TAG
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(16 * SZ_1M)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
+#define CONFIG_MXC_GPIO
+
+#define CONFIG_MXC_UART
+#define CONFIG_MXC_UART_BASE		UART1_BASE
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_BAUDRATE			115200
+
+#define CONFIG_CMD_FUSE
+#ifdef CONFIG_CMD_FUSE
+#define CONFIG_MXC_OCOTP
+#endif
+
+/* MMC Configs */
+#define CONFIG_FSL_USDHC
+#ifdef CONFIG_FSL_USDHC
+#define CONFIG_FSL_ESDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR	USDHC2_BASE_ADDR
+
+#ifdef CONFIG_SYS_USE_NAND
+#define CONFIG_SYS_FSL_USDHC_NUM	1
+#else
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#endif
+
+#define CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#define CONFIG_SUPPORT_EMMC_BOOT /* eMMC specific */
+#endif
+
+#undef CONFIG_BOOTM_NETBSD
+#undef CONFIG_BOOTM_PLAN9
+#undef CONFIG_BOOTM_RTEMS
+
+#undef CONFIG_CMD_EXPORTENV
+#undef CONFIG_CMD_IMPORTENV
+
+#define CONFIG_CMD_NET
+#ifdef CONFIG_CMD_NET
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define CONFIG_FEC_ENET_DEV 0
+
+#if (CONFIG_FEC_ENET_DEV == 0)
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x2
+#define CONFIG_FEC_XCV_TYPE             RMII
+#elif (CONFIG_FEC_ENET_DEV == 1)
+#define IMX_FEC_BASE			ENET2_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x1  /* need board rework */
+#define CONFIG_FEC_XCV_TYPE             RMII
+#endif
+#define CONFIG_ETHPRIME                 "FEC"
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_MICREL
+#define CONFIG_FEC_DMA_MINALIGN		64
+#endif
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_CONS_INDEX		1
+
+/* I2C configs */
+#define CONFIG_CMD_I2C
+#ifdef CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_SPEED		100000
+#endif
+
+/* EEPROM */
+#define CONFIG_CMD_EEPROM
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 2
+#define CONFIG_ENV_EEPROM_IS_ON_I2C
+#define CONFIG_SYS_I2C_MULTI_EEPROMS
+/* the page boundary is 32 bytes (2^5 = 32) */
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS 5
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS 10
+
+#define PHYS_SDRAM_SIZE			SZ_512M
+
+#define CONFIG_VIDEO
+#define CONFIG_CMD_EADISP
+
+/* Command definition */
+#include <config_cmd_default.h>
+
+#undef CONFIG_CMD_IMLS
+
+#define CONFIG_BOOTDELAY		3
+
+#define CONFIG_LOADADDR			0x80800000
+#define CONFIG_SYS_TEXT_BASE		0x87800000
+
+#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
+#ifdef CONFIG_SYS_BOOT_NAND
+#define CONFIG_MFG_NAND_PARTITION "mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs) "
+#else
+#define CONFIG_MFG_NAND_PARTITION ""
+#endif
+
+#ifdef CONFIG_VIDEO
+#define CONFIG_VIDEO_MODE \
+	"panel=Innolux-AT070TN\0"
+#else
+#define CONFIG_VIDEO_MODE ""
+#endif
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		CONFIG_MFG_NAND_PARTITION \
+		"clk_ignore_unused "\
+		"\0" \
+	"initrd_addr=0x83800000\0" \
+	"initrd_high=0xffffffff\0" \
+	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+#if defined(CONFIG_SYS_BOOT_NAND)
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	CONFIG_VIDEO_MODE \
+	"fdt_addr=0x83000000\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"console=ttymxc0\0" \
+	"bootargs=console=ttymxc0,115200 ubi.mtd=3 "  \
+		"root=ubi0:rootfs rootfstype=ubifs "		     \
+		"mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs)\0"\
+	"bootcmd=nand read ${loadaddr} 0x4000000 0x800000;"\
+		"nand read ${fdt_addr} 0x5000000 0x100000;"\
+		"bootz ${loadaddr} - ${fdt_addr}\0"
+
+#else
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	CONFIG_VIDEO_MODE \
+	"script=boot.scr\0" \
+	"image=zImage\0" \
+	"console=ttymxc0\0" \
+	"fdt_high=0xffffffff\0" \
+	"initrd_high=0xffffffff\0" \
+	"fdt_file=imx6ulea-com-kit.dtb\0" \
+	"fdt_addr=0x83000000\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=yes\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
+	"mmcargs=setenv bootargs console=${console},${baudrate} " \
+		"root=${mmcroot} ${args_from_script}\0" \
+	"loadbootscript=" \
+		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} " \
+		"root=/dev/nfs " \
+	"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp ${args_from_script}\0" \
+		"netboot=echo Booting from net ...; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${image}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0"
+
+#define CONFIG_BOOTCOMMAND \
+	   "mmc dev ${mmcdev};" \
+	   "mmc dev ${mmcdev}; if mmc rescan; then " \
+		   "if run loadbootscript; then " \
+			   "run bootscript; " \
+		   "else " \
+			   "if run loadimage; then " \
+				   "run mmcboot; " \
+			   "else run netboot; " \
+			   "fi; " \
+		   "fi; " \
+	   "else run netboot; fi"
+#endif
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT		"=> "
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_CBSIZE		1024
+
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS		256
+#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
+
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_MEMTEST_START	0x80000000
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + 0x10000000)
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
+#define CONFIG_SYS_HZ			1000
+
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_STACKSIZE		SZ_128K
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS		1
+#define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* FLASH and environment organization */
+#define CONFIG_SYS_NO_FLASH
+
+#define CONFIG_ENV_SIZE			SZ_8K
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+#define CONFIG_FSL_QSPI
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_SYS_USE_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#else
+#define CONFIG_FSL_QSPI
+#define CONFIG_ENV_IS_IN_MMC
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_NAND_TRIMFFS
+
+/* NAND stuff */
+#define CONFIG_NAND_MXS
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_BASE		0x40000000
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* DMA stuff, needed for GPMI/MXS NAND support */
+#define CONFIG_APBH_DMA
+#define CONFIG_APBH_DMA_BURST
+#define CONFIG_APBH_DMA_BURST8
+#endif
+
+#ifdef CONFIG_FSL_QSPI
+#define CONFIG_QSPI_BASE		QSPI1_BASE_ADDR
+#define CONFIG_QSPI_MEMMAP_BASE		QSPI1_ARB_BASE_ADDR
+
+#define CONFIG_CMD_SF
+#define	CONFIG_SPI_FLASH
+#define	CONFIG_SPI_FLASH_STMICRO
+#define	CONFIG_SPI_FLASH_BAR
+#define	CONFIG_SF_DEFAULT_BUS		0
+#define	CONFIG_SF_DEFAULT_CS		0
+#define	CONFIG_SF_DEFAULT_SPEED		40000000
+#define	CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+#endif
+
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(8 * SZ_64K)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+#elif defined(CONFIG_ENV_IS_IN_NAND)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_OFFSET		(8 << 20)
+#define CONFIG_ENV_SECT_SIZE		(128 << 10)
+#define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
+#endif
+
+#define CONFIG_SYS_MMC_ENV_DEV		1   /* USDHC2 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
+#define CONFIG_MMCROOT			"/dev/mmcblk1p2"  /* USDHC2 */
+
+#define CONFIG_OF_LIBFDT
+#define CONFIG_CMD_BOOTZ
+
+#define CONFIG_CMD_BMODE
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+#define CONFIG_CMD_CACHE
+#endif
+
+#ifdef CONFIG_VIDEO
+#define	CONFIG_CFB_CONSOLE
+#define	CONFIG_VIDEO_MXS
+#define	CONFIG_VIDEO_LOGO
+#define	CONFIG_VIDEO_SW_CURSOR
+#define	CONFIG_VGA_AS_SINGLE_DEVICE
+#define	CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define	CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define	CONFIG_CMD_BMP
+#define	CONFIG_BMP_16BPP
+#define	CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_VIDEO_BMP_LOGO
+#endif
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#ifdef CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#endif
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "mx6ul_14x14_evk_android.h"
+#endif
+
+#endif
diff --git a/include/configs/mx7dea-com.h b/include/configs/mx7dea-com.h
new file mode 100644
index 0000000..dc3ee5e
--- /dev/null
+++ b/include/configs/mx7dea-com.h
@@ -0,0 +1,467 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Embedded Artists i.MX7 Dual COM board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX7D_COM_KIT_CONFIG_H
+#define __MX7D_COM_KIT_CONFIG_H
+
+#include <asm/arch/imx-regs.h>
+#include <linux/sizes.h>
+#include "mx7_common.h"
+#include <asm/imx-common/gpio.h>
+
+#define CONFIG_SPL_TEXT_BASE    0x00908000
+#define CONFIG_SPL_FRAMEWORK
+
+
+#if defined(CONFIG_SPL_BUILD)
+
+
+#define CONFIG_SPL_I2C_SUPPORT
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_GPIO_SUPPORT
+#define CONFIG_SPL_SERIAL_SUPPORT
+
+#define CONFIG_SPL_MMC_SUPPORT
+#define CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR 138
+
+#define CONFIG_SPL_BOARD_INIT
+
+#define CONFIG_SYS_SPL_MALLOC_START     0x912800
+#define CONFIG_SYS_SPL_MALLOC_SIZE      0x4800
+
+
+#endif
+
+#define CONFIG_MX7
+#define CONFIG_ROM_UNIFIED_SECTIONS
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+#define CONFIG_DBG_MONITOR
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+#ifdef CONFIG_SECURE_BOOT
+#ifndef CONFIG_CSF_SIZE
+#define CONFIG_CSF_SIZE 0x4000
+#endif
+#endif
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_REVISION_TAG
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(32 * SZ_1M)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
+#define CONFIG_MXC_GPIO
+
+#define CONFIG_MXC_UART
+#define CONFIG_MXC_UART_BASE		UART1_IPS_BASE_ADDR
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_BAUDRATE			115200
+
+#define CONFIG_CMD_FUSE
+#ifdef CONFIG_CMD_FUSE
+#define CONFIG_MXC_OCOTP
+#endif
+
+/* MMC Configs */
+#define CONFIG_FSL_ESDHC
+#define CONFIG_FSL_USDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR	0
+
+#define CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#define CONFIG_SUPPORT_EMMC_BOOT /* eMMC specific */
+
+#define PHYS_SDRAM_SIZE			SZ_1G
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_NET
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define CONFIG_FEC_XCV_TYPE             RGMII
+#define CONFIG_ETHPRIME                 "FEC"
+#define CONFIG_FEC_MXC_PHYADDR          1
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_BROADCOM
+#define CONFIG_FEC_DMA_MINALIGN		64
+
+/* ENET1 */
+#define IMX_FEC_BASE			ENET_IPS_BASE_ADDR
+
+/* PMIC */
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_PFUZE300
+#define CONFIG_POWER_PFUZE300_I2C_ADDR	0x08
+
+#undef CONFIG_BOOTM_NETBSD
+#undef CONFIG_BOOTM_PLAN9
+#undef CONFIG_BOOTM_RTEMS
+
+#undef CONFIG_CMD_EXPORTENV
+#undef CONFIG_CMD_IMPORTENV
+
+/* I2C configs */
+#define CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_SPEED		100000
+
+/* Command definition */
+#include <config_cmd_default.h>
+
+#undef CONFIG_CMD_IMLS
+
+#define CONFIG_BOOTDELAY		3
+
+#define CONFIG_LOADADDR			0x80800000
+#define CONFIG_SYS_TEXT_BASE		0x87800000
+
+#define CONFIG_SYS_AUXCORE_BOOTDATA 0x60000000 /* Set to QSPI1 A flash at default */
+#define CONFIG_CMD_BOOTAUX /* Boot M4 */
+#define CONFIG_CMD_SETEXPR
+
+#ifdef CONFIG_CMD_BOOTAUX
+#define UPDATE_M4_ENV \
+	"m4image=m4_qspi.bin\0" \
+	"loadm4image=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${m4image}\0" \
+	"update_m4_from_sd=" \
+		"if sf probe 0:0; then " \
+			"if run loadm4image; then " \
+				"setexpr fw_sz ${filesize} + 0xffff; " \
+				"setexpr fw_sz ${fw_sz} / 0x10000; "	\
+				"setexpr fw_sz ${fw_sz} * 0x10000; "	\
+				"sf erase 0x0 ${fw_sz}; " \
+				"sf write ${loadaddr} 0x0 ${filesize}; " \
+			"fi; " \
+		"fi\0" \
+	"m4boot=sf probe 0:0; bootaux "__stringify(CONFIG_SYS_AUXCORE_BOOTDATA)"\0"
+#else
+#define UPDATE_M4_ENV ""
+#endif
+
+#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
+#ifdef CONFIG_SYS_BOOT_NAND
+#define CONFIG_MFG_NAND_PARTITION "mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs) "
+#else
+#define CONFIG_MFG_NAND_PARTITION ""
+#endif
+
+#ifdef CONFIG_VIDEO
+#define CONFIG_VIDEO_MODE \
+	"panel=TFT43AB\0"
+#else
+#define CONFIG_VIDEO_MODE ""
+#endif
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		CONFIG_MFG_NAND_PARTITION \
+		"clk_ignore_unused "\
+		"\0" \
+	"initrd_addr=0x83800000\0" \
+	"initrd_high=0xffffffff\0" \
+	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+#if defined(CONFIG_SYS_BOOT_NAND)
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	CONFIG_VIDEO_MODE \
+	"fdt_addr=0x83000000\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"console=ttymxc0\0" \
+	"bootargs=console=ttymxc0,115200 ubi.mtd=3 "  \
+		"root=ubi0:rootfs rootfstype=ubifs "		     \
+		"mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs)\0"\
+	"bootcmd=nand read ${loadaddr} 0x4000000 0x800000;"\
+		"nand read ${fdt_addr} 0x5000000 0x100000;"\
+		"bootz ${loadaddr} - ${fdt_addr}\0"
+
+#else
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	UPDATE_M4_ENV \
+	CONFIG_VIDEO_MODE \
+	"script=boot.scr\0" \
+	"image=zImage\0" \
+	"console=ttymxc0\0" \
+	"fdt_high=0xffffffff\0" \
+	"initrd_high=0xffffffff\0" \
+	"fdt_file=imx7dea-com-kit.dtb\0" \
+	"fdt_addr=0x83000000\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=yes\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
+	"mmcargs=setenv bootargs console=${console},${baudrate} " \
+		"root=${mmcroot} ${args_from_script}\0" \
+	"loadbootscript=" \
+		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} " \
+		"root=/dev/nfs " \
+	"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp ${args_from_script}\0" \
+		"netboot=echo Booting from net ...; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${image}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0"
+
+#define CONFIG_BOOTCOMMAND \
+	   "mmc dev ${mmcdev};" \
+	   "mmc dev ${mmcdev}; if mmc rescan; then " \
+		   "if run loadbootscript; then " \
+			   "run bootscript; " \
+		   "else " \
+			   "if run loadimage; then " \
+				   "run mmcboot; " \
+			   "else run netboot; " \
+			   "fi; " \
+		   "fi; " \
+	   "else run netboot; fi"
+#endif
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT		"=> "
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_CBSIZE		1024
+
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS		256
+#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
+
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_MEMTEST_START	0x80000000
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + 0x20000000)
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
+#define CONFIG_SYS_HZ			1000
+
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_STACKSIZE		SZ_128K
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS		1
+#define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* FLASH and environment organization */
+#define CONFIG_SYS_NO_FLASH
+
+#define CONFIG_ENV_SIZE			SZ_8K
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+#define CONFIG_SYS_USE_QSPI
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_SYS_USE_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#else
+#define CONFIG_ENV_IS_IN_MMC
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_NAND_TRIMFFS
+
+/* NAND stuff */
+#define CONFIG_NAND_MXS
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_BASE		0x40000000
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* DMA stuff, needed for GPMI/MXS NAND support */
+#define CONFIG_APBH_DMA
+#define CONFIG_APBH_DMA_BURST
+#define CONFIG_APBH_DMA_BURST8
+#endif
+
+#ifdef CONFIG_SYS_USE_QSPI
+#define CONFIG_FSL_QSPI    /* enable the QUADSPI driver */
+#define CONFIG_QSPI_BASE		QSPI1_IPS_BASE_ADDR
+#define CONFIG_QSPI_MEMMAP_BASE		QSPI0_ARB_BASE_ADDR
+
+#define CONFIG_CMD_SF
+#define	CONFIG_SPI_FLASH
+#define	CONFIG_SPI_FLASH_MACRONIX
+#define	CONFIG_SPI_FLASH_BAR
+#define	CONFIG_SF_DEFAULT_BUS		0
+#define	CONFIG_SF_DEFAULT_CS		0
+#define	CONFIG_SF_DEFAULT_SPEED		40000000
+#define	CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+#endif
+
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(8 * SZ_64K)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+#elif defined(CONFIG_ENV_IS_IN_NAND)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_OFFSET		(37 << 20)
+#define CONFIG_ENV_SECT_SIZE		(128 << 10)
+#define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+#define CONFIG_SYS_FSL_USDHC_NUM	1
+#else
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#endif
+#define CONFIG_SYS_MMC_ENV_DEV		0   /* USDHC1 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
+#define CONFIG_MMCROOT			"/dev/mmcblk0p2"  /* USDHC1 */
+
+#define CONFIG_OF_LIBFDT
+#define CONFIG_CMD_BOOTZ
+
+#define CONFIG_CMD_BMODE
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+#define CONFIG_CMD_CACHE
+#endif
+
+#define CONFIG_VIDEO
+#define CONFIG_CMD_EADISP
+
+#ifdef CONFIG_VIDEO
+#define	CONFIG_CFB_CONSOLE
+#define	CONFIG_VIDEO_MXS
+#define	CONFIG_VIDEO_LOGO
+#define	CONFIG_VIDEO_SW_CURSOR
+#define	CONFIG_VGA_AS_SINGLE_DEVICE
+#define	CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define	CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define	CONFIG_CMD_BMP
+#define	CONFIG_BMP_16BPP
+#define	CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_VIDEO_BMP_LOGO
+#endif
+
+/* #define CONFIG_SPLASH_SCREEN*/
+/* #define CONFIG_MXC_EPDC*/
+
+/*
+ * SPLASH SCREEN Configs
+ */
+#if defined(CONFIG_SPLASH_SCREEN) && defined(CONFIG_MXC_EPDC)
+/*
+ * Framebuffer and LCD
+ */
+#define	CONFIG_CFB_CONSOLE
+#define CONFIG_CMD_BMP
+#define CONFIG_LCD
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+
+#undef LCD_TEST_PATTERN
+/* #define CONFIG_SPLASH_IS_IN_MMC			1 */
+#define LCD_BPP					LCD_MONOCHROME
+/* #define CONFIG_SPLASH_SCREEN_ALIGN		1 */
+
+#define CONFIG_WAVEFORM_BUF_SIZE		0x400000
+#endif
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX7
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+
+#define CONFIG_IMX_THERMAL
+
+#if defined(CONFIG_MXC_EPDC) && defined(CONFIG_SYS_USE_QSPI)
+#error "EPDC Pins conflicts QSPI, Either EPDC or QSPI can be enabled!"
+#endif
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "mx7dsabresdandroid.h"
+#endif
+#endif	/* __MX7D_COM_KIT_CONFIG_H */
diff --git a/include/configs/mx7dea-ucom.h b/include/configs/mx7dea-ucom.h
new file mode 100644
index 0000000..9359925
--- /dev/null
+++ b/include/configs/mx7dea-ucom.h
@@ -0,0 +1,467 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Embedded Artists i.MX7 Dual uCOM board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX7D_UCOM_KIT_CONFIG_H
+#define __MX7D_UCOM_KIT_CONFIG_H
+
+#include <asm/arch/imx-regs.h>
+#include <linux/sizes.h>
+#include "mx7_common.h"
+#include <asm/imx-common/gpio.h>
+
+#define CONFIG_SPL_TEXT_BASE    0x00908000
+#define CONFIG_SPL_FRAMEWORK
+
+
+#if defined(CONFIG_SPL_BUILD)
+
+
+#define CONFIG_SPL_I2C_SUPPORT
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_GPIO_SUPPORT
+#define CONFIG_SPL_SERIAL_SUPPORT
+
+#define CONFIG_SPL_MMC_SUPPORT
+#define CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR 138
+
+#define CONFIG_SPL_BOARD_INIT
+
+#define CONFIG_SYS_SPL_MALLOC_START     0x912800
+#define CONFIG_SYS_SPL_MALLOC_SIZE      0x4800
+
+
+#endif
+
+#define CONFIG_MX7
+#define CONFIG_ROM_UNIFIED_SECTIONS
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+#define CONFIG_DBG_MONITOR
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+#ifdef CONFIG_SECURE_BOOT
+#ifndef CONFIG_CSF_SIZE
+#define CONFIG_CSF_SIZE 0x4000
+#endif
+#endif
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_REVISION_TAG
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(32 * SZ_1M)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
+#define CONFIG_MXC_GPIO
+
+#define CONFIG_MXC_UART
+#define CONFIG_MXC_UART_BASE		UART1_IPS_BASE_ADDR
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_BAUDRATE			115200
+
+#define CONFIG_CMD_FUSE
+#ifdef CONFIG_CMD_FUSE
+#define CONFIG_MXC_OCOTP
+#endif
+
+/* MMC Configs */
+#define CONFIG_FSL_ESDHC
+#define CONFIG_FSL_USDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR	0
+
+#define CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#define CONFIG_SUPPORT_EMMC_BOOT /* eMMC specific */
+
+#define PHYS_SDRAM_SIZE			SZ_1G
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_NET
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define CONFIG_FEC_XCV_TYPE             RGMII
+#define CONFIG_ETHPRIME                 "FEC"
+#define CONFIG_FEC_MXC_PHYADDR          1
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_BROADCOM
+#define CONFIG_FEC_DMA_MINALIGN		64
+
+/* ENET1 */
+#define IMX_FEC_BASE			ENET_IPS_BASE_ADDR
+
+/* PMIC */
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_PFUZE300
+#define CONFIG_POWER_PFUZE300_I2C_ADDR	0x08
+
+#undef CONFIG_BOOTM_NETBSD
+#undef CONFIG_BOOTM_PLAN9
+#undef CONFIG_BOOTM_RTEMS
+
+#undef CONFIG_CMD_EXPORTENV
+#undef CONFIG_CMD_IMPORTENV
+
+/* I2C configs */
+#define CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_SPEED		100000
+
+/* Command definition */
+#include <config_cmd_default.h>
+
+#undef CONFIG_CMD_IMLS
+
+#define CONFIG_BOOTDELAY		3
+
+#define CONFIG_LOADADDR			0x80800000
+#define CONFIG_SYS_TEXT_BASE		0x87800000
+
+#define CONFIG_SYS_AUXCORE_BOOTDATA 0x60000000 /* Set to QSPI1 A flash at default */
+#define CONFIG_CMD_BOOTAUX /* Boot M4 */
+#define CONFIG_CMD_SETEXPR
+
+#ifdef CONFIG_CMD_BOOTAUX
+#define UPDATE_M4_ENV \
+	"m4image=m4_qspi.bin\0" \
+	"loadm4image=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${m4image}\0" \
+	"update_m4_from_sd=" \
+		"if sf probe 0:0; then " \
+			"if run loadm4image; then " \
+				"setexpr fw_sz ${filesize} + 0xffff; " \
+				"setexpr fw_sz ${fw_sz} / 0x10000; "	\
+				"setexpr fw_sz ${fw_sz} * 0x10000; "	\
+				"sf erase 0x0 ${fw_sz}; " \
+				"sf write ${loadaddr} 0x0 ${filesize}; " \
+			"fi; " \
+		"fi\0" \
+	"m4boot=sf probe 0:0; bootaux "__stringify(CONFIG_SYS_AUXCORE_BOOTDATA)"\0"
+#else
+#define UPDATE_M4_ENV ""
+#endif
+
+#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
+#ifdef CONFIG_SYS_BOOT_NAND
+#define CONFIG_MFG_NAND_PARTITION "mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs) "
+#else
+#define CONFIG_MFG_NAND_PARTITION ""
+#endif
+
+#ifdef CONFIG_VIDEO
+#define CONFIG_VIDEO_MODE \
+	"panel=TFT43AB\0"
+#else
+#define CONFIG_VIDEO_MODE ""
+#endif
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		CONFIG_MFG_NAND_PARTITION \
+		"clk_ignore_unused "\
+		"\0" \
+	"initrd_addr=0x83800000\0" \
+	"initrd_high=0xffffffff\0" \
+	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+#if defined(CONFIG_SYS_BOOT_NAND)
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	CONFIG_VIDEO_MODE \
+	"fdt_addr=0x83000000\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"console=ttymxc0\0" \
+	"bootargs=console=ttymxc0,115200 ubi.mtd=3 "  \
+		"root=ubi0:rootfs rootfstype=ubifs "		     \
+		"mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs)\0"\
+	"bootcmd=nand read ${loadaddr} 0x4000000 0x800000;"\
+		"nand read ${fdt_addr} 0x5000000 0x100000;"\
+		"bootz ${loadaddr} - ${fdt_addr}\0"
+
+#else
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	UPDATE_M4_ENV \
+	CONFIG_VIDEO_MODE \
+	"script=boot.scr\0" \
+	"image=zImage\0" \
+	"console=ttymxc0\0" \
+	"fdt_high=0xffffffff\0" \
+	"initrd_high=0xffffffff\0" \
+	"fdt_file=imx7dea-ucom-kit.dtb\0" \
+	"fdt_addr=0x83000000\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=yes\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
+	"mmcargs=setenv bootargs console=${console},${baudrate} " \
+		"root=${mmcroot} ${args_from_script}\0" \
+	"loadbootscript=" \
+		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} " \
+		"root=/dev/nfs " \
+	"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp ${args_from_script}\0" \
+		"netboot=echo Booting from net ...; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${image}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0"
+
+#define CONFIG_BOOTCOMMAND \
+	   "mmc dev ${mmcdev};" \
+	   "mmc dev ${mmcdev}; if mmc rescan; then " \
+		   "if run loadbootscript; then " \
+			   "run bootscript; " \
+		   "else " \
+			   "if run loadimage; then " \
+				   "run mmcboot; " \
+			   "else run netboot; " \
+			   "fi; " \
+		   "fi; " \
+	   "else run netboot; fi"
+#endif
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT		"=> "
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_CBSIZE		1024
+
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS		256
+#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
+
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_MEMTEST_START	0x80000000
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + 0x20000000)
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
+#define CONFIG_SYS_HZ			1000
+
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_STACKSIZE		SZ_128K
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS		1
+#define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* FLASH and environment organization */
+#define CONFIG_SYS_NO_FLASH
+
+#define CONFIG_ENV_SIZE			SZ_8K
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+#define CONFIG_SYS_USE_QSPI
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_SYS_USE_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#else
+#define CONFIG_ENV_IS_IN_MMC
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_NAND_TRIMFFS
+
+/* NAND stuff */
+#define CONFIG_NAND_MXS
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_BASE		0x40000000
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* DMA stuff, needed for GPMI/MXS NAND support */
+#define CONFIG_APBH_DMA
+#define CONFIG_APBH_DMA_BURST
+#define CONFIG_APBH_DMA_BURST8
+#endif
+
+#ifdef CONFIG_SYS_USE_QSPI
+#define CONFIG_FSL_QSPI    /* enable the QUADSPI driver */
+#define CONFIG_QSPI_BASE		QSPI1_IPS_BASE_ADDR
+#define CONFIG_QSPI_MEMMAP_BASE		QSPI0_ARB_BASE_ADDR
+
+#define CONFIG_CMD_SF
+#define	CONFIG_SPI_FLASH
+#define	CONFIG_SPI_FLASH_MACRONIX
+#define	CONFIG_SPI_FLASH_BAR
+#define	CONFIG_SF_DEFAULT_BUS		0
+#define	CONFIG_SF_DEFAULT_CS		0
+#define	CONFIG_SF_DEFAULT_SPEED		40000000
+#define	CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+#endif
+
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(8 * SZ_64K)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+#elif defined(CONFIG_ENV_IS_IN_NAND)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_OFFSET		(37 << 20)
+#define CONFIG_ENV_SECT_SIZE		(128 << 10)
+#define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+#define CONFIG_SYS_FSL_USDHC_NUM	1
+#else
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#endif
+#define CONFIG_SYS_MMC_ENV_DEV		0   /* USDHC1 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
+#define CONFIG_MMCROOT			"/dev/mmcblk0p2"  /* USDHC1 */
+
+#define CONFIG_OF_LIBFDT
+#define CONFIG_CMD_BOOTZ
+
+#define CONFIG_CMD_BMODE
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+#define CONFIG_CMD_CACHE
+#endif
+
+#define CONFIG_VIDEO
+#define CONFIG_CMD_EADISP
+
+#ifdef CONFIG_VIDEO
+#define	CONFIG_CFB_CONSOLE
+#define	CONFIG_VIDEO_MXS
+#define	CONFIG_VIDEO_LOGO
+#define	CONFIG_VIDEO_SW_CURSOR
+#define	CONFIG_VGA_AS_SINGLE_DEVICE
+#define	CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define	CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define	CONFIG_CMD_BMP
+#define	CONFIG_BMP_16BPP
+#define	CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_VIDEO_BMP_LOGO
+#endif
+
+/* #define CONFIG_SPLASH_SCREEN*/
+/* #define CONFIG_MXC_EPDC*/
+
+/*
+ * SPLASH SCREEN Configs
+ */
+#if defined(CONFIG_SPLASH_SCREEN) && defined(CONFIG_MXC_EPDC)
+/*
+ * Framebuffer and LCD
+ */
+#define	CONFIG_CFB_CONSOLE
+#define CONFIG_CMD_BMP
+#define CONFIG_LCD
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+
+#undef LCD_TEST_PATTERN
+/* #define CONFIG_SPLASH_IS_IN_MMC			1 */
+#define LCD_BPP					LCD_MONOCHROME
+/* #define CONFIG_SPLASH_SCREEN_ALIGN		1 */
+
+#define CONFIG_WAVEFORM_BUF_SIZE		0x400000
+#endif
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX7
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+
+#define CONFIG_IMX_THERMAL
+
+#if defined(CONFIG_MXC_EPDC) && defined(CONFIG_SYS_USE_QSPI)
+#error "EPDC Pins conflicts QSPI, Either EPDC or QSPI can be enabled!"
+#endif
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "mx7dsabresdandroid.h"
+#endif
+#endif	/* __MX7D_UCOM_KIT_CONFIG_H */
